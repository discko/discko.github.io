---
title: LC-0258-各位相加
tags:
  - LeetCode
  - Math
categories: LeetCode
mathjax: true
date: 2020-09-17 16:33:12
---

# 题干
给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
<!--more-->
示例:  

> 输入: 38  
> 输出: 2   
> 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。  

进阶:  
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？


# 分析
我们就直接挑战进阶难度吧。这是一个数学问题。  

## 引理
先放结论：一个数对9的余数，等于该数各位数字之和对9的余数。  
**如果觉得太长了，或者对这个引理比较了解，可以直接跳到下一节。**  

下面开始引理部分。  
我记得小学的时候我的一位数学老师（我只记得姓马了），交给我们一个快速检验乘法结果是否正确的验算的方法，叫做“弃九法”（又叫“去九法”）。大致流程是这样的：  
* 对于乘法运算$A\times B=C$，将十进制的$A$、$B$、$C$各位拆开，分别相加  
* 如果相加的结果超过1位数，则继续拆开相加，直到最终为1位数  
* 记$A$最终的结果为$A'$，同理$B$的为$B'$，$C$的为$C'$  
* 将$A'$与$B'$相乘，若乘积结果超过1位数，则各位拆开相加直到为1位数，记为$D$  
* 如果$C'=D$则$A\times B=C$的计算可能是正确的。但若$C'\ne D$则$A\times B=C$的计算一定是错误的

举个例子，（[例子来源](https://baike.baidu.com/item/%E5%8E%BB%E4%B9%9D%E6%B3%95/7994203?fromtitle=%E5%BC%83%E4%B9%9D%E6%B3%95&fromid=7664454&fr=aladdin)），在计算$19786901\times8098678443=160247748582475143$时，我们首先将两个乘数各位拆开相加，积的各位也拆开相加：  
$$
\begin{aligned}
& 19786901 &\Rightarrow 1+9+7+8+6+9+0+1=41 \Rightarrow 4+1=5 \\
& 8098678443 &\Rightarrow 8+0+9+8+6+7+8+4+4+3=57 \Rightarrow 5+7=12 \Rightarrow 1+2=3 \\
& 160247748582475143 &\Rightarrow 1+6+0+2+4+7+7+4+8+5+8+2+4+7+5+1+4+3=78 \\ & &\Rightarrow 7+8=15 \Rightarrow 1+5=6 
\end{aligned}  
$$
这其中$A'=5$，$B'=3$，$C'=6$   

然后：$D=A'\times B'=5\times3=15 \Rightarrow 1+5=6$，即$D=C'$，所以上面那个乘法计算是可能正确的。  

当然，这个方法主要是用来验错的（即如果$D\ne C'$，则计算是一定错误的）而不是用来验对的，毕竟最简单的例子，$12\times6=72$和$12000\times6=72$两个式子中，$A'$、$B'$、$C'$、$D$是一模一样的，但显然后一个式子是错的。

当然，本篇的目的不是讲弃九法，而是讲弃九法背后的一个数学原理，或者说数学巧合，那就是“一个数对9的余数，等于该数各位数字之和对9的余数”。如果一个十进制数是$\overline{A_n\cdots A_1A_0}$，（也即最高位、十位、个位分别是$A_n$、$A_1$、$A_0$），则$\overline{A_n\cdots A_1A_0} \equiv A_n+\cdots+A_1+A_0 \pmod9$。即$\overline{A_n\cdots A_1A_0}$和$A_n+\cdots+A_1+A_0$在模9时是同余的（不太恰当的说法，在对9取余时，两个数$\overline{A_n\cdots A_1A_0}$和$A_n+\cdots+A_1+A_0$是等价的）。   
要怎么证明呢，其实也简单：  
$$
\begin{aligned}
\overline{A_n\cdots A_1A_0} &= A_n\times10^n+\cdots+ A_1\times10+A_0 \\
                            &= A_n\times(\overline{\underbrace{9\cdots9}_{n个9}}+1)+\cdots+A_1\times(9+1)+A_0 \\
                            &= (A_n\times\overline{\underbrace{9\cdots9}_{n个9}}+\cdots+A_1\times9)+(A_n+\cdots+A_1+A_0) \\
                            &= 9\times(A_n\times\overline{\underbrace{1\cdots1}_{n个1}}+\cdots+A_1\times1)+ (A_n+\cdots+A_1+A_0) \\
                            &= 9\times N + (A_n+\cdots+A_1+A_0) \\
\end{aligned}
$$
同时，我们知道$(A+B)\%m=(A\%m+B\%m)\%m$的，所以：
$$
\begin{aligned}
\overline{A_n\cdots A_1A_0}\%9 &= (9\times N + (A_n+\cdots+A_1+A_0))\%9 \\
                               &= ((9\times N)\%9) + (A_n+\cdots+A_1+A_0)\%9)\%9 \\
                               &= (0+ (A_n+\cdots+A_1+A_0)\%9)\%9 \\
                               &= (A_n+\cdots+A_1+A_0)\%9
\end{aligned}
$$
也即，
$$
\overline{A_n\cdots A_1A_0} \equiv A_n+\cdots+A_1+A_0 \pmod 9
$$
引理证毕。

## 回到题目
写了这么长，都快忘记题目是什么了。再来回顾一下：   
> 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

有没有很眼熟。引理是各位数字相加后对9的余数，和这个数对9的余数是相同的；题目是求反复将一个数的各位数相加，直到1位数。那么这两个是否等价呢？   
我们举两个例子先：比如$123$、$32768$、$90$、$153$。  
$$
\begin{aligned}
123\%9=6 &\Leftrightarrow 1+2+3=6 \\
32768\%9=8 &\Leftrightarrow 3+2+7+6+8=26\rightarrow2+68 \\
90\%9=0 &\nLeftrightarrow 9+0=9 \\
153\%9=0 &\nLeftrightarrow 1+5+3=9
\end{aligned}
$$
似乎找到了一些规律，如果目标数不是9的倍数，那么引理和题目要求是一致的；如果目标数恰是9的倍数，那么结果不正确。当然这也是容易证明的。   
**不想看证明的，可以再次跳关到下一节。**

对于$\overline{A_n\cdots A_1A_0} \equiv A_n+\cdots+A_1+A_0 \pmod 9$，我们不妨设   
$$A_n+\cdots+A_1+A_0=\overline{B_m\cdots B_1B_0}$$   
而且很容易证明$\overline{A_n\cdots A_1A_0} > A_n+\cdots+A_1+A_0$。   
同时$n\ge m$，并且只有两个情况$n=m$。   
* 一个是$n=m=1$时，此时就不需要再进行拆位加和了   
* 另一个是$n=2$且$A_1+A_2\ge10$时。由于$A_1+A_0\in[2,18]\in N$，所以$B_1+B_0\in[1,9]\in Z$。   
所以数的位数是在不断缩小的。最终就会变成一位数，比如$C_0$。   
则根据引理有：   
$$\overline{A_n\cdots A_1A_0}\equiv\underbrace{A_n+\cdots+A_1+A_0\equiv\overline{B_m\cdots B_1B_0} \equiv B_m+\cdots+B_1+B_0 \equiv C_0}_{题目要求} \pmod 9$$   
这一部分，其实就是题目要求的过程。  


那么诸如$90$、$153$这样是9的倍数的（或者说模9余0的）数，有是怎么回事呢？其实也很好理解。对于这个同余式：   
$$
\overline{A_n\cdots A_1A_0} \equiv A_n+\cdots+A_1+A_0 \pmod 9
$$
我上面说了，也可以这么理解，就是$\overline{A_n\cdots A_1A_0}$和$A_n+\cdots+A_1+A_0$是等价的，不过是在$\pmod 9$的情况下。那么回到上面$90$和$153$这两个不等价的表达式，其实都没有写完。正确的应当是：   
$$
\begin{aligned}
90\%9=0 &\Leftrightarrow 9+0=9 \rightarrow 9\%9=0 \\
153\%9=0 &\Leftrightarrow 1+5+3=9 \rightarrow 9\%9=0
\end{aligned}
$$
即，最后需要再模9，才是最终结果。这就是引理和题目唯一有偏差的地方。题目只需要到一位数就可以了，9是一位数，但还可以模9。   

## 解决问题
问题分析到这里，已经比较简单，大的方向就是把“反复将`num`各个位上的数字相加，直到结果为一位数”转换为求`num`对9的余数。唯一的漏洞就是如果`num`是9的倍数，那就不准了。为此，可以提出两个解决方案。  
* 替换法   
对于`num`是9的倍数的情况，余数是0。而在仿真的情况下（即“反复将`num`各个位上的数字相加，直到结果为一位数”），是不可能得到0的。因为一个数的每一位上的数一定是一个非负数，而多个非负数相加的结果为0的情况，就只有这些非负数都是0的情况，这个情况是不能支撑`num`存在的。（除非恰好`num=0`）   
所以，当遇到余数是0的情况，如果`num`不为0，则结果就是9，如果`num`为0，则结果就是0。   
* 拆补法   
上面的写法还不够优雅，需要做一些判断。我们换一个思路。如果我从`num`中先拿走1个，然后对9取余，然后再把拿走的这个放回去。这个是取余运算允许的运算法则：(A+B)%C=(A%C+B%C)%C。由于对9取余的值域是[0,8]，再+1也还仅是1位数。即(A-1)%9+1=((A%9)-1%9)%9+1=A%9-1+1=A%9。这么做还有一个好处，那就是如果A是0的话，A-1=-1，而常见的运行环境（比如C/C++/Java等）都规定取余的符号，是由被除数决定的，所以(A-1)%9+1=-1%9+1=-1+1=0。不需要对0再去做判断了。

# 解题
根据上面两个方案，可以写出下面两个函数，被注释掉的时替换法的，保留的
```java
class Solution {
    // public int addDigits(int num) {
    //     int rt=num%9;
    //     return rt!=0?rt:(num==0?0:9);
    // }
    public int addDigits(int num) {
        return (num-1)%9+1;
    }
}
```

# 复杂度分析
没什么好分析的了吧，时间复杂度和空间复杂度，两种方案都是$O(1)$，只不过后一个看上去更优雅一点而已。

# 后记
一个Easy难度的题目，写了这么多。感觉有点累啊-，-特别是公式写起来。不过还是很有收获的。