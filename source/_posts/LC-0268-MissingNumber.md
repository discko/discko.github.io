---
title: LC-0268-缺失数字
tags:
  - LeetCode
  - Math
  - BitManipulation
categories: LeetCode
mathjax: true
date: 2020-09-18 10:04:10
---


# 题干
给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。
<!--more-->
示例 1:  
> 输入: [3,0,1]  
> 输出: 2  

示例 2:  
> 输入: [9,6,4,2,3,5,7,0,1]  
> 输出: 8  

说明:
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

# 分析
这个题干，多读一下，就能理解了。也就是现在有0到n一共n+1个数，从中抽取n个数字，乱序组成一个数组。找出没被抽中的那一个。   
那很好办呀。稍微转一转，脑子里就出现了2种方法，还不算Hash法（毕竟Hash法就需要$O(n)$的空间了。  

## 方法一：数学法
原来的序列和现在的数组比，除了顺序之外，就多了一个数。那就把原来的所有数全都加起来，然后减掉这个数组中所有数的和，剩下的就是多了的（没被选中的）那个数了。而原来所有的数，是一个等差数列，利用高斯小朋友快速计算1~100的和的方法，就能够计算出来，也就是：
$$
sum=\frac{n(n+1)}{2}
$$
不过这种解法需要注意，如果`n`很大的话，可能会使所选择的存储类型溢出，因此需要注意。那这时候存储`sum`的就应当取`n`的大小能够存储下的最小位数2倍的类型来存储。  
当然，如果不使用高斯公式的话，在遍历时，一边加（序数）一边减（数组中的数），就能缓解累加溢出的速度，不过数量级上还是一样的，不建议这么做。


## 方法二：位运算法
如果把原来的序列和现在的数组混合在一起，那么就回到了一道经典的题：  
> 一个数组中，所有的数都出现了2次，只有一个数只出现了1次，找出那个只出现了1次的数。  
这个问题，利用异或就可以轻松解决。

# 解题
```java
class Solution {
/*
Solution 1
    public int missingNumber(int[] nums) {
        //nums.length == n
        long ans=(1+nums.length)*(nums.length)/2;
        for(int num:nums){
            ans-=num;
        }
        return (int)ans;
    }
*/
    public int missingNumber(int[] nums) {
        int ans=nums.length;
        for(int i=0;i<nums.length;i++){
            ans^=i^nums[i];
        }
        return ans;
    }
}
```