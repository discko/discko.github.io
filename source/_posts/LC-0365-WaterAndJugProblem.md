---
title: LC-0365-水壶问题
tags:
  - LeetCode
  - BFS/DFS
  - Math
categories: LeetCode
mathjax: true
date: 2020-09-21 14:46:04
---

# 题干
有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？  

如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升水。  

你允许：  

* 装满任意一个水壶  
* 清空任意一个水壶  
* 从一个水壶向另外一个水壶倒水，直到装满或者倒空  
<!--more-->

示例 1: (From the famous ["Die Hard" example](https://www.youtube.com/watch?v=BVtQNK_ZUJg))

> 输入: x = 3, y = 5, z = 4
> 输出: True

示例2：  

> 输入: x = 2, y = 6, z = 5  
> 输出: False

# 方法一
## 分析
在没有什么更好的办法之前，我们按照自仿真的办法来模拟一下。对于任意一个时刻，我们可以认为水壶中，只会有“空”、“有水”三个状态，对于每一个水壶，我们可以执行“加满”、“倒空”、“倒入另一个水壶”三个动作。对这三个状态，和三个行为，我们可以定义出如下几种行为（我们设A罐的最大容量为$x$，当前水量为$a$；B罐的最大容量为$y$，当前水量为$b$；且$x≤y$：  
1.   当$a=0$时，$a'=x$，$b'=b$（即利用外部水源，将A罐从空装满）  
2.   当$b=0$时，$b'=y$，$b'=a$（即利用外部水源，将B罐从空装满）  
3.   当$a=x$时，$a'=0$（即将A罐清空）  
4.   当$b=y$时，$b'=0$（即将B罐清空）  
5.   当$a>0$时，若$a+b>y$，则$a'=a+b-y$，$b'=y$；若$a+b\le y$，则$a'=0$，$b'=a+b$（即将A罐中的水倒入B罐）    
6.   当$b>0$时，若$a+b>x$，则$a'=x$，$b'=a+b-x$；若$a+b\le x$，则$a'=a+b$，$b'=0$（即将B罐中的水倒入A罐）  

其他行为都可以认为是非法的。  

可能有人会问，如果A罐中有水，但不满，也可以执行1.的行为呀。没错，现实生活中是可以的，但是在这个题目的环境中是没有意义的。  
我们举个例子，对于$\{x=3, y=5\}$的情况，先将B罐装满得到$(a,b)=(0,5)$，然后将B罐中的水倒入A罐$(a,b)=(3,2)$。这时候我们将B罐装满$(a,b)=(3,5)$，这和直接从$(a,b)=(0,0)$开始，先后利用外部水源将两个罐子装满没有区别。  

那么，这时候，我们就可以利用DFS或BFS，对这六个状态进行深度优先搜索，直到A罐或B罐或两罐中总共的水量是$z$为止。  
根据网上的意见，此题如果使用递归的DFS的话，可能会因递归栈过深而爆栈。为此，我们利用队列进行BFS。在BFS的过程中，将已经遇到过的$(a,b)$记录下来，以免重复。  

最终的代码如下：  

## 解题
```java
class Solution {
    //a structure to record two tins
    static final class Tins{
        int a;
        int b;
        Tins(int a, int b){
            this.a=a;this.b=b;
        }
        public int hashCode(){
            return java.util.Objects.hash(a,b);
        }
        public boolean equals(Object other){
            return this==other || (other != null && other instanceof Tins && a==((Tins)other).a&&b==((Tins)other).b);
        }

    }

    public boolean canMeasureWater(int x, int y, int z) {
        if(x+y<z || z<0 || x<0 || y<0){
            return false;
        }
        //special cases: {x=0, y=0, z=0}, {x=1, y=0, z=0}
        if(z==0 || x+y==z){
            return true;
        }
        
        HashSet<Tins> visited=new HashSet<>();
        ArrayDeque<Tins> queue=new ArrayDeque<>();
        
        Tins root=new Tins(0,0), full=new Tins(x,y);
        queue.offer(root);
        visited.add(root);
        
        while(!queue.isEmpty()){
            Tins tins=queue.poll();
            for(int condition=0;condition<6;condition++){
                Tins newTins=changeTins(full, tins.a, tins.b, condition);

                if(newTins==null||visited.contains(newTins)){
                    continue;
                }
                if(newTins.a==z||newTins.b==z||newTins.a+newTins.b==z){
                    return true;
                }else{
                    visited.add(newTins);
                    queue.offer(newTins);
                }
            }
        }

        return false;
    }
    
    public Tins changeTins(Tins full, int a, int b, int condition){
        Tins tins=null;
        switch(condition){
            case 0:
                if(a==0){
                    tins=new Tins(full.a, b);
                }
                break;
            case 1:
                if(b==0){
                    tins=new Tins(a, full.b);
                }
                break;
            case 2:
                if(a==full.a){
                    tins=new Tins(0, b);
                }
                break;
            case 3:
                if(b==full.b){
                    tins=new Tins(a, 0);
                }
                break;
            case 4:
                if(a>0){
                    tins=a+b>full.b?new Tins(a+b-full.b, full.b):new Tins(0, a+b);
                }
                break;
            case 5:
                if(b>0){
                    tins=a+b>full.a?new Tins(full.a, a+b-full.a):new Tins(a+b, 0);
                }
                break;
        }
        return tins;
    }
}
```

# 小结
利用BFS进行处理，代码写起来本身不麻烦，各个条件的处理也还算简单。期间撞了两个没有考虑到的测试用例：$\{x=1,y=0,z=0\}$和$\{x=0,y=0,z=0\}$。  
最终的运行结果没有问题，但是复杂度较高，上面的这套代码对36个OJ的测试用例，耗时在500ms上下，空间占用94MB+。所以一定是有更简单的办法的。

时间上，不做过细的分析的话，A罐内可取的状态有$[0,x]$共$x+1$个，B罐内可取的状态有$[0,y]$共$y+1$个，BFS的时候的时间复杂度是$O(1)$，所以最终的时间复杂度不坏于$O(xy)$。  

空间上，由于`queue`和`visited`两个最坏时需要将所有经历过的状态全部存下来，所以应该两倍于A罐和B罐的联合可能数，故空间复杂度是$O(xy)$。


# 方法二
## 分析
在思考方法一的时间和空间复杂度的时候，我就在想，到底会有多少个BFS的结点呢。于是我们来做一下实验。

* 对于$\{x=3, y=5\}$的情况，我们可以称量的有：  
8（A罐和B罐都装满，记作【12】)  
7（B罐装满0+5，B罐倒入A罐3+2，倒光A罐0+2，B罐倒入A罐2+0，B罐装满2+5，记作【26362】）  
6（B罐装满0+5，B罐倒入A罐3+2，A罐倒光0+2，B罐倒入A罐2+0，B罐装满2+5，B罐倒入A罐3+4，A罐倒光0+4，B罐倒入A罐3+1，A罐倒光0+1，B罐倒入A罐1+0，B罐装满1+5，记作【2636263632】）  
5（【2】）  
4（【263626】）  
3（【1】）  
2（【26】）  
1（【26362636】）
0

* 对于$\{x=18,y=30\}$的情况，我们可以称量的有：  
48（【12】）    
42（B罐装满0+30，B罐倒入A罐18+12，A罐倒光0+12，B罐倒入A罐12+0，B罐装满12+30，【26362】）
36（B罐装满0+30，B罐倒入A罐18+12，A罐倒光0+12，B罐倒入A罐12+0，B管装满12+30，B罐倒入A罐18+24，A罐倒光0+24，B罐倒入A罐18+6，A罐倒光0+6，B罐倒入A罐6+0，B罐装满6+30，【26362636362】）  
30（【2】）  
24（【263626】）  
18（【1】）  
12（【26】）  
6（【26362636】）  
0  

有没有发现什么规律，我们能够得到的所有的可取的值，是从$0$到$x+y$间所有的$x$和$y$的最大公约数的倍数的数。但是这个最大公约数是怎么来的呢。我们看上面两个例子中，很多的步骤都是“B装满，B倒入A，A倒掉，B再倒入A”（也就是2636），像不像更相减损术？  

知道了这个，那么代码写起来就很简单了。

## 解题
```java
class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        if(x+y<z || z<0 || x<0 || y<0){
            return false;
        }
        if(x+y==z||z==0){
            return true;
        }
        // if(x>y){
        //     x^=y;
        //     y^=x;
        //     x^=y;
        // }
        while(y!=0){
            int t=x%y;
            x=y;
            y=t;
        }
        return z%x==0;
    }
}
```

## 小结
代码中使用的是辗转相除法来求$gcd$，而不是更相减损术。注释掉的部分是保持$x\le y$的，不过应该问题不大，毕竟如果$x\ge y$的话，也就多做一轮辗转相除法而已。最终辗转相除法中较大的那个数就是$gcd$。  
这样的话，复杂度就是这样的：  
时间上，我们将取余运算作为$O(1)$单位时间的话，那么最坏的情况下的时间复杂度是$O(\log n)$。（[辗转相除法的时间复杂度见此](https://www.cnblogs.com/DeepJay/p/12025190.html)，感觉很巧妙啊）。  

空间上，仅使用了常数的空间，因此空间复杂度是$O(1)$。  
提交后，时间稳定在了1ms左右。

## 尝试证明
上面我们直接含糊地一语带过了最重要的部分，那就是怎么确定这个问题和“$z$能否被$x$和$y$的最大公约数整除”是等价的。接下来，我就来尝试着证明这个问题。  

首先，我们要确定一件事情，那就是可不可能两个罐子里，都有水，但是不满？我想这个应该没有问题吧，根据“方法一”中的6个行为，被操作的罐子中，至少有一个是空的（3、4、5.2、6.2）、至少有一个是满的（1、2、5.1、6.1），再没有其他的可能了。所以，两个罐子里，不可能都只有半壶水。  
接下来，对上面的6个行为做一下量化：  
1. 当A罐空时，A罐装满，即$a'=0+x, b'=b$。  
2. 当B罐空时，B罐装满，即$a'=a, b'=0+y$。  
3. 当A罐满时，A罐倒光，即$a'=x-x, b'=b$。
4. 当B罐满时，B罐倒光，即$a'=a, b'=y-y$。
5. 当A罐非空时，A罐向B罐倒，倒完之后，A和B中只有一个是半壶水。  
6. 当B罐非空时，B罐向A罐倒，倒完之后，A和B中只有一个是半壶水。  

同时，我们可以推导出“两个罐子里不可能都是空的”（这样就回到了初始状态），和“两个罐子里不可能都是满的”（这样下一步必然是3或4，那就相当于只做了2或1）。同时，5和6作为互逆的操作，不可以紧接着前后做。  
接下来，我们做一些简单的模拟。

首先我们假设$x\le y$，且$mx < y <(m+1)x$。然后假设第1步我们是将A罐装满的，记作$(x,0)@1$。  
此时对于6个行为：  

* ~~装满A~~，不可以。因为此时A已经是满的了。  
* ~~装满B~~，不可以。因为两个罐子里不可以都是满的。  
* ~~倒光A~~，不可以。因为两个罐子不可以都是空的。  
* ~~倒光B~~，不可以。因为此时B已经是空的了。  
* 将A倒入B，可以。这时得到$(0,x)@2$。  
    * 装满A，可以。这时得到$(x,x)@3$  
        * ~~装满A~~，不可以。因为此时A已经是满的了。  
        * ~~装满B~~，不可以。因为两个罐子里不可以都是满的。  
        * ~~倒光A~~，不可以。因为这样就回到了上一步。  
        * ~~倒光B~~，不可以。因为这样就相当于$(x,0)@1$。  
        * 将A倒入B，可以。这时得到$(0,2x)@3$。接下来不断重复此步，***过程中B的水量从$x$、$2x$一直到$mx$***，直到B装满，此时得到$(y-mx,y)@3$。  
            * ~~装满A~~，不可以。因为两个罐子不可以都是满的。  
            * ~~装满B~~，不可以。因为B已经是满的了。  
            * ~~倒光A~~，不可以。因为这样相当于$(0,y)@1$。  
            * 倒光B，可以。这样可以得到$(y-mx,0)@4$。  
                * ~~装满A~~，不可以。因为这样就相当于$(x,0)@1$。  
                * ~~装满B~~，不可以。因为这样就回到了上一步。  
                * ~~倒光A~~，不可以。因为两个罐子不可以都是空的。  
                * ~~倒光B~~，不可以。因为此时B已经是空的了。
                * 将A倒入B，可以。这样可以得到$(0,y-mx)@5$。  
                    * 装满A，可以。这样就得到了$(x,y-mx)@6$。  
                        * ~~装满A~~，不可以。因为此时A已经是满的了。  
                        * ~~装满B~~，不可以。因为两个罐子不可以都是满的。  
                        * ~~倒光A~~，不可以。因为这样就回到了上一步。  
                        * ~~倒光B~~，不可以。因为这样就相当于$(x,0)@1$。  
                        * ***将A倒入B，可以。这样就得到了$(0,y-(m-1)x)@6$。***  
                        * ~~将B倒入A~~，不可以。因为A已经是满的了。
                    * ~~装满B~~，不可以。因为两个罐子不可以都是满的。  
                    * ~~倒光A~~，不可以。因为此时A已经是空的了。  
                    * ~~倒光B~~，不可以。因为两个罐子不可以都是空的。  
                    * ~~将A倒入B~~，不可以。因为此时A已经是空的了。  
                    * ~~将B倒入A~~，不可以。因为这和上一步互逆。
                * ~~将B倒入A~~，不可以。因为此时B已经是空的了。  
            * ~~将A倒入B~~， 不可以。因为此时B已经是满的了。  
            * 将B倒入A，可以。这样就得到了$(x,2y-(m+1)x)@4$。
                * ~~装满A~~，不可以。因为此时A是满的。  
                * ~~装满B~~，不可以。因为两个罐子不可以都是满的。  
                * 倒光A，可以。这样就得到了$(0,2y-(m+1)x)@5$。  
                    * ~~装满A~~，不可以。因为这样就回到了上一步。  
                    * ~~装满B~~，不可以。因为这样相当于$(0,y)@1$。  
                    * ~~倒光A~~，不可以。因为此时A已经是空的了。  
                    * ~~倒光B~~，不可以。因为两个罐子不可以都是空的。
                    * ~~将A倒入B~~，不可以。因为此时A已经是空的了。 
                    * ***将B倒入A，可以。这样就得到了$(x,2y-(m+2)x)@6$。接下来不断重复此步m-1次，直到B内不足$x$，得到$(x,2y-(2m+1)x)@m+5$***
                * ~~倒光B~~，不可以。因为这样就相当于$(x,0)@1$。
                * ~~将A倒入B~~，不可以。因为这和上一步互逆。 
                * ~~将B倒入A~~，不可以。因为这时A已经是满的了。  
        * ~~将B倒入A~~，不可以。因为这时A已经是满的了。  
    * ~~装满B~~，不可以。这样就相当于$(0,y)@1$   
    * ~~倒光A~~，不可以。此时A已经是空的了。  
    * ~~倒光B~~，不可以。两个罐子不可以都是空的。  
    * ~~将A倒入B~~，不可以。此时A已经是空的了。  
    * ~~将B倒入A~~，不可以。因为这和上一步互逆。  
* ~~将B倒入A~~，不可以。因为此时B已经是空的了。  

经过上面的推演，我们发现，历史的进程会有三个阶段。  

1. 第一个阶段，B罐中的水量从$x$、$2x$一直到$mx$。接下来会进入两个分支
2. 如果是分支一，到A罐为空，B罐内是$y-(m-1)x$的量，然后接下来呢？我们按照下面的继续。接下来每2步，B罐内的水容量就会减少1个$x$。在$5+2(m-1)$步之后，得到$(0,y-x)@3+2m$。在此过程中，B罐将会以此装有$y$、$y-x$、$y-2x$一直到$y-mx$的水量。：    
    * 装满A，可以。这样就得到了$(x,y-(m-1)x)@7$。  
        * ~~装满A~~，不可以。因为这时A已经是满的了。
        * ~~装满B~~，不可以。因为两个罐子不可以都是满的。  
        * ~~倒光A~~，不可以。因为这样就回到了上一步。  
        * ~~倒光B~~，不可以。因为这样就相当于$(x,0)@1$。  
        * ***将A倒入B，可以。这样就得到了$(0,y-(m-2)x)@8$。***  
        * ~~将B倒入A~~，不可以。因为A已经是满的了。
    * ~~装满B~~，不可以。因为这样相当于$(0,y)@1$。  
    * ~~倒光A~~，不可以。因为A已经是空的了。  
    * ~~倒光B~~，不可以。因为两个罐子不可以都是空的。  
    * ~~将A倒入B~~，不可以。因为A已经是空的了。  
    * ~~将B倒入A~~，不可以。因为这和上一步互逆。  
3. 如果是后分支二，B罐中的水量，将会从$2y-(m+1)x$开始，每一步增加$x$的水量，直到$2y-(2m+1)x$。  

有没有发现点什么。每一步的操作，都会使B罐的水量在$mx+ny$中，而且根据最小水量$(0,0)$、最大水量$(x,y)$我们知道，$mx+ny$的限制条件是：$0\le mx+ny \le x+y\quad|\quad x,y\in Z$。那么只要某个$mx+ny=z$，就说明这两个水壶可以装$z$的水。

这时候我们就要请出我们的 [裴蜀定理（贝祖定理）](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86)。这个定理是这样描述的：  

> 若$x,y$是整数,且$\gcd(x,y)=d$，那么对于任意的整数$x,y,ax+by$都一定是d的倍数。  

所以，也就是说，如果$z$是$x,y$最大公约数的倍数，那么这个水壶问题就有解。