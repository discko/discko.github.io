---
title: LC-0672-灯泡开关II
tags:
  - LeetCode
  - Math
categories: LeetCode
mathjax: true
date: 2020-10-12 18:48:18
---


# 题干
现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。
<!--more-->

假设这 n 只灯泡被编号为 [1, 2, 3 ..., n]，这 4 个按钮的功能如下：

1. 将所有灯泡的状态反转（即开变为关，关变为开）  
2. 将编号为偶数的灯泡的状态反转  
3. 将编号为奇数的灯泡的状态反转  
4. 将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, ...)  

示例 1:

> 输入: n = 1, m = 1.  
> 输出: 2  
> 说明: 状态为: [开], [关]  

示例 2:

> 输入: n = 2, m = 1.  
> 输出: 3  
> 说明: 状态为: [开, 关], [关, 开], [关, 关]  

示例 3:

> 输入: n = 3, m = 1.  
> 输出: 4  
> 说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].  

注意： n 和 m 都属于 [0, 1000].

# 分析
刚那道题的时候一脸懵逼，不过做了一点分析之后，就豁然开朗。  
首先，上述4个动作中，1作用于所有数（1的倍数），2作用于所有偶数（2的倍数），3作用于所有奇数（2的倍数+1），4作用于所有3的倍数+1。那么很容易就想到，我们需要分析的灯泡数n应当是不超过6的（因为6是1、2、3的最小公倍数）。  
然后我们来看对于6个及以内的n（灯泡数）情况下，有哪些组合情况。  

当然，我们仍然需要确定的是，这个跟异或位运算一样，交换操作步骤的执行顺序，是不影响最终结果的。因为最终归结到某一位上，这一位最终就是“应当执行几次取反操作”。比如4123这个执行，对于1号灯泡（根据题干，是从1开始编号的），有4、1、3三个动作要求其取反，那么就$0\rightarrow 1 \rightarrow 0 \rightarrow 1$这样。  

好，接下来我们来看看对于6个灯泡的操作组合情况：  

|     |灯泡1|灯泡2|灯泡3|灯泡4|灯泡5|灯泡6|   |
|:--: |:--:|:--:|:--:|:--:|:--:|:--:|:--:|  
|原始|0|0|0|0|0|0|  |
|1  |1|1|1|1|1|1|   |
|2  |0|1|0|1|0|1|   |
|3  |1|0|1|0|1|0|   |
|4  |1|0|0|1|0|0|   |
|12 |1|0|1|0|1|0|相当于2步的3|
|13 |0|1|0|1|0|1|相当于2步的2|
|14 |0|1|1|0|1|1|   |
|23 |1|1|1|1|1|1|相当于2步的1|
|24 |1|1|0|0|0|1|   |
|34 |0|0|1|1|1|0|
|123|0|0|0|0|0|0|   |
|124|0|0|1|1|1|0|相当于3步的34|
|234|0|1|1|0|1|1|相当于3步的14|
|1234|1|0|0|1|0|0|相当于4步的4|  

除了“原始”那1行，6个“相当于”的重复行，还剩下8个可能的状态。  

那么至此，其实已经差不多分析出来了。  
如果$n\ge6$：  
$$
\begin{equation*}
ans=\left\{
\begin{aligned}
& 4, & &m=1 \\
& 7, & &m=2 \\
& 8, & &m\ge3
\end{aligned}
\right.
\end{equation*}
$$
当然，同理可以列出$n=5$、$n=4$等等的情况。但是感觉好麻烦啊。  

我们发现，最多也就8中情况，竟然占了6位（6个灯泡），理论上应该只需要3个灯泡就可以全部表示了。那是不是说后3个灯泡与前三个灯泡有什么关系呢？确实是这样的。我们还是按照各个位的情况来分析。

如果设操作1执行了为$O_1$次，操作2执行了$O_2$次，操作3执行了$O_3$次，操作4执行了$O_4$次，则对于这6个灯泡有：  
$$
\begin{equation*}
\left\{
\begin{aligned}
& 灯泡1=& &(O_1+O_3+O_4)\%2 \\
& 灯泡2=& &(O_1+O_2)\%2 \\
& 灯泡3=& &(O_1+O_3)\%2 \\
& 灯泡4=& &(O_1+O_2+O_4)\%2 \\
& 灯泡5=& &(O_1+O_3)\%2 \\
& 灯泡6=& &(O_1+O_2)\%2
\end{aligned}
\right.
\end{equation*}
$$  

我们对这个式子里的顺序做一下交换：  
$$
\begin{equation*}
\left\{
\begin{aligned}
& 灯泡2=& &(O_1+O_2)\%2 \\
& 灯泡6=& &(O_1+O_2)\%2 \\
& 灯泡4=& &(O_1+O_2+O_4)\%2 \\
& 灯泡3=& &(O_1+O_3)\%2 \\
& 灯泡5=& &(O_1+O_3)\%2 \\
& 灯泡1=& &(O_1+O_3+O_4)\%2 \\
\end{aligned}
\right.
\end{equation*}
$$   

可以发现，灯泡2和灯泡6的行为是完全一致的，灯泡3和和灯泡5的行为是完全一致的。所以最多只需要4个灯泡就行了：
$$
\begin{equation*}
\left\{
\begin{aligned}
& 灯泡1=& &(O_1+O_3+O_4)\%2 \\
& 灯泡2=& &(O_1+O_2)\%2 \\
& 灯泡3=& &(O_1+O_3)\%2 \\
& 灯泡4=& &(O_1+O_2+O_4)\%2 \\
\end{aligned}
\right.
\end{equation*}
$$  

那还可以再少1个灯泡么？我们继续看。  
在上面的式子里，灯泡1比灯泡2多了一个$O_4$，灯泡4比灯泡3也多了一个$O_4$。如果$O_4$是偶数的话，那么灯泡1和灯泡2是一样的，同时灯泡3和灯泡4是一样的；如果$O_4$是奇数的话，那么灯泡1和灯泡2相异，同时灯泡3和灯泡4相异。  
那么换一个说法：如果灯泡1与灯泡2相同，那么灯泡3与灯泡4相同；如果灯泡1余灯泡2相异，则灯泡3与灯泡4相异。用式子表示的话，就是：  

$$
\begin{equation*}
\left\{
\begin{aligned}
& 灯泡1=& &(O_1+O_3+O_4)\%2 \\
& 灯泡2=& &(O_1+O_2)\%2 \\
& 灯泡3=& &(O_1+O_3)\%2 \\
& 灯泡4=& &灯泡1\oplus灯泡2\oplus灯泡3 \\
\end{aligned}
\right.
\end{equation*}
$$  
其中$\oplus$是异或符号，当然，换成程序语言的话就是`灯泡4 = 灯泡1==灯泡2 ? 灯泡3 : !灯泡3`。但这都不影响灯泡4可以用前三个灯泡来表示。这样一来，表格可以简化为：  

|     |灯泡1|灯泡2|灯泡3|
|:--: |:--:|:--:|:--:|
|1  |1|1|1|
|2  |0|1|0|
|3  |1|0|1|
|4  |1|0|0|
|14 |0|1|1|
|24 |1|1|0|
|34 |0|0|1|
|123|0|0|0|

这样看上去，就很清爽了。我们可以根据$n$和$m$去列出所有的情况。  

* 当$n=0$时，灯泡排列数为0；
* 当$m=0$且$n\ne0$时，灯泡排列数为1；
* 当$n=1$且$m\ne0$时，灯泡排列数为2（见前4行，前1列）；
* 当$n=2$且$m\ne0$时，  
    * 如果$m=1$，则灯泡排列数为3（见前4行，前2列，有11、01、10三种可能）；
    * 如果$m\ge2$，则灯泡排列数为4（见前7行，前2列）；
* 当$n\ge3$且$m\ne0$时，
    * 如果$m=1$，则灯泡排列数为4（见前4行，前3列）；
    * 如果$m=2$，则灯泡排列数为7（见前7行，前3列）；
    * 如果$m\ge3$，则灯泡排列数为8（见前8行，前3列）。

最终总结成代码：

# 解题
```java
class Solution {
    public int flipLights(int n, int m) {
        if(n<=0){
            return 0;
        }
        if(m==0){
            return 1;
        }
        if(n==1){
            return 2; 
        }
        if(n==2){
            if(m==1){
                return 3;
            }else{
                return 4;
            }
        }
        if(n>=3){
            switch(m){
                case 1:
                    return 4;
                case 2:
                    return 7;
                default:
                    return 8;
            }
        }
        return 0;
    }
}
```

# 复杂度
没什么好分析的，时间复杂度空间复杂度都是$O(1)$。  

