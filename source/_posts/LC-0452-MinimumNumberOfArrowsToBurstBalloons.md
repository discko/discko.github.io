---
title: LC-0452-用最少数量的箭引爆气球
tags:
  - LeetCode
  - Greedy
categories: LeetCode
mathjax: true
date: 2020-09-29 10:16:19
---


# 题干
在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
<!--more-->
示例:

> 输入:  
> [[10,16], [2,8], [1,6], [7,12]]  
>   
> 输出:  
> 2  
>   
> 解释:  
> 对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。  

# 分析
还是实际模拟一下，如果我们现在有一堆气球，我们会如何实际射箭。  
对于已知的两个气球$A(x_\text{a1},x_\text{a2})$和$B(x_\text{b1},x_\text{b2})$，如果选择其中一个座位参考的话比如$A$，如果满足$x_\text{b1}\le x_\text{a2}$则两个气球用一支箭就可以引爆（箭射在$[x_\text{b1}, x_\text{a2}]$之间就可以了）；而如果足$x_\text{a2}\le x_\text{b1}$，则需要两支箭才行。如下图：
![一支箭与两支箭](ExampleCase.png)  

换句话说，如果我选定某一个气球为“这一支箭一定要引爆的气球”的话，那么如果能找到所有起始位置在这个“一定要引爆的气球”的结束位置之前的气球的话，这些气球都可以使用一支箭来引爆。当然了，这些气球的结束为止也必须要在这个“一定要引爆的气球”的起始位置之后。当然，这时候，还会有一个问题，如下图。如果我们选择B作为这个“一定要引爆的气球”，黄线内就是满足上述要求的取余，那么根据上面的逻辑，我们应当可以将BCDE这4个气球都一起引爆，然而事与愿违。    
![错误示例](MustToBurstBalloonFalseCase.png)   
这是为什么呢，因为我们所选取的目标气球B的结尾坐标在后续BCDE这4个气球中不是最左的，为了要将一堆气球引爆，我们要考虑的其实是“所有结束坐标在目标气球结束坐标右侧”且“开始坐标在目标气球结束坐标左侧”的这些气球。

为此，我们应当要对气球的结束坐标按照从小到大排序。这样按照上面的逻辑，就可以引爆这些气球了。  
![正确示例](MustToBurstBalloon.png)   


总结一下，就应该是这样几个步骤：  

1. 对所有气球按照结束为止从小到大进行排序
2. 再取1支箭，选取当前气球作为目标气球$T$（也就是这支箭一定要引爆的气球），并记其结束为止为$T_\text{end}$，并向后遍历所有气球，记当前遍历的气球为$C$，开始位置为 $C_\text{start}$，  
    * 如果$C$的开始位置在T的结束位置之前，即满足 $ C_\text{start} \le T_\text{end} $，则表示可以被一支箭引爆，此时继续向后遍历；  
    * 如果$C$的开始位置在T的结束位置之后，即 $ T_\text{end} \le C_\text{start} $，则这时候C与T不能用一支箭引爆。那么我们需要利用取的那支箭将目前此次遍历到的气球都引爆。然后回到第2步。  
3. 直到所有气球都被引爆。  
4. 数数看一共用了几支箭。  

当然了，写程序的话，我们不需要真的引爆气球。  

# 解题
```java
class Solution {
    public int findMinArrowShots(int[][] balloons) {
        if (balloons.length < 2) {
            return balloons.length;
        }

        Arrays.sort(balloons, (a, b) -> a[1] - b[1]);

        int arrows = 1;
        int Tend = balloons[0][1];
        for (int[] balloon : balloons) {
            //Cstart == balloon[0]
            if (Tend < balloon[0]) {
                arrows++;
                Tend = balloon[1];
            }
        }
        return arrows;
    }
}
// @lc code=end
```

# 复杂度
时间上，排序使用的如果是快速排序，平均情况下的时间复杂度是$O(n\log n)$，最后的for-loop是线性时间$n$，所以合起来的时间复杂度就是$O(n\log n)$。  

空间上，排序是原地的，使用了一些常数大小的空间，所以空间复杂度是$O(1)$。  