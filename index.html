<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wudi.space","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="吴迪小站">
<meta property="og:url" content="https://www.wudi.space/index.html">
<meta property="og:site_name" content="吴迪小站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="吴迪">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.wudi.space/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>吴迪小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴迪小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2021/01/04/Cache-02RedisAdvance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/04/Cache-02RedisAdvance/" class="post-title-link" itemprop="url">缓存技术-02-Redis进阶操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-04 17:27:45" itemprop="dateCreated datePublished" datetime="2021-01-04T17:27:45+08:00">2021-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-06 09:33:21" itemprop="dateModified" datetime="2021-01-06T09:33:21+08:00">2021-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">常用缓存技术原理与应用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/2021/01/02/Cache-01Basic/">前一篇文章</a>对缓存的一些基础知识，以及Redis的基本用法有了一定的了解。本文将列举一些进阶用法，包括管道、发布订阅、事务等等。</p>
<h1 id="利用管道批量发送命令"><span class="post-title-index">1. </span><a href="#利用管道批量发送命令" class="headerlink" title="利用管道批量发送命令"></a>利用管道批量发送命令</h1><p>由于每一次连接都需要建立连接，这需要一定的时间消耗。如果每次只发送一条指令，就比较浪费。因此建立一次连接，发收多条消息是比较经济的做法。在Spring中可以采用连接池的方式，通过长连接来操作Redis。在非框架环境下，如果有客户端，也可以直接使用客户端（比如redis-cli或者可视化的客户端），也可以通过管道，一次将需要的消息都发出去。</p>
<h2 id="利用netcat进行socket连接"><span class="post-title-index">1.1. </span><a href="#利用netcat进行socket连接" class="headerlink" title="利用netcat进行socket连接"></a>利用netcat进行socket连接</h2><p>在linux系统（macOS也行）上都可以安装一款名为netcat的网络工具。  </p>
<blockquote>
<p>yum install nc    # CentOS<br>brew install nc   # macOS</p>
</blockquote>
<p>Windows上也有移植版本，可以自行搜索。  </p>
<p>netcat是一款简单易用的UNIX网络工具，通常用于网络连接的测试或黑客工具。通过nc可以轻易的创建各种类型的连接。这里使用nc去创建一个持久的socket连接。  </p>
<p>建立一个连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc localhost 6379</span><br></pre></td></tr></table></figure><br>回车之后，就可以直接交互式的发送redis命令，并接收返回值了（如果有密码的话，可以用指令<code>auth xxx</code>输入密码）。<br>也可以通过管道将指令一次性发送：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"set key5 5\nincr key5\nget key5"</span> | nc localhost 6379</span><br></pre></td></tr></table></figure><br>这时就会一次性返回：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+OK     <span class="comment"># 建立连接成功    </span></span><br><span class="line">:6      <span class="comment"># set成功  </span></span><br><span class="line"><span class="variable">$1</span>      <span class="comment"># incr成功  </span></span><br><span class="line">6       <span class="comment"># get结果</span></span><br></pre></td></tr></table></figure></p>
<h2 id="利用redis-cli-—pipe"><span class="post-title-index">1.2. </span><a href="#利用redis-cli-—pipe" class="headerlink" title="利用redis-cli —pipe"></a>利用redis-cli —pipe</h2><p>当命令数很多的时候，通过nc很难确认是否所有命令都成功执行。<br>从Redis 2.6开始，redis-cli内检了管道模式，可以通过管道向redis-cli输入命令。<br>这时，可以先准备一个文本文件，其中记录了所有需要批量执行的命令。当然，因为redis只支持Windows下的换行符（<code>\r\n</code>），所以可以利用unix2dos工具箱进行转码，在安装（<code>yum install unix2dos</code>或者<code>brew install unix2dos</code>之类的）后，直接执行<code>unix2dos redis_batch.txt</code>就可以得到转换好的文件。<br>然后通过诸如cat指令提取这个文本文件中的命令，并通过管道符连接redis即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat redis_batch.txt | redis-cli --pipe</span><br></pre></td></tr></table></figure><br>然后就会显示错误的条数和redis服务的响应数量。  </p>
<p>当然，这里直接使用<code>cat redis_batch.txt | redis-cli</code>，不添加<code>--pipe</code>开关也可以，这样的话，每一条响应都会输出在终端上，而且据说效率会比<code>--pipe</code>要慢不少。  </p>
<h1 id="发布-订阅"><span class="post-title-index">2. </span><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h1><p>订阅：SUBCRIBE channel [channel …]：订阅频道在此时之后的消息<br>发布：PUBLISH channel message：向频道发送消息  </p>
<p>例：聊天消息，既需要实时获取，也需要历史记录，这个系统应当如何设计？<br>利用redis的发布订阅功能，可以实现实时获取的功能。对于历史记录可分为短期历史记录和长期历史记录，长期历史记录存放在数据库中（可通过kafka写入数据库），短期数据通过redis的sorted set（支持区间删除和取出）以时间为score存储或者list作为队列存储。  </p>
<p>下图是消息上传和下载的流程。左边是简易的实现方式。为了保持3个存储器中数据的一致性，可以采用右侧的方式来进行。<br><img src="/2021/01/04/Cache-02RedisAdvance/RedisChatMessageStorage.png" alt="RedisChatMessageStorage">  </p>
<h1 id="事务"><span class="post-title-index">3. </span><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务标记：MULTI：标记事务由此开始，此标记后的相同客户端发至服务端的指令都被缓存。<br>事务执行：EXEC：连续执行MULTI指令之后，此条指令之前的所有被缓存的指令。多个客户端开启事务时，以首先发送EXEC指令的先后顺序执行。<br>事务取消：DISCARD：取消MULTI标记。<br>键值监控：WATCH key [key …]：在事务开启前先获取key的值，在EXEC时如果这些值发生了变化，则中断事务（无论事务执行中是否使用了这个或这些key）。</p>
<p>Redis的事务仅能保证原子性，当执行发生错误时，已执行的指令依然生效，不支持回滚（因为无法预知错误，redis的错误仅可能是语法的错误，比如对string执行队列操作等等）。  </p>
<h1 id="布隆过滤器（Bloom-Filter）"><span class="post-title-index">4. </span><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h1><p>利用BF可以缓解缓存穿透（缓存击穿）的问题。<br>所谓缓存穿透，是指大量请求同时查询一个缓存，缓存中如果没有这个记录，这些请求同时去访问数据库，使数据库压力增大。  </p>
<p>考虑一个场景，数据库中存在一些数据。如果现在高并发访问，需要大量的查询，这些查询可能是存在于数据库中，也可能不存在数据库中。这样的场景会有如下3种设计方案：  </p>
<ol>
<li>让所有请求直接访问数据库。</li>
<li>将数据库中的数据都放到Redis缓存中。</li>
<li>将一部分数据放到缓存中，当缓存中不存在时交给数据库去查询。  </li>
</ol>
<p>针对方案2，当数据非常大时，所需要的内存缓存也是巨量的，成本太高。对于方案1，数据的负载过高。针对方案2，在一些情况下是可以的，但是当大量请求没有命中缓存时，依然会遇到缓存击穿的问题，直接高并发访问数据库。<br>这时，如果存在一个过滤器，如果能高效判断请求的东西是否在大数据集中，哪怕不是特别精准，也能够有效缓解缓存击穿的问题。  </p>
<h2 id="基本布隆过滤器"><span class="post-title-index">4.1. </span><a href="#基本布隆过滤器" class="headerlink" title="基本布隆过滤器"></a>基本布隆过滤器</h2><p>这时，就要请出布隆过滤器（Bloom Filter）。<br>BF由k个hash函数和一个bitmap组成。初始化时，对每一个大数据集中的数据，进行k个hash，得到k个散列值，并对bitmap对应位置置位（可能存在重复置位）。使用时，对请求的数据也进行k个hash，得到k个散列值，去判断对应的bitmap位是否被置位。如果都被置位了，则这个请求可能存在于大数据集中；如果有至少1位未被置位，则这个请求一定不存在于大数据集中。<br>如下图，数据集（训练集）中有Data1、Data2、Data3，值分别为5、12、21，都经过3个hash函数散列到bitmap中。<br>然后过来了3个测试值Test1、Test2、Test3。Test1的值为5，与数据集中的Data1是一致的，因此其对应的散列值在bitmap中都是1，所以通过BF测试；Test2的值为13，但其散列后的3个值在bitmap中恰好都是1，所以也通过BF测试；Test3的值为34，其散列后的3个值在bitmap中有至少一个是0，所以没有通过BF测试。<br><img src="/2021/01/04/Cache-02RedisAdvance/BloomFilter.png" alt="BloomFilter"><br>实际中，可以通过选择合适的hash函数组和合理的bitmap长度，来尽量避免Test2这种假阳性的发生。  </p>
<p>在上面的场景中，在数据初始化时，提取出数据库中的所有可被搜索数据，然后自己实现bitmap和hash函数来生成BF；也可以利用Redis的bitmap操作，自己维护一个BF；当然，还可以利用Redis的BloomFilter Module，在初始化时BF.ADD key data 所有数据库中可被搜索的元素，然后利用BF.EXISTS key data确认BF的测试结果。  </p>
<h2 id="Counting-Bloom-Filter-计数布隆过滤器"><span class="post-title-index">4.2. </span><a href="#Counting-Bloom-Filter-计数布隆过滤器" class="headerlink" title="Counting Bloom Filter 计数布隆过滤器"></a>Counting Bloom Filter 计数布隆过滤器</h2><p>为了应对BF的数据集（训练集）可能会实时修改的情况，将BF的bitmap中每一位升级为一个计数器，在训练时，得到的hash散列值后不是简单将某一位置位，而是将对应的计数器+1。这样，如果需要实时删除某一个训练值，就只需要将其散列值对应的计数器-1即可。<br>然而由此一来，为了增加一个可删除的功能，bitmap不得不成倍的膨胀（原本1位，现在需要膨胀为好多位，用来存放1个整数）。</p>
<h2 id="Cuckoo-Filter-布谷鸟过滤器"><span class="post-title-index">4.3. </span><a href="#Cuckoo-Filter-布谷鸟过滤器" class="headerlink" title="Cuckoo Filter 布谷鸟过滤器"></a>Cuckoo Filter 布谷鸟过滤器</h2><p>由于BF在查询时需要多次计算hash、bitmap难以最大化利用空间（很多位都是空的），而且不支持反向操作（删除）。为此，布谷鸟过滤器（Cuckoo Filter）横空出世。<br>布谷鸟（也就是杜鹃）根据小时候看的百科全书上的说法，自己基本不建造巢穴，而是将蛋下在别的鸟巢中，为了让巢主人一下子无法发现，还会踢掉一些主人的蛋，让总蛋数量保持不变。<br>CF也是一样的做法。与BF使用一组hash函数和一个bitmap不同，CF使用1个hash函数、1个指纹函数、1个固定的对偶函数和1个数组（每个数组元素有k个存储单元，也即可以顺序存放k个指纹，比如4）。对偶函数的作用就是在已知一个散列位置的时候，可以计算出另一个对偶位置用于存放指纹。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp = fingerprint(data);</span><br><span class="line">p1 = hash(data);</span><br><span class="line">p2 = dual(p1, data);</span><br><span class="line"><span class="comment">// p1 == dual(p2, fp);</span></span><br></pre></td></tr></table></figure><br>通常，<code>dual(x, y) = x ^ hash(y)</code>。这样在已知p1时，可以计算出p2；在已知p2时可以计算出p1。那么怎么使用呢？</p>
<p>在训练时，将训练数据随机使用一个hash函数得到1个散列值，首先查看数组中散列值位置的4个存储单元是否放满了，如果没有放满，则将指纹放入。如果4个位置都放满了，则尝试放入对偶位置。如果对偶位置也放满了，则从2个位置中随机中踢出一个，自己放进去。然后被踢出的根据指纹计算其自己的对偶位置，如果这个对偶位置也放满了，则替换其中一个，被踢出的继续寻找自己的对偶位置。直到所有元素都被放下，或者踢出次数达到上限（形成挤兑）。  </p>
<p>这样的设计是可以提高整个空间的利用率的，但是当重复插入相同元素，则会很快沾满自己可以存放的8个位置，从而形成无限踢出造成挤兑。  </p>
<h1 id="Redis作为缓存"><span class="post-title-index">5. </span><a href="#Redis作为缓存" class="headerlink" title="Redis作为缓存"></a>Redis作为缓存</h1><p>Redis作为缓存和作为数据库的区别：</p>
<ol>
<li>缓存的数据只是数据的副本（丢了也没关系）</li>
<li>缓存不是全量数据</li>
<li>缓存随着访问而变化</li>
<li>缓存里应该放热数据  </li>
</ol>
<p>那么如何让Redis中的数据随着业务变化呢？<br>设置有效期：根据业务逻辑设置（部分数据只需要保存xx时长，过期就没有使用必要了）<br>热数据变冷淘汰：根据业务运转设置（比如经过一段时间运转，发现某些数据变成了冷数据，方访问量低迷）。</p>
<h2 id="过期"><span class="post-title-index">5.1. </span><a href="#过期" class="headerlink" title="过期"></a>过期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value EXPIRE second</span><br></pre></td></tr></table></figure>
<p>或者通过非原子的2步操作进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">EXPIRE key second</span><br></pre></td></tr></table></figure><br>在设置了过期时长后，通过GET不会续期。只能通过<code>EXPIRE key second</code>重新设置过期时长。  </p>
<p>如果对正在倒计时的键值对使用<code>SET key value</code>来刷新数据，会取消其过期时间。  </p>
<p>Redis清除过期的策略<br>被动：在访问时，如果该键值已经过期，则清除。<br>主动：每秒做10次下面的事情，这样可以在稍微牺牲内存的情况下，保证性能。 </p>
<ol>
<li>测试随机的20个键值对</li>
<li>删除其中过期的</li>
<li>如果有超过25%是过期的，则重复1</li>
</ol>
<h2 id="数据淘汰设置"><span class="post-title-index">5.2. </span><a href="#数据淘汰设置" class="headerlink" title="数据淘汰设置"></a>数据淘汰设置</h2><p>在conf中可以进行如下设置，位于MEMORY MANAGEMENT节中。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大内存用量，建议不要特别大，不然在快照时会很耗时</span></span><br><span class="line">maxmemory &lt;bytes&gt;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 达到最大内存用量时，如何清除无用数据。可选：</span></span><br><span class="line"><span class="comment"># noeviction 不清除，放不下了就报错，通常用于数据库时</span></span><br><span class="line"><span class="comment"># volatile-lru 删除设有过期时间的键值对中的上次使用时间最远的的</span></span><br><span class="line"><span class="comment"># allkeys-lru 删除所有的键值对中的上次使用时间最远的的</span></span><br><span class="line"><span class="comment"># volatile-lfu、allkeys-lfu 删除使用次数最少的</span></span><br><span class="line"><span class="comment"># volatile-random、allkeys-random 随机删除</span></span><br><span class="line"><span class="comment"># volatile-ttl 删除设有过期时间的键值对中剩余时间最少的</span></span><br><span class="line">maxmemory-policy</span><br></pre></td></tr></table></figure>
<h2 id="Redis缓存时可能遇到的问题"><span class="post-title-index">5.3. </span><a href="#Redis缓存时可能遇到的问题" class="headerlink" title="Redis缓存时可能遇到的问题"></a>Redis缓存时可能遇到的问题</h2><h3 id="缓存击穿"><span class="post-title-index">5.3.1. </span><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h3 id="缓存雪崩"><span class="post-title-index">5.3.2. </span><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h3 id="缓存穿透"><span class="post-title-index">5.3.3. </span><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h3 id="缓存（与数据库）一致性（双写）"><span class="post-title-index">5.3.4. </span><a href="#缓存（与数据库）一致性（双写）" class="headerlink" title="缓存（与数据库）一致性（双写）"></a>缓存（与数据库）一致性（双写）</h3><h1 id="Redis持久化"><span class="post-title-index">6. </span><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>持久化有2种思路。快照/副本，日志。  </p>
<h2 id="快照——RDB持久化"><span class="post-title-index">6.1. </span><a href="#快照——RDB持久化" class="headerlink" title="快照——RDB持久化"></a>快照——RDB持久化</h2><p>生成一个RDB文件，里面记录了当前所有内存中的数据。</p>
<h3 id="方法"><span class="post-title-index">6.1.1. </span><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>save：阻塞。场景：关机维护</li>
<li>bgsave：后台非阻塞。场景：任何手动场景</li>
<li>配置文件：自动、定时、后台非阻塞（调用bgsave）。  </li>
</ul>
<p>配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save &lt;second&gt; &lt;changes&gt;</span></span><br><span class="line">save 900 1      <span class="comment"># 每900秒只要有至少1个修改就触发bgsave</span></span><br><span class="line">save 300 10     <span class="comment"># 每300秒只要有至少10个修改旧触发bgsave</span></span><br><span class="line"><span class="comment"># 可以设置多条规则</span></span><br><span class="line"><span class="comment"># Redis默认开启RDB</span></span><br></pre></td></tr></table></figure></p>
<h3 id="bgsave实现原理与技术基础"><span class="post-title-index">6.1.2. </span><a href="#bgsave实现原理与技术基础" class="headerlink" title="bgsave实现原理与技术基础"></a>bgsave实现原理与技术基础</h3><p>bgsave通过fork()实现。<br>在fork后，父进程与子进程可以访问到相同的值。因为在fork时，系统仅为子进程创建了一份新的虚拟内存映射表，里面映射的物理内存的地址与父进程是一样的。所以fork速度很快，需要的内存很少。基于fork之后会修改的内容相对会很少的假设，启用COW（copy on write），即在fork之后修改的值，才会创建新的物理内存（并修改虚拟内存和物理内存的映射关系）。<br>Redis利用fork创建一个子进程进行快照，这样一方面不会阻塞父进程继续IO和执行指令，另一方面父进程的修改也不会体现到子进程中，达到快照的目的。  </p>
<p><img src="/2021/01/04/Cache-02RedisAdvance/RedisSnapshot.png" alt="RedisSnapshot">  </p>
<h3 id="RDB的优缺点"><span class="post-title-index">6.1.3. </span><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h3><p>缺点：</p>
<ol>
<li>不支持拉链表（也即只有一个rdb文件，没有数据变迁历史记录）</li>
<li>丢失数据可能性较大（下一次save之前的数据，会在宕机后丢失）</li>
</ol>
<p>优点：磁盘上存储的rdb文件中的内容类似于序列化，恢复速度快。</p>
<h2 id="写操作记录——AOF"><span class="post-title-index">6.2. </span><a href="#写操作记录——AOF" class="headerlink" title="写操作记录——AOF"></a>写操作记录——AOF</h2><p>AOF，即Append-Only File。只增量记录写操作。</p>
<h3 id="优缺点"><span class="post-title-index">6.2.1. </span><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>丢失数据少（数据完整性相对高）</li>
<li>如果RDB与AOF同时开启，则用AOF恢复数据（Redis 4.0之后，AOF文件中包括RDB的全量，以及增量的写操作</li>
</ol>
<p>缺点：<br>比RDB慢，在执行命令的同时，执行AOF的文件写操作，会降低Redis的效率。</p>
<h3 id="如何让AOF文件足够小"><span class="post-title-index">6.2.2. </span><a href="#如何让AOF文件足够小" class="headerlink" title="如何让AOF文件足够小"></a>如何让AOF文件足够小</h3><p>重写rewrite<br>Redis 4.0之前删除可以抵消的指令，合并重复的命令。所以此时的AOF是一个春指令的日志文件。此操作是一个CPU密集操作。<br>Redis 4.0之后，会将RDB文件合并到AOF中，增量部分用记录指令。所以此时的AOF是一个混合体，既利用了RDB的快和节省空间，又利用了AOF的完整性。此操作比4.0时的rewrite速度快得多。（<code>aof-use-rdb-preamble yes</code>默认开启）</p>
<h3 id="配置"><span class="post-title-index">6.2.3. </span><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>AOF默认关闭<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF</span></span><br><span class="line">appendonly yes <span class="comment"># 开启</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写AOF时flush缓冲区的策略</span></span><br><span class="line">appendfsync everysec    <span class="comment"># 默认为everysec每秒进行flush，compromise</span></span><br><span class="line"><span class="comment"># appendfsync no        # 不手动flush，由系统自己来。速度最快，但可能会丢失未flush的数据</span></span><br><span class="line"><span class="comment"># appendfsync always    # 每次执行指令都会flush数据，会影响效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof 重写策略</span></span><br><span class="line"><span class="comment"># 当aof文件增长达到特定百分比，则触发重写（与上一次aof后的文件尺寸比</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="comment"># 小于此尺寸，则不触发aof重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2021/01/02/Cache-01Basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/02/Cache-01Basic/" class="post-title-link" itemprop="url">缓存技术-01-一些基础知识与基础概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-02 13:42:32" itemprop="dateCreated datePublished" datetime="2021-01-02T13:42:32+08:00">2021-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-05 09:14:37" itemprop="dateModified" datetime="2021-01-05T09:14:37+08:00">2021-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">常用缓存技术原理与应用</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习一下缓存技术。<br></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/02/Cache-01Basic/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2020/12/26/Concurrent-AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/26/Concurrent-AQS/" class="post-title-link" itemprop="url">多线程与高并发-AQS原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-26 11:24:08" itemprop="dateCreated datePublished" datetime="2020-12-26T11:24:08+08:00">2020-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-02 11:35:56" itemprop="dateModified" datetime="2021-01-02T11:35:56+08:00">2021-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">多线程与高并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前文中主要线程的原理、进程内线程同步的原理、以及JUC中常用或常问的工具类的用法和特点进行介绍。本文将对JUC中各个工具类的基础——AQS——进行源码级细致分析。<br></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/12/26/Concurrent-AQS/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴迪"
      src="/images/avatar.jpg?raw=true">
  <p class="site-author-name" itemprop="name">吴迪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备17000391号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴迪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      var config = {
        theme:'default',
        logLevel:'fatal',
        securityLevel:'strict',
        startOnLoad:true,
        arrowMarkerAbsolute:false,

        er:{
          diagramPadding:20,
          layoutDirection:'TB',
          minEntityWidth:100,
          minEntityHeight:75,
          entityPadding:15,
          stroke:'gray',
          fill:'honeydew',
          fontSize:12,
          useMaxWidth:true,
        },
        flowchart:{
          diagramPadding:8,
          htmlLabels:true,
          curve:'linear',
        },
        sequence:{
          diagramMarginX:50,
          diagramMarginY:10,
          actorMargin:50,
          width:150,
          height:65,
          boxMargin:10,
          boxTextMargin:5,
          noteMargin:10,
          messageMargin:35,
          messageAlign:'center',
          mirrorActors:true,
          bottomMarginAdj:1,
          useMaxWidth:true,
          rightAngles:false,
          showSequenceNumbers:false,
        },
        gantt:{
          titleTopMargin:25,
          barHeight:20,
          barGap:4,
          topPadding:50,
          leftPadding:75,
          gridLineStartPadding:35,
          fontSize:11,
          fontFamily:'"Open-Sans", "sans-serif"',
          numberSectionStyles:4,
          axisFormat:'%Y-%m-%d',
        }
      };
      mermaid.initialize(config);
    }
  </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
