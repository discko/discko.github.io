<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wudi.space","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="上一篇文章，简单介绍了一下AOP的用法，分析了一下新版AOP与旧版本AOP在执行流程上的变化。这篇文章将看看AOP的实现原理之JdkDynamicProxy。">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读源码-SpringAOP-02JdkDynamicProxy">
<meta property="og:url" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/index.html">
<meta property="og:site_name" content="吴迪小站">
<meta property="og:description" content="上一篇文章，简单介绍了一下AOP的用法，分析了一下新版AOP与旧版本AOP在执行流程上的变化。这篇文章将看看AOP的实现原理之JdkDynamicProxy。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-without.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-with.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-AutowiredCallStack.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/ImplementationsOfAopProxy.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/JdkDynamicProxyChain.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/JdkDynamicProxy-MethodInvocationShallowClone.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/JdkDynamicProxyCallStack.png">
<meta property="article:published_time" content="2020-12-12T02:28:59.000Z">
<meta property="article:modified_time" content="2020-12-15T01:28:14.652Z">
<meta property="article:author" content="吴迪">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="AOP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-without.png">

<link rel="canonical" href="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>阅读源码-SpringAOP-02JdkDynamicProxy | 吴迪小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴迪小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          阅读源码-SpringAOP-02JdkDynamicProxy
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-12 10:28:59" itemprop="dateCreated datePublished" datetime="2020-12-12T10:28:59+08:00">2020-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-15 09:28:14" itemprop="dateModified" datetime="2020-12-15T09:28:14+08:00">2020-12-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">阅读源码</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上一篇文章，简单介绍了一下AOP的用法，分析了一下新版AOP与旧版本AOP在执行流程上的变化。这篇文章将看看AOP的实现原理之JdkDynamicProxy。<br><a id="more"></a></p>
<h1 id="自己实现一个Proxy"><span class="post-title-index">1. </span><a href="#自己实现一个Proxy" class="headerlink" title="自己实现一个Proxy"></a>自己实现一个Proxy</h1><h2 id="实现代码"><span class="post-title-index">1.1. </span><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>首先根据自己设想的原理来自己实现一个Proxy。<br>比如我们有这样一个接口和对应的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//space.wudi.readsourceaop.jdkdynamicproxy.myproxy.UserServiceImpl</span></span><br><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.myproxy;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.bean.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">login</span><span class="params">(String username)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//space.wudi.readsourceaop.jdkdynamicproxy.myproxy.UserServiceImpl</span></span><br><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.myproxy;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.jdkdynamicproxy.bean.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String username)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"now logging in..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username, <span class="string">"email"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后实现代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.myproxy.proxy;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.jdkdynamicproxy.bean.User;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.jdkdynamicproxy.myproxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUserService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService targetObject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyUserService</span><span class="params">(UserService targetObject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String username)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before(username);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            User rtVal = targetObject.login(username);</span><br><span class="line">            afterReturning(rtVal, username);</span><br><span class="line">            <span class="keyword">return</span> rtVal;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable throwable)&#123;</span><br><span class="line">            afterThrow(throwable, username);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            after(username);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object...args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in After with args: "</span>+Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object rtVal, Object...args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in AfterThrowing with args: "</span> + Arrays.toString(args)+<span class="string">" and rtVal: "</span>+rtVal);</span><br><span class="line">        ((User)rtVal).setEmail(<span class="string">"modified by ProxyUserService"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">(Throwable throwable, String...args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in AfterThrowing with args: "</span> + Arrays.toString(args)+<span class="string">" and exception: "</span>+throwable);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"meet a exception: "</span>+ throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Object...args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in Before with args: "</span>+ Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来实现入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.myproxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.jdkdynamicproxy.bean.User;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.jdkdynamicproxy.myproxy.proxy.ProxyUserService;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseMyProxyController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="keyword">private</span> UserService userServiceProxy;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userServiceProxy = <span class="keyword">new</span> ProxyUserService(userService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/loginWithoutProxy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">loginWithoutProxy</span><span class="params">(String username)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.login(username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/loginWithProxy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">UserLoginWithProxy</span><span class="params">(String username)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userServiceProxy.login(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后我们就可以通过接口调用了。</p>
<h2 id="测试"><span class="post-title-index">1.2. </span><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>首先调用没有使用代理的<code>/loginWithoutProxy?username=WuDi</code>：<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-without.png" alt="WithoutMyProxy"><br>对应的控制台输出：  </p>
<blockquote>
<p>now logging in…</p>
</blockquote>
<p>而利用代理的<code>/loginWithProxy?username=WuDi</code>：<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-with.png" alt="WithMyProxy"><br>对应的控制台输出：  </p>
<blockquote>
<p>in Before with args: [WuDi]<br>now logging in…<br>in AfterReturning with args: [WuDi] and rtVal: space.wudi.readsourceaop.jdkdynamicproxy.bean.User@4c14b089<br>in After with args: [WuDi]  </p>
</blockquote>
<p>同样的，如果不传入username，就会触发NullPointerException，我们来试一下：<br>没有代理的<code>/loginWithoutProxy</code>：</p>
<blockquote>
<p>now logging in…<br>2020-12-12 12:32:55.794 ERROR 11313 —- [nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException: username cannot be null] with root cause<br>java.lang.NullPointerException: username cannot be null<br>…TraceStack</p>
</blockquote>
<p>有代理的<code>/loginWithProxy</code>：</p>
<blockquote>
<p>in Before with args: [null]<br>now logging in…<br>in AfterThrowing with args: [null] and exception: java.lang.NullPointerException: username cannot be null<br>in After with args: [null]<br>2020-12-12 12:30:56.431 ERROR 11313 —- [nio-8080-exec-3] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: meet a exception: username cannot be null] with root cause<br>java.lang.RuntimeException: meet a exception: username cannot be null<br>…TraceStack</p>
</blockquote>
<p>可以看到即使抛出了异常，也依然访问了After方法。</p>
<h2 id="加入Around和自动注入"><span class="post-title-index">1.3. </span><a href="#加入Around和自动注入" class="headerlink" title="加入Around和自动注入"></a>加入Around和自动注入</h2><p>由于篇幅，这个我就放在git上了，需要的可以通过<a href="https://github.com/discko/ReadSource/tree/master/readsource-aop" target="_blank" rel="noopener">传送门</a>自行查看。<br>分别执行接口<code>/loginAutowired?username=WuDi</code>、<code>/loginAutowired</code> ，可以得到无异常的输出日志：</p>
<blockquote>
<p>in Around before process<br>in Before<br>now logging in…<br>in AfterReturning with rtVal: space.wudi.readsourceaop.jdkdynamicproxy.bean.User@7abb7e21<br>in After<br>in Around after process</p>
</blockquote>
<p>和有异常的输出日志：  </p>
<blockquote>
<p>in Around before process<br>in Before<br>now logging in…<br>in AfterThrowing with rtVal: java.lang.reflect.InvocationTargetException<br>in After<br>in Around after process</p>
</blockquote>
<p>在AfterReturning的lambda中下一个断点，在调用栈中也可以进行观察：<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/MyProxy-AutowiredCallStack.png" alt="MyProxyAutowired"><br>此时仍然在<code>processAfter()</code>方法中，但并未执行<code>adviseAfter()</code>。</p>
<p>解释一下各个类的作用：<br><code>space.wudi.readsourceaop.jdkdynamicproxy.myproxy.proxy.ProxyAroundUserService</code>这个类就是代理类，我将几个Advice过程通过Functional接口都留在了这个代理类中了，并通过<code>AspectProcessor</code>子类中的<code>process()</code>方法去执行流程。<br>而在<code>space.wudi.readsourceaop.jdkdynamicproxy.myproxy.MyAspect</code>类中，创建了这个代理类的bean，通过lambda表达式实现了各个Advice阶段。<br>最后在<code>space.wudi.readsourceaop.jdkdynamicproxy.myproxy.UseMyProxyAutowiredController</code>类中利用<code>@Autowired</code>将代理类注入到<code>UserService userService</code>这个引用中。  </p>
<h1 id="SpringAOP中代理Proxy的实现方式"><span class="post-title-index">2. </span><a href="#SpringAOP中代理Proxy的实现方式" class="headerlink" title="SpringAOP中代理Proxy的实现方式"></a>SpringAOP中代理Proxy的实现方式</h1><p>Spring AOP 中代理有两种实现方式，分别是利用Jdk中自带的Dynamic Proxy和利用CgLib第三方库。从哪儿看出来的呢，可以搜索aop proxy相关的类，很容易就找到一个叫做AopProxy的接口，查看其实现，分别是<code>JdkDynamicAopProxy</code>、<code>CglibAopProxy</code>、<code>ObjenesisAopProxy</code>。后两个师出同源，就都认为是CGLib的了。<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/ImplementationsOfAopProxy.png" alt="ImplementationsOfAopProxy">。</p>
<p>当然，翻看<code>DefaultAopProxyFactory</code>的源码或者文档，也能发现Spring AOP是通过上述两种方式实现的。</p>
<h1 id="JDK-Dynamic-Proxy"><span class="post-title-index">3. </span><a href="#JDK-Dynamic-Proxy" class="headerlink" title="JDK Dynamic Proxy"></a>JDK Dynamic Proxy</h1><h2 id="代理对象的生成"><span class="post-title-index">3.1. </span><a href="#代理对象的生成" class="headerlink" title="代理对象的生成"></a>代理对象的生成</h2><p>我们从<code>JdkDynamicAopProxy</code>类出发，里面很容易就看到了两个<code>getProxy</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">"Creating JDK dynamic proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, <span class="keyword">this</span>.proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，最终调用的都是<code>java.lang.reflection.Proxy</code>类的<code>newProxyInstance</code>方法。需要传入一个<code>ClassLoader</code>、一个需要代理的接口列表（也就是目标对象的接口列表），以及<code>this</code>指针（<code>JdkDynamicAopProxy</code>同时也实现了<code>InvocationHandler</code>接口，所以它自己本身可以调用<code>this.invoke()</code>方法来调用目标方法。<br>继续跟踪<code>newProxyInstance()</code>方法，大致经过这样3步：确认参数合法性→创建代理对象→实例化代理对象。前后都比较简单，“创建代理对象”这部只有一个动作，<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code>，那么继续跟踪，里面也就一句有用的话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是在<code>proxyClassCache</code>中寻找使用相同类加载器<code>loader</code>加载的，而且有相同<code>interfaces</code>接口列表的代理类。如果没有的话，会利用proxyClassCache去创建。<br>看上去很接近了，看看<code>proxyClassCache</code>的初始化，就在最上面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">       proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><br>那么看来就是<code>ProxyClassFactory</code>了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;</span><br><span class="line">        <span class="comment">// 代理类的类名的前缀</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line">        <span class="comment">// 为了防止类名重复，使用一个自增器，在类名前缀后面拼接</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">            <span class="comment">//存放目标对象的合法接口，把Map当Set用</span></span><br><span class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="comment">//利用传入的类加载器loader尝试加载接口类，如果加载失败就抛出异常。失败的可能比如类不可达、不在此类加载器中等。</span></span><br><span class="line">                Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 确认这是一个interface</span></span><br><span class="line">                <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 确认没有重复添加</span></span><br><span class="line">                <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为代理类确定所在包</span></span><br><span class="line">            String proxyPkg = <span class="keyword">null</span>;     </span><br><span class="line">            <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历所有的接口，如果发现某个接口是非public的，那么后面就要将代理对象放到这个接口所在的包里。如果发现更多的非public接口，而且存放在不同的包里，那么就要抛出异常，因为后面创建的Proxy对象无法同时实现这些接口。</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">                <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                    accessFlags = Modifier.FINAL;</span><br><span class="line">                    String name = intf.getName();</span><br><span class="line">                    <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                    String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        proxyPkg = pkg;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果proxyPkg是null，也就是说上面遍历的所有的接口都不是非public的，那么就使用默认的包名（com.sun.proxy)</span></span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过$Proxy和计数器拼接，得到代理类的类名。</span></span><br><span class="line">            <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成代理类的class文件（在内存中，以byte数组表示）</span></span><br><span class="line">            <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加载这个代理类到类加载器</span></span><br><span class="line">                <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这样，大致的流程就清楚了。上面的<code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)</code>这一行里面就纯粹是在内存中根据class文件的格式创建class文件。唯一值得一提的就是，在其中有这样3行，如果让我写的话，我估计一定会忘记：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">this</span>.addProxyMethod(equalsMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">this</span>.addProxyMethod(toStringMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><br>从这个角度来说的话，代理类中至少存在这三个函数的实现的。 </p>
<p>在<code>ProxyGenerator.generateProxyClass</code>还有一行值得注意，那就是<code>if (saveGeneratedFiles) {Files.write(xxx)}</code>，也就是说如果<code>saveGeneratedFiles</code>为真，就将class文件输出。网上翻，可以看到这个属性的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br></pre></td></tr></table></figure><br>所以，在JVM的启动参数上增加<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>就可以将class文件输出了。<br>尝试了一下，因为<code>JdkDynamicAopProxy</code>在构造的时候调用的<code>AopProxyUtils.completeProxiedInterfaces()</code>中，会额外引入3个接口，所以有一些额外的接口被注入了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.aop.framework.AopProxyUtils</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, <span class="keyword">boolean</span> decoratingProxy) &#123;</span><br><span class="line">    Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">boolean</span> addSpringProxy = !advised.isInterfaceProxied(SpringProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">boolean</span> addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">boolean</span> addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="keyword">int</span> nonUserIfcCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">        nonUserIfcCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">        nonUserIfcCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addDecoratingProxy) &#123;</span><br><span class="line">        nonUserIfcCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = <span class="keyword">new</span> Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount];</span><br><span class="line">    System.arraycopy(specifiedInterfaces, <span class="number">0</span>, proxiedInterfaces, <span class="number">0</span>, specifiedInterfaces.length);</span><br><span class="line">    <span class="keyword">int</span> index = specifiedInterfaces.length;</span><br><span class="line">    <span class="keyword">if</span> (addSpringProxy) &#123;</span><br><span class="line">        proxiedInterfaces[index] = SpringProxy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addAdvised) &#123;</span><br><span class="line">        proxiedInterfaces[index] = Advised<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addDecoratingProxy) &#123;</span><br><span class="line">        proxiedInterfaces[index] = DecoratingProxy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxiedInterfaces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样一来，除了原本自己写的接口中未实现的方法、3个默认方法（equals()、hashCode()、toString()），还会新增26个方法。下面是一个class文件反编译后得到的java代码，我已经将<code>SpringProxy</code>、<code>Advised</code>、<code>DecoratingProxy</code>中的接口及相关代码删除了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy62</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">JdkDynamicService</span>, <span class="title">SpringProxy</span>, <span class="title">Advised</span>, <span class="title">DecoratingProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="comment">//other private static Method mx;</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy62(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">useJdkDynamicProxy</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//other function delclarations</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"space.wudi.readsourceaop.jdkdynamicproxy.service.JdkDynamicService"</span>).getMethod(<span class="string">"useJdkDynamicProxy"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            <span class="comment">//other mx = Class.forName().getMethod()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="代理的过程"><span class="post-title-index">3.2. </span><a href="#代理的过程" class="headerlink" title="代理的过程"></a>代理的过程</h2><h3 id="测试代码编写"><span class="post-title-index">3.2.1. </span><a href="#测试代码编写" class="headerlink" title="测试代码编写"></a>测试代码编写</h3><p>编写一组代理的目标，具体参见<a href="https://github.com/discko/ReadSource/tree/master/readsource-aop" target="_blank" rel="noopener">示例代码</a>。<br>还是贴一下代码吧。<br>首先创建了一个注解，用于标记需要被切入的目标方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AspectJoinPoint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后是切面类，没有什么太多需要讲的，<code>@Pointcut</code>处使用了<code>@annotation</code>去查找相关的切入点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(space.wudi.readsourceaop.jdkdynamicproxy.annotation.AspectJoinPoint)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"around before"</span>);</span><br><span class="line">        Object rtVal = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"around after"</span>);</span><br><span class="line">        <span class="keyword">return</span> rtVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointcut()"</span>, returning = <span class="string">"rtVal"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object rtVal)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after returning "</span>+rtVal);</span><br><span class="line">        <span class="keyword">return</span> rtVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"pointcut()"</span>, throwing = <span class="string">"throwable"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable throwable)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after throwing "</span>+throwable);</span><br><span class="line">        <span class="keyword">throw</span> throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来是接口和实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface</span></span><br><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JdkDynamicService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">useJdkDynamicProxy</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//implementation</span></span><br><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.jdkdynamicproxy.service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.jdkdynamicproxy.annotation.AspectJoinPoint;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicServiceImpl</span> <span class="keyword">implements</span> <span class="title">JdkDynamicService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@AspectJoinPoint</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">useJdkDynamicProxy</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in service"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id="</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后在<code>MyController</code>中增加了一个API入口，用于调用测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// space.wudi.readsourceaop.jdkdynamicproxy.controller.MyController</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略其他的API接口</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdkDynamicService jdkDynamicService;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/testJdkDynamicProxy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testJdkDynamicProxy</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in controller"</span>);</span><br><span class="line">        <span class="keyword">return</span> jdkDynamicService.useJdkDynamicProxy(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明一下几个类：  </p>
<ul>
<li><code>space.wudi.reassourceaop.service.JdkDynamicProxyService</code>是一个即将被代理的接口。里面就只有一个未实现的方法<code>useJdkDynamicProxy</code>。  </li>
<li><code>space.wudi.reassourceaop.service.JdkDynamicProxyServiceImpl</code>是上述接口的实现，其实例也就是被代理的目标对象。</li>
<li><code>space.wudi.reassourceaop.annotation.AspectJoinPoint</code>是一个注解，用来标注需要被代理的切入点Pointcut。</li>
<li><code>space.wudi.reassourceaop.aspect.ServiceAspect</code>就是这个切面的描述。声明了<code>@Arount</code>、<code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code>这5个Advice。</li>
<li><code>space.wudi.reassourceaop.controller.MyController</code>中新增了一个<code>String testJdkDynamicProxy(String)</code>函数，用来测试该代理，并且添加了代理对象的注入点<code>@Autowired JdkDynamicService jdkDynamicService</code>。  </li>
</ul>
<h3 id="观察主要逻辑"><span class="post-title-index">3.2.2. </span><a href="#观察主要逻辑" class="headerlink" title="观察主要逻辑"></a>观察主要逻辑</h3><p>在启动后，我们在<code>MyController.testJdkDynamicProxy()</code>中下一个断点，并跟着断点进行调试。可以看到，在原本应该进入<code>JdkDynamicProxyServiceImpl.useJdkDynamicProxy()</code>，实际上却进入了<code>org.springframework.aop.framework.JdkDynamicAopProxy.invoke()</code>之中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.JdkDynamicAopProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取一个持有目标对象的对象</span></span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="comment">// 如果代理中没有定义equals()方法，且现在准备调用equals()方法，下同</span></span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尽量晚地获取目标对象</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 获取advice的责任链</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 如果advice责任链是空的，就直接调用目标对象的目标方法</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 利用责任链，创建代理对象的MethodInvocation</span></span><br><span class="line">            MethodInvocation invocation =</span><br><span class="line">                    <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// 调用责任链，获取返回值</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对返回值进行处理</span></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                returnType != Object<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">returnType</span>.<span class="title">isInstance</span>(<span class="title">proxy</span>) &amp;&amp;</span></span><br><span class="line"><span class="class">                !<span class="title">RawTargetAccess</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">            <span class="comment">// 特殊情况，如果目标对象被代理的方法返回了this，则将this替换为代理对象</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">            <span class="comment">// 如果返回了null，但目标方法应当返回基础类型，则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">                    <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从源码来看，主要分成这样几个步骤：判断调用方法（特殊方法特殊处理）→获取目标对象（尽量晚）→调用advice责任链获取返回值→对返回值进行处理（如果需要）→收尾和返回。<br>这样，比较重要的就是责任链如何调用了。<br>先不说为什么，只说是什么，现在的责任链中有哪些节点呢？断点内看得很清楚：<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/JdkDynamicProxyChain.png" alt="JdkDynamicProxyChainList"><br>可以看到第一个是<code>ExposeInvocationInterceptor</code>，然后就是<code>Around</code>、<code>Before</code>、<code>After</code>、<code>AfterReturning</code>、<code>AfterThrowing</code>这几个Advice了。</p>
<h3 id="责任链调用"><span class="post-title-index">3.2.3. </span><a href="#责任链调用" class="headerlink" title="责任链调用"></a>责任链调用</h3><p>上面代码中利用责任链和代理对象生成了一个<code>ReflectiveMethodInvocation</code>对象，并调用了它的<code>proceed()</code>函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MethodInvocation invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">retVal = invocation.proceed();</span><br></pre></td></tr></table></figure><br>然后在<code>proceed()</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.ReflectiveMethodInvocation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经到达责任链末尾，则调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取责任链中的当前节点</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点是一个InterceptorAndDynamicMethodMatcher，则执行这里。先省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是个MethodInterceptor就invoke</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ExposeInvocationInterceptor"><span class="post-title-index">3.2.3.1. </span><a href="#ExposeInvocationInterceptor" class="headerlink" title="ExposeInvocationInterceptor"></a>ExposeInvocationInterceptor</h4><p>上面说到了，责任链中的首个元素是一个<code>ExposeInvocationInterceptor</code>，它不是<code>InterceptorAndDynamicMethodMatcher</code>，所以进入else分支，执行<code>ExposeInvocationInterceptor.invoke()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.interceptor.ExposeInvocationInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation oldInvocation = invocation.get();</span><br><span class="line">    invocation.set(mi);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        invocation.set(oldInvocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的<code>invocation</code>是一个ThreadLocal，这里的oldInvocation是<code>MyController</code>的代理对象中的<code>testJdkDynamicProxy()</code>（因为我是在这个函数里下的断点，而这个方法也会被<code>LogAspect</code>的切面代理。所以从这里的逻辑可以看出，每进入一个新的切面Aspect，就会在ThreadLocal中记录当前切面的<code>ReflectiveMethodInvocation</code>，这样当需要的时候，就可以从中取出必要的信息；而退出一层后，又会恢复上一层Aspect的<code>ReflectiveMethodInvocation</code>。<br>这时候，再执行<code>mi.proceed()</code>，而<code>mi</code>就是上面<code>ReflectiveMethodInvocation</code>传入的<code>this</code>，所以就又回到了责任链调用。这一次，我们会取出下一个元素，里面会包含<code>AspectJAroundAdvice</code>和<code>MethodMatcher</code>两个，所以会执行上面省略的那一部分代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.ReflectiveMethodInvocation</span></span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">    InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">    <span class="comment">// 获取目标对象的class</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">        <span class="comment">//如果目标对象和目标方法与代理匹配，则调用拦截器中的方法（也就是advice方法）</span></span><br><span class="line">        <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果目标对象和目标方法与代理不匹配，则直接递归调用下一个责任链节点</span></span><br><span class="line">        <span class="keyword">return</span> proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="AspectJAroundAdvice"><span class="post-title-index">3.2.3.2. </span><a href="#AspectJAroundAdvice" class="headerlink" title="AspectJAroundAdvice"></a>AspectJAroundAdvice</h4><p>这样，通过<code>dm.interceptor.invoke</code>就进入了<code>Around</code> advice。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.aspectj.AspectJAroundAdvice</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MethodInvocation is not a Spring ProxyMethodInvocation: "</span> + mi);</span><br><span class="line">    &#125;</span><br><span class="line">    ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">    <span class="comment">// 生成可执行process()方法的JoinPoint对象，以作为@Around修饰的方法的入参（之一）</span></span><br><span class="line">    ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">    JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">    <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里很简单，创建了一个<code>ProceedingJoinPoint</code>对象（这也就是我们在切面中<code>@Around</code>中使用的那个可以调用<code>process()</code>的<code>JoinPoint</code>对象。<br>继续往<code>invokeAdviceMethod()</code>方法中走，经过<code>argBinding()</code>函数将参数整理成<code>@Around</code>需要的数量和顺序，然后就可以调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object[] actualArgs = args;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        actualArgs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(<span class="keyword">this</span>.aspectJAdviceMethod);</span><br><span class="line">        <span class="comment">// 这里就是调用的核心，直接调用@Around修饰的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aspectJAdviceMethod.invoke(<span class="keyword">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="comment">/* blabla */</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里很简单，this.aspectJAdviceMethod就是@Around修饰的那个<code>around</code>方法<code>public Object around(ProceedingJoinPoint joinPoint) throws Throwable</code>，invoke的第一个参数就是<code>ServiceAspect</code>的实例，第二个就是<code>around</code>方法的入参列表。这样就进入了<code>ServiceAspect.around()</code>函数里。直接跟踪进入<code>MethodInvocationProceedingJoinPoint.process()</code>方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.methodInvocation.invocableClone().proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的invocableClone主要做了两件事情，首先会将参数列表进行浅拷贝，然后将methodInvocation进行浅拷贝（包括其中的chain）。上面的注解中明确了浅拷贝的目的，那就是既能使用原有的引用和chain，同时又能保证值的独立性。下图中左边的是克隆后的对象，右边蓝色边框中的是原对象，可以看出对象id发生了变化（原来是@5872，现在是@6646）；另外，argument数组对象也发生了变化（原来是@5860，现在是@6617）。但其他的都是直接引用的（包括argument中的元素也没有进行复制）。<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/JdkDynamicProxy-MethodInvocationShallowClone.png" alt="JdkDynamicProxy-MethodInvocationShallowClone">  </p>
<p>接下来，又回到了<code>ReflectiveMethodInvocation.proceed()</code>，这次按照顺序，会从责任链中取出<code>MethodBeforeAdviceInterceptor</code>。</p>
<h4 id="MethodBeforeAdviceInterceptor"><span class="post-title-index">3.2.3.3. </span><a href="#MethodBeforeAdviceInterceptor" class="headerlink" title="MethodBeforeAdviceInterceptor"></a>MethodBeforeAdviceInterceptor</h4><p>进入<code>MethodBeforeAdviceInterceptor.invoke()</code>，很简单，就2行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里<code>mi</code>是<code>ReflectiveMethodInvocation</code>，所以<code>mi.getMethod()</code>仍然是controller中的那个函数，经过跟踪，发现在<code>this.advice.before</code>中根本没有使用这个参数-，-。<br>不管了，继续往里面，为了执行before advice，还需要先执行<code>getJoinPointMatch()</code>，这个是干什么的呢？主要是用来进行参数（advice入参）绑定的。我们知道，在@Pointcut上面以及各个诸如@Around、@Before上，都可以增加一个argNames字段，这样在编译后如果抹掉了参数名称导致无法绑定的话，就需要利用argNames字段进行辅助。但是这些被存在了<code>ReflectiveMethodInvocation</code>的<code>userAttribute</code>中，这是一个<code>Map</code>，key是<code>@Pointcut</code>修饰的函数名，value就是一个<code>JoinPointMatch</code>对象，里面描述了参数的绑定关系。<br>说起来很复杂，其实就是在进行传参时，需要通过<code>ReflectiveMethodInvocation</code>的<code>userAttribute</code>拿到参数绑定信息。但信息在这么深的地方是访问不到的，这时候，责任链的首个元素就发挥作用了，看下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> JoinPointMatch <span class="title">getJoinPointMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MethodInvocation mi = ExposeInvocationInterceptor.currentInvocation();</span><br><span class="line">    <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"MethodInvocation is not a Spring ProxyMethodInvocation: "</span> + mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getJoinPointMatch((ProxyMethodInvocation) mi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码第一行，就是通过<code>ExposeInvocationInterceptor</code>的静态方法<code>currentInvocation()</code>，利用ThreadLocal获取到了此线程中的当前的MethodInvocation，这玩意儿就是在责任链首个元素处理过程中添加到<code>invocations</code>中的。<a href="####ExposeInvocationInterceptor">点此跳转到那段代码</a>这样一来，ExposeInvocation的作用就很清楚了。  </p>
<p>接下来就和Around一样，就可以执行到<code>ServiceAspect.before()</code>中了。<br>至于为什么Around不需要通过<code>ExposeInvocationInterceptor.currentInvocation()</code>来获取<code>JoinPointMatch</code>，是因为在<code>AspectJAroundAdvice.invoke(MethodInvocation mi)</code>中，直接通过入参<code>mi</code>就拿到了<code>JoinPointMatch</code>；而Before中竟然传了一些垃圾进去，却没有把这么重要的<code>mi</code>传进去。不知道设计者是怎么想的，可能还有什么更精妙的设计在其中，只不过我还没有悟透。</p>
<p>这样，总算把Before执行完了，一路return回到<code>MethodBeforeAdviceInterceptor</code>的这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这时候，我们就可以执行<code>return mi.proceed()</code>了。回到<code>ReflectiveMethodInvocation.proceed()</code>，继续在责任链中取出节点。这次取出的是<code>AspectJAfterAdvice</code>。</p>
<h4 id="AspectJAfterAdvice"><span class="post-title-index">3.2.3.4. </span><a href="#AspectJAfterAdvice" class="headerlink" title="AspectJAfterAdvice"></a>AspectJAfterAdvice</h4><p>进入<code>AspectJAfterAdvice.invoke()</code>，它是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>很明显能看出来会先继续从责任链中取advice，最后在调用After的advice方法。<br>那么就继续取吧。接下来取出的是<code>AfterReturningAdviceInterceptor</code>。</p>
<h4 id="AfterReturningAdviceInterceptor"><span class="post-title-index">3.2.3.5. </span><a href="#AfterReturningAdviceInterceptor" class="headerlink" title="AfterReturningAdviceInterceptor"></a>AfterReturningAdviceInterceptor</h4><p>进入<code>AfterReturningAdviceInterceptor.invoke()</code>，看上去也很简单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object retVal = mi.proceed();</span><br><span class="line">    <span class="keyword">this</span>.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>继续从责任链里取，似乎已经取到最后一个了，这次取出的是<code>AspectJAfterThrowingAdvice</code>。</p>
<h4 id="AspectJAfterThrowingAdvice"><span class="post-title-index">3.2.3.6. </span><a href="#AspectJAfterThrowingAdvice" class="headerlink" title="AspectJAfterThrowingAdvice"></a>AspectJAfterThrowingAdvice</h4><p>进入<code>AspectJAfterThrowingAdvice.invoke()</code>，原本以为要结束了，结果还有一层：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldInvokeOnThrowing(ex)) &#123;</span><br><span class="line">            invokeAdviceMethod(getJoinPointMatch(), <span class="keyword">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再次调用<code>ReflectiveMethodInvocation.proceed()</code>，这次终于是最后一次了，因为在方法的开始，就因为责任链已经取完了，直接调用目标函数，并返回即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用链已经取完了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//直接调用目标函数</span></span><br><span class="line">    <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，就终于进入了心心念念的<code>JdkDynamicServiceImpl.useJdkDynamicProxy()</code>方法之中。看看调用栈：<br><img src="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/JdkDynamicProxyCallStack.png" alt="JdkDynamicProxyCallStack">  </p>
<p>从下往上栈逐渐变深。</p>
<ul>
<li>最下面是<code>MyController</code>中的API接口函数（当然这个<code>MyController</code>实际上是<code>CGLib</code>根据<code>LogAspect</code>生成的代理），</li>
<li>下面数第2个，是<code>ServiceAspect</code>生成的<code>JdkDynamicServiceImpl</code>的代理。</li>
<li>下面数第3个，就是<code>Around</code>的Advice对象。</li>
<li>再往上，就是<code>ServiceAspect</code>中的<code>around()</code>函数。</li>
<li>再往上的4个分别就是<code>Before</code>、<code>After</code>、<code>AfterReturning</code>、<code>AfterThrowing</code>的advice对象。</li>
<li>最上方的，就是目标对象的目标函数，也就是<code>JdkDynamicServiceImpl.useJdkDynamicProxy()</code>了。  </li>
</ul>
<p>在目标函数中，如果发生了异常，就会被<code>AspectJAfterThrowingAdvice</code>中的catch截获，交由<code>ServiceAspect</code>中的<code>@AfterThrowing</code>处理。没有问题就会一层一层往上抛，并依次执行<code>@AfterReturning</code>、<code>@After</code>。直到回到<code>@Around</code>之中。再继续返回直到回到<code>MyController</code>之中。这样，整个调用过程就终于结束了。</p>
<h2 id="初始化切面、构造责任链"><span class="post-title-index">3.3. </span><a href="#初始化切面、构造责任链" class="headerlink" title="初始化切面、构造责任链"></a>初始化切面、构造责任链</h2><p>上面生成代理对象、调用代理对象的过程基本上已经清楚了，那么如何初始化切面以及责任链呢？还是跟着源码来看一看。</p>
<h3 id="初始化切面"><span class="post-title-index">3.3.1. </span><a href="#初始化切面" class="headerlink" title="初始化切面"></a>初始化切面</h3><p>Spring AOP在BeanFactory中注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>（名字贼长），在调用其<code>findCandidateAdvisors()</code>时，通过<code>BeanFactoryAspectJAdvicorsBuilder.buildAspectJAdvicors()</code>遍历<code>beanFactory</code>中的所有bean，找出所有<code>isAspect()</code>的bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来对每一个Aspect类型的bean进行分析。对当前Aspect的Bean，调用<code>ReflectiveAspectJAdvisorFactory.getAdvisors()</code>来获取Advisor列表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">    validate(aspectClass);</span><br><span class="line">    <span class="comment">//这个装饰器可以防止MetadataAwareAspectInstanceFactory被重复实例化</span></span><br><span class="line">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">            <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line"></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注意这个getAdvisorMethod()</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, <span class="number">0</span>, aspectName);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略下面的非单例aspect和introduction的advisor的添加</span></span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这个方法中，会通过<code>getAdvisorMethods(aspectClass)</code>来获取有所Advice方法。这个需要注意：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAdvisorMethods</span><span class="params">(Class&lt;?&gt; aspectClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ReflectionUtils.doWithMethods(aspectClass, method -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将所有不带@Pointcut的method都加进来，并使用ReflectionUtils.USER_DECLARED_METHODS过滤器先筛一遍</span></span><br><span class="line">        <span class="comment">// 这个过滤器只保留用户定义的方法，过滤掉桥接方法等编译器生成的方法</span></span><br><span class="line">        <span class="keyword">if</span> (AnnotationUtils.getAnnotation(method, Pointcut<span class="class">.<span class="keyword">class</span>) </span>== <span class="keyword">null</span>) &#123;</span><br><span class="line">            methods.add(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">    <span class="keyword">if</span> (methods.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 然后对方法进行排序</span></span><br><span class="line">        methods.sort(METHOD_COMPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而这个排序方法，奠定了后续责任链中的顺序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 按照下面列出的顺序排序</span></span><br><span class="line">    Comparator&lt;Method&gt; adviceKindComparator = <span class="keyword">new</span> ConvertingComparator&lt;&gt;(</span><br><span class="line">            <span class="keyword">new</span> InstanceComparator&lt;&gt;(</span><br><span class="line">                    Around<span class="class">.<span class="keyword">class</span>, <span class="title">Before</span>.<span class="title">class</span>, <span class="title">After</span>.<span class="title">class</span>, <span class="title">AfterReturning</span>.<span class="title">class</span>, <span class="title">AfterThrowing</span>.<span class="title">class</span>),</span></span><br><span class="line"><span class="class">            (<span class="title">Converter</span>&lt;<span class="title">Method</span>, <span class="title">Annotation</span>&gt;) <span class="title">method</span> -&gt; </span>&#123;</span><br><span class="line">                AspectJAnnotation&lt;?&gt; ann = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);</span><br><span class="line">                <span class="keyword">return</span> (ann != <span class="keyword">null</span> ? ann.getAnnotation() : <span class="keyword">null</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    Comparator&lt;Method&gt; methodNameComparator = <span class="keyword">new</span> ConvertingComparator&lt;&gt;(Method::getName);</span><br><span class="line">    <span class="comment">// 如果出现多个相同的注解的方法，将方法的名字作为次关键字进行二次排序</span></span><br><span class="line">    METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这里，就能知道各Advice的排序依据了。  </p>
<h3 id="构造Advisor元素"><span class="post-title-index">3.3.2. </span><a href="#构造Advisor元素" class="headerlink" title="构造Advisor元素"></a>构造Advisor元素</h3><p>最后，对排好序的每一个非@Pointcut修饰的方法调用<code>getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrderInAspect, String aspectName)</code>，如果是一个合法的advisor，就会在advisor的实例化过程中根据<code>@Around</code>或<code>@Before</code>之类的分别创建不同的Advice实例并持有，然后这个advisor就被被加入到advisors列表中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.aspectj.annotation.ReflectiveAspectJAdvisorFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,  MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="keyword">int</span> declarationOrder, String aspectName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 验证Aspect类的合法性</span></span><br><span class="line">    Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    validate(candidateAspectClass);</span><br><span class="line">    <span class="comment">// 确认其存在@Around、@Before之类的注解</span></span><br><span class="line">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isAspect(candidateAspectClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Advice must be declared inside an aspect type: "</span> +</span><br><span class="line">                <span class="string">"Offending method '"</span> + candidateAdviceMethod + <span class="string">"' in class ["</span> +</span><br><span class="line">                candidateAspectClass.getName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Found AspectJ method: "</span> + candidateAdviceMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用来存放根据这个method生成的advice</span></span><br><span class="line">    AbstractAspectJAdvice springAdvice;</span><br><span class="line">    <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> AtPointcut:</span><br><span class="line">            <span class="comment">// 如果不小心混入了@Pointcut，那么就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Processing pointcut '"</span> + candidateAdviceMethod.getName() + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> AtAround:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAroundAdvice(candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AtBefore:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJMethodBeforeAdvice(</span><br><span class="line">                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AtAfter:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAfterAdvice(</span><br><span class="line">                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAfterReturningAdvice(</span><br><span class="line">                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">            <span class="comment">// 如果@AfterReturning存在returning字段，也就是给返回值命名了，需要将这个参数名保留下来</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">                springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">            springAdvice = <span class="keyword">new</span> AspectJAfterThrowingAdvice(</span><br><span class="line">                    candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">            <span class="comment">// 如果@AfterThrowing存在throwable字段，也就是给异常值命名了，需要将这个参数名保留下来</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Unsupported advice type on method: "</span> + candidateAdviceMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    springAdvice.setAspectName(aspectName);</span><br><span class="line">    springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">    String[] argNames = <span class="keyword">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (argNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">        springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">    &#125;</span><br><span class="line">    springAdvice.calculateArgumentBindings();</span><br><span class="line">    <span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对所有Aspect都分析完成后，将所有的Advisor都合并在一个列表中。这样准备工作就完成了。</p>
<h3 id="为代理对象装入Advisor-chain"><span class="post-title-index">3.3.3. </span><a href="#为代理对象装入Advisor-chain" class="headerlink" title="为代理对象装入Advisor chain"></a>为代理对象装入Advisor chain</h3><p>在创建Proxy的过程中，由于首先要实例化目标对象，所以AOP在<code>postProcessAfterInitialization</code>中加入了创建Proxy的动作。<br>在<code>AbstractAutoProxyCreator</code>中的<code>wrapIfNessesary</code>，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经advice了，那么就创建拦截器责任链</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而这里的<code>getAdvicesAndAdvisorsForBean</code>会调用<code>AbstractAdvisorAutoProxyCreator.findEligibleAdvisors()</code>，来获取符合当前Proxy的目标对象的advisors。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先找到候选的Advisors，也就是所有Aspect中的Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 然后根据目标对象的名字和类型，筛选合适的Aspect中的所有Advisor</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里会分两步进行，首先调用<code>findCandidateAdvisors()</code>将所有的Aspect中的Advisor筛选出来作为候选的（candidate）Advisor，然后根据bean的类型和名字，将这些候选的Advisor中合适的保留下来，并按照<code>@Order</code>进行排序。<br>这里用于排序的是<code>org.springframework.core.annotation.AnnotationAwareOrderComparator</code>，它继承自<code>org.springframework.core.OrderComparator</code>，是专门用于有order的排序器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">sortAdvisors</span><span class="params">(List&lt;Advisor&gt; advisors)</span> </span>&#123;</span><br><span class="line">    AnnotationAwareOrderComparator.sort(advisors);</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然，在排序之前，还有非常重要的一步，那就是<code>extendAdvisors(eligibleAdvisors)</code>。这一步是干什么呢，就是把责任链中的首个元素（<code>ExposeInvocationInterceptor</code>装进去）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.aspectj.AspectJProxyUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">makeAdvisorChainAspectJCapableIfNecessary</span><span class="params">(List&lt;Advisor&gt; advisors)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果列表是空的，就不要加入ExposeInvocationInterceptor了</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> foundAspectJAdvice = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">            <span class="comment">// Be careful not to get the Advice without a guard, as this might eagerly</span></span><br><span class="line">            <span class="comment">// instantiate a non-singleton AspectJ aspect...</span></span><br><span class="line">            <span class="keyword">if</span> (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">                foundAspectJAdvice = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果列表中存在AspectJ的Advice且还没有添加过ExposeInvocationInterceptor，那么就添加一个到列表头</span></span><br><span class="line">        <span class="keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">            advisors.add(<span class="number">0</span>, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>至于为什么要从所有的Aspect中选择，那是因为一个代理可能会同时符合多个Aspect中的Advisor。</p>
<p>然后将advisors回传，完成<code>AbstractAutoProxyCreator.wrapIfNessesary()</code>中的<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code>。接下来，就可以调用<code>createProxy()</code>了。<br>在<code>createProxy()</code>中，跟着逻辑一步一步，就走到了梦寐以求的位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.DefaultAopProxyFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp; (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，就执行到创建代理对象处了。<br>终于回来了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/AOP/" rel="tag"># AOP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/11/ReadSource-SpringAop-01Usage/" rel="prev" title="阅读源码-SpringAOP-01使用">
      <i class="fa fa-chevron-left"></i> 阅读源码-SpringAOP-01使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/" rel="next" title="阅读源码-SpringAOP-03CgLibProxy">
      阅读源码-SpringAOP-03CgLibProxy <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#自己实现一个Proxy"><span class="nav-text">1. 自己实现一个Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现代码"><span class="nav-text">1.1. 实现代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试"><span class="nav-text">1.2. 测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加入Around和自动注入"><span class="nav-text">1.3. 加入Around和自动注入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringAOP中代理Proxy的实现方式"><span class="nav-text">2. SpringAOP中代理Proxy的实现方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK-Dynamic-Proxy"><span class="nav-text">3. JDK Dynamic Proxy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代理对象的生成"><span class="nav-text">3.1. 代理对象的生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理的过程"><span class="nav-text">3.2. 代理的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#测试代码编写"><span class="nav-text">3.2.1. 测试代码编写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察主要逻辑"><span class="nav-text">3.2.2. 观察主要逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#责任链调用"><span class="nav-text">3.2.3. 责任链调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ExposeInvocationInterceptor"><span class="nav-text">3.2.3.1. ExposeInvocationInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AspectJAroundAdvice"><span class="nav-text">3.2.3.2. AspectJAroundAdvice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MethodBeforeAdviceInterceptor"><span class="nav-text">3.2.3.3. MethodBeforeAdviceInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AspectJAfterAdvice"><span class="nav-text">3.2.3.4. AspectJAfterAdvice</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AfterReturningAdviceInterceptor"><span class="nav-text">3.2.3.5. AfterReturningAdviceInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AspectJAfterThrowingAdvice"><span class="nav-text">3.2.3.6. AspectJAfterThrowingAdvice</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化切面、构造责任链"><span class="nav-text">3.3. 初始化切面、构造责任链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化切面"><span class="nav-text">3.3.1. 初始化切面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造Advisor元素"><span class="nav-text">3.3.2. 构造Advisor元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为代理对象装入Advisor-chain"><span class="nav-text">3.3.3. 为代理对象装入Advisor chain</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴迪"
      src="/images/avatar.jpg?raw=true">
  <p class="site-author-name" itemprop="name">吴迪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备17000391号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴迪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      var config = {
        theme:'default',
        logLevel:'fatal',
        securityLevel:'strict',
        startOnLoad:true,
        arrowMarkerAbsolute:false,

        er:{
          diagramPadding:20,
          layoutDirection:'TB',
          minEntityWidth:100,
          minEntityHeight:75,
          entityPadding:15,
          stroke:'gray',
          fill:'honeydew',
          fontSize:12,
          useMaxWidth:true,
        },
        flowchart:{
          diagramPadding:8,
          htmlLabels:true,
          curve:'linear',
        },
        sequence:{
          diagramMarginX:50,
          diagramMarginY:10,
          actorMargin:50,
          width:150,
          height:65,
          boxMargin:10,
          boxTextMargin:5,
          noteMargin:10,
          messageMargin:35,
          messageAlign:'center',
          mirrorActors:true,
          bottomMarginAdj:1,
          useMaxWidth:true,
          rightAngles:false,
          showSequenceNumbers:false,
        },
        gantt:{
          titleTopMargin:25,
          barHeight:20,
          barGap:4,
          topPadding:50,
          leftPadding:75,
          gridLineStartPadding:35,
          fontSize:11,
          fontFamily:'"Open-Sans", "sans-serif"',
          numberSectionStyles:4,
          axisFormat:'%Y-%m-%d',
        }
      };
      mermaid.initialize(config);
    }
  </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
