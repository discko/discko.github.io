<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wudi.space","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前文中主要线程的原理、进程内线程同步的原理、以及JUC中常用或常问的工具类的用法和特点进行介绍。本文将对JUC中各个工具类的基础——AQS——进行源码级细致分析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Concurrent-AQS">
<meta property="og:url" content="https://www.wudi.space/2020/12/26/Concurrent-AQS/index.html">
<meta property="og:site_name" content="吴迪小站">
<meta property="og:description" content="前文中主要线程的原理、进程内线程同步的原理、以及JUC中常用或常问的工具类的用法和特点进行介绍。本文将对JUC中各个工具类的基础——AQS——进行源码级细致分析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.wudi.space/2020/12/26/Concurrent-AQS/CallStackOfAQS.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/26/Concurrent-AQS/BugWithoutPROPAGATE.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/26/Concurrent-AQS/UsageOfDegradeReadWriteLock.png">
<meta property="article:published_time" content="2020-12-26T03:24:08.000Z">
<meta property="article:modified_time" content="2021-01-02T03:32:09.330Z">
<meta property="article:author" content="吴迪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.wudi.space/2020/12/26/Concurrent-AQS/CallStackOfAQS.png">

<link rel="canonical" href="https://www.wudi.space/2020/12/26/Concurrent-AQS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Concurrent-AQS | 吴迪小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴迪小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2020/12/26/Concurrent-AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Concurrent-AQS
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-26 11:24:08" itemprop="dateCreated datePublished" datetime="2020-12-26T11:24:08+08:00">2020-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-02 11:32:09" itemprop="dateModified" datetime="2021-01-02T11:32:09+08:00">2021-01-02</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前文中主要线程的原理、进程内线程同步的原理、以及JUC中常用或常问的工具类的用法和特点进行介绍。本文将对JUC中各个工具类的基础——AQS——进行源码级细致分析。<br><a id="more"></a><br>前文JUC中的工具类中，不使用<code>synchronized</code>，是如何实现阻塞和阻塞队列的呢？答案就是，这些类中都存在一个（大部分都命名为<code>Sync</code>）继承自<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>（也就是AQS）的内部类，通过其实例化生成的对象（通常命名为<code>sync</code>）进行上锁、阻塞、排队、解锁的过程。  </p>
<p>AQS其实有两个，一个叫<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>，一个叫<code>java.util.concurrent.locks.AbstractQueuedLongSynchronizer</code>。名字上后一个比前一个多了一个Long。通过注释可以看到，后者的state属性是long类型的，而前者的state属性是int类型的，其他都是一样的。后面我们会知道，state其实就是用于标记可分享的锁的数量（对于共享锁而言）或者重入的次数（对于独占锁而言）的，在特殊条件下，int不够用，就会使用long的。两者在逻辑上是一致的，因此在下面的分析过程中，还是会以<code>AbstractQueuedSynchronizer</code>进行。</p>
<h1 id="AQS的基本构造"><span class="post-title-index">1. </span><a href="#AQS的基本构造" class="headerlink" title="AQS的基本构造"></a>AQS的基本构造</h1><h2 id="结构"><span class="post-title-index">1.1. </span><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>AQS是由一个双向链表构成的，其结点是<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.Node</code>。<code>Node</code>中有一些属性，来一个个看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer.Node</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>waitStatus</code>：当前结点的等待状态。初始化为0，表示是普通的一个同步线程结点；初始化为<code>CONDITION</code>(值为<code>-2</code>)，表示这个结点是通过<code>condition.await()</code>进行阻塞的。总的而言，大部分情况下不需要去判断这些特定的值，只需要根据符号就可以了，正值就表示已经被取消了，负值则表示正处于等待状态。</li>
<li><code>prev</code>：前驱结点。只有在入队的时候才会被赋值，在出队的时候才会被设为null。</li>
<li><code>next</code>：后继结点。只有在入队的时候才会被赋值，当某结点被取消（<code>CACELLED</code>）的时候会被修改（修改为指向自己以示标记，也为了能更好地GC），在出队的时候才会被设为null。从这种意义上来说，next为null不能表示这个结点就在队尾。</li>
<li><code>thread</code>：用于记录这个结点表示的thread。在入队的时候赋值，当当被取消或者被设为头结点（开始使用这个线程）时，设为null</li>
<li><code>nextWaiter</code>：专门用于<code>Condition</code>的等待队列，因为<code>Condition</code>是独占的，所以只需要一个单向链表就可以了。当<code>Condition</code>被唤醒，结点将重新被加入上面的双向链表等待队列去重新获取锁。</li>
</ul>
<p>waitStatus可选的值及含义如下：   </p>
<ul>
<li><code>CANCELLED</code>：值为<code>1</code>。表示该线程获取锁的过程（因为timeout超时或interrupt中断或者发生了什么异常）已经被取消了，不在尝试进入临界区。  </li>
<li><code>SIGNAL</code>：值为<code>-1</code>。表示当前结点的后继结点目前已经（或即将）被阻塞了，而且在本结点被唤醒或被取消之后，应该唤醒其后继结点。通常是由那个“即将被阻塞”的结点，修改其前驱结点为<code>SIGNAL</code>。    </li>
<li><code>CONDITION</code>：值为<code>-2</code>。表示当前结点正在一个Condition等待队列（<code>Condition Wait Queue</code>）中。这个值不会被用于阻塞队列，当从等待队列中结束等待，被转移到阻塞队列中时，会被改设为0。</li>
<li><code>PROPAGATE</code>：值为<code>-3</code>。表示在释放共享锁时，应当将释放过程传播给其他结点。这个值只有头结点才可以在<code>doReleaseShared</code>方法中设置。</li>
<li>值<code>0</code>：用来标记非以上所有状态。</li>
</ul>
<p>然后，在AQS中，有声明为该Node类型的属性，记录该双向队列的头尾结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>head</code>：等待队列的头。因为头结点是当前正在使用的结点，所以<code>head.waitStatus</code>绝对不会是<code>CANCELLED</code></li>
<li><code>tail</code>：等待队列的尾。只能通过入队方法（<code>enq(Node)</code>）修改，来添加一个结点</li>
<li><code>state</code>：同步的状态。对于<code>ReentrantLock</code>而言，就是重入的次数，初始化时为0，在同一线程中每lock一次就+1，每unlock一次就-1，当回到0时，就说明这个锁可以释放了。</li>
</ul>
<p>这个阻塞队列参考自一个名为<code>CHL</code>的数据结构（由三个姓氏首字母分别为C、H、L的人发明）。该队列有这样的性质：  </p>
<ul>
<li>这个阻塞队列的头表示目前已经被激活（甚至已经结束）的线程。这也就意味着，参与竞争的是除了队首之外的元素。</li>
<li>这是一个准双向链表，通过next和prev指针连接。逆序（prev）保证是连通的，但是正序（next）可能会在某些非队尾结点提前中断（为null或者指向自己），这是为了能够快速标记无效的结点。</li>
</ul>
<h2 id="方法"><span class="post-title-index">1.2. </span><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>AQS中有如下比较重要的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 可供外部调用的获取锁的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>; <span class="comment">// 获取独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;<span class="comment">// 获取可中断的独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;   <span class="comment">// 获取共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 获取可中断的独占锁</span></span><br><span class="line"><span class="comment">// 2. 可供外部调用的释放锁的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 释放独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>; <span class="comment">// 释放共享锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 查询锁的状态，并尝试获取锁，由AQS的派生类具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 尝试获取独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;<span class="comment">// 尝试获取共享所</span></span><br><span class="line"><span class="comment">// 4. 查询缩短状态，并尝试释放锁，由AQS的派生类具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 尝试释放独占锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;<span class="comment">// 尝试释放共享锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 用于 Lock.tryLock(long timeout, TimeUnit unit)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span>;   <span class="comment">// 尝试一定时间去获取独占锁，内部会调用tryAcquire 和 doAcquireNanos</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span>; <span class="comment">// 尝试一定时间去获取共享锁，内部会调用tryAcquireShared和doAcquireSharedNanos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 内部对阻塞队列操作的过程</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 对独占锁阻塞队列的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;   <span class="comment">// 对可中断独占锁阻塞队列的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span>; <span class="comment">// 在一定时间内对独占锁阻塞队列的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;  <span class="comment">// 对共享锁阻塞队列的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span>; <span class="comment">// 对可中断共享锁阻塞队列的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span>;   <span class="comment">// 在一定时间内对共享锁阻塞队列的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 内部唤醒被阻塞线程的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 因意外，取消本次获取锁过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span></span>;</span><br></pre></td></tr></table></figure><br>方法稍微分一下组：</p>
<ol>
<li>暴露给各个类型的锁的实现类，可直接调用的用于加锁的方法。根据类型可分为独占锁和共享锁，如果这个锁是可以被打断的（应用用于<code>Lock.lockInterruptibly()</code>则可以使用带有Interruptibly的方法。</li>
<li>暴露给各个类型的锁的实现类，可直接调用的用于解锁的方法。比如各个<code>Lock.unlock()</code>、<code>CountDownLatch.countdown()</code>之类的都会调用本组的方法。</li>
<li>查询锁状态，尝试获取锁的过程。这2个方法由各AQS的派生类去实现，直接调用AQS中这2个方法会抛出<code>UnsupportOperation</code>异常。其参数<code>arg</code>通常是指想要获取或释放的锁的次数。而返回的是获取的结果，对于<code>tryAcquireShared</code>而言返回值是本次获取后剩余的共享锁的数量，也就是说负数表示获取失败、0表示获取成功但是后续就<strong><em>可能</em></strong>无法获取了，整数表示后续<strong><em>可能</em></strong>仍然能获取成功（所谓<strong><em>可能</em></strong>，就是说后续在再次上锁的时候，还是需要再判断一下）；而对于<code>tryAcquire</code>而言，就表示此次获取是true成功的或者false失败的。</li>
<li>查询锁状态，尝试释放锁的过程。这2个方法由各AQS的派生类去实现，直接调用AQS中这2个方法会抛出<code>UnsupportOperation</code>异常。其参数<code>arg</code>通常是指想要获取或释放的锁的次数。而返回的是获取的结果，true成功的或者false失败的。</li>
<li>这两个是专门用于<code>Lock.tryLock(long time, TimeUnit unit)</code>这种类型的方法，在其内部还是会调用<code>tryAcquireShared</code>和<code>doAcquireSharedNanos</code>这两个方法。</li>
<li>对于第3组方法调用后返回尝试获取锁失败的情况，会先将本线程加入阻塞队列，然后调用本组方法，对阻塞队列进行操作，对需要阻塞的，会在本组方法中阻塞。</li>
<li>在调用第2组的方法后，会首先调用第4组进行尝试获取锁，若果成功了，则通过本组方法，对阻塞的线程进行唤醒。</li>
<li>当在获取锁的过程中（已经进入阻塞队列，或者被从阻塞状态唤醒后但还没来得及修改状态的时候）发生意外时，通过该方法兜底。</li>
</ol>
<h2 id="方法执行顺序"><span class="post-title-index">1.3. </span><a href="#方法执行顺序" class="headerlink" title="方法执行顺序"></a>方法执行顺序</h2><p>用流程图解释一下可以获得锁和无法获得锁的过程。<br><img src="/2020/12/26/Concurrent-AQS/CallStackOfAQS.png" alt="CallStackOfAQS">  </p>
<h2 id="具体源码分析"><span class="post-title-index">1.4. </span><a href="#具体源码分析" class="headerlink" title="具体源码分析"></a>具体源码分析</h2><p>看完大致流程，接下来到源码中仔细看一下，AQS是怎么做锁实现无关部分的控制的。</p>
<h3 id="上锁入口"><span class="post-title-index">1.4.1. </span><a href="#上锁入口" class="headerlink" title="上锁入口"></a>上锁入口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquire</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquireInterruptibly</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquireSharedInterruptibly</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致都是差不多的，在进入上锁入口后，调用对应的<code>tryAcquireXXX</code>方法（<code>tryAcquire</code>、<code>tryAcquireShared</code>），如果失败，则进入相应的<code>doAcquireXXX</code>方法（<code>acquireQueued</code>、<code>doAcquireInterruptibly</code>、<code>doAcquireShared</code>、<code>doAcquireSharedInterruptibly</code>）。这里<code>tryAcquireXXX</code>失败，根据锁的形式会有一些区别，共享锁的话因为返回的是尝试获取后还剩余的锁的数量，所以<code>&lt;0</code>表示获取失败；而独占锁直接返回成功或失败。<br>这里不太一样的地方在于，由于<code>acquireQueued</code>方法会返回在阻塞过程中是否发生了中断（不需要反馈中断的，即使发生了中断也视为没有中断过），所以把<code>acquireQueued</code>放在了<code>if</code>的条件中，为真则触发<code>selfInterrupt</code>也就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#selfInterrupt</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="尝试获取锁失败后"><span class="post-title-index">1.4.2. </span><a href="#尝试获取锁失败后" class="headerlink" title="尝试获取锁失败后"></a>尝试获取锁失败后</h3><p>入口还是比较简单的，由于<code>tryAcquireXXX</code>是由各个派生类自己实现的，而且如果try acquire成功后，就直接结束lock过程了，所以接下来看看try acquire失败后，如何对阻塞队列进行处理。  </p>
<p>查看各个方法，都需要执行的是addWaiter方法。独占的两个传入的第一个参数是<code>Node.EXCLUSIVE = null</code>，共享的两个传入的是<code>NODE.SHARED = new Node()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;    <span class="comment">// 队列为空，则懒初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;  <span class="comment">// 将node加入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Node(Thread thread, Node mode) &#123;</span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>addWaiter</code>还是比较好理解的，就是通过CAS操作，将本线程对应的结点放到同步队列的队尾。如果CAS操作失败了，就通过<code>for(;;)</code>进行无限循环（也就是自旋），直到成功为止。特别的，如果队列为空，则在此时再进行初始化（懒初始化）。<br>可是为什么要将锁的模式放到<code>nextWaiter</code>字段呢？前面说过了，<code>nextWaiter</code>是用来存放Condition的等待队列的。这是因为Condition只能用于独占锁中，而<code>Node.EXCLUSIVE = null</code>、<code>NODE.SHARED = new Node()</code>，所以通过<code>nextWaiter == null</code>就可以判断这个锁是独占的还是共享的。</p>
<p>接下来分锁类型看看加入队列之后，具体都干了些什么。</p>
<h4 id="独占锁尝试获取失败后"><span class="post-title-index">1.4.2.1. </span><a href="#独占锁尝试获取失败后" class="headerlink" title="独占锁尝试获取失败后"></a>独占锁尝试获取失败后</h4><p>首先是独占锁的<code>acquireQueue</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取node的前驱结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 如果前驱是头结点，且本线程尝试获取锁成功</span></span><br><span class="line">                setHead(node); <span class="comment">// 本结点升级为头结点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 头结点释放</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)   <span class="comment">// 在尝试失败后，需要park</span></span><br><span class="line">            &amp;&amp; parkAndCheckInterrupt()) <span class="comment">//执行park</span></span><br><span class="line">                <span class="comment">// park时发生了中断，记录下来</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 发生了错误，取消获取锁</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>还是利用<code>for(;;)</code>自旋。然后获取node的前驱结点。因为队首元素是正在被执行的线程（甚至已经执行结束了），所以如果node的前驱是对手元素的话，那么node就是队列中最优先可以去获取的结点了。接下来我们跳过<code>if (p == head &amp;&amp; tryAcquire(arg))</code>，先看一下下面的，因为这是在一个自旋之中，下面执行完了，还是会执行到这边。<br>下面是一个if语句，包含两个判断条件，如果第一个是false的话，就短路第二个以及if块中的代码。第一个条件是<code>shouldParkAfterFailedAcquire(p, node)</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所谓应不应该park，是要确认前面的结点的状态是否已经设置好了。只有当前一个结点的<code>waitStatus</code>被设置为<code>SIGNAL</code>，那么本结点在前一个结点的锁释放之后，本结点才能被通知唤醒。所以<code>ws == Node.SIGNAL</code>表示前一个结点已经设置好了，本结点可以安心地去睡了；<code>ws&gt;0</code>表示前面的结点已经被取消了，那么就循环向前寻找本结点真正有效（<code>waitStatus&lt;0</code>)的前驱结点（然后等下一次自旋再来判断是否已经设置好了）;<code>else</code>的话，就表示前驱结点还是有效的，那么就通过CAS将其状态改为SIGNAL，至于成功了还是失败了，不能在这里浪费时间，等下一次自旋的时候再去判断。</p>
<p>接下来就可以进行park了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用<code>LockSupport.park()</code>来阻塞线程。当某处唤醒本线程后，返回阻塞或称中是否发生了中断。  </p>
<p>接下来再到上面的<code>if</code>那边：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquireQueued</span></span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取node的前驱结点</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">    <span class="comment">// 如果前驱是头结点，且本线程尝试获取锁成功</span></span><br><span class="line">    setHead(node); <span class="comment">// 本结点升级为头结点</span></span><br><span class="line">    p.next = <span class="keyword">null</span>; <span class="comment">// 头结点释放</span></span><br><span class="line">    failed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#setHead</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当被唤醒后，通过自旋，再次来到这边，如果node已经排到优先级最高处（其前驱结点为头结点），则再次tryAcquire。<br>这里为什么要再次tryAcquire而不是直接占用锁呢？这是为了兼容公平与非公平两种锁。前一篇文章已经说了，ReentrantLock可以在构造时设置该可重入锁是公平的还是非公平的。所谓公平与非公平的区别，就是正好执行到类似于<code>lock.lock()</code>语句处的线程，是先进入阻塞队列（那么对于已经进入阻塞队列的线程就是公平的，大家一起排队），还是先不管三七二十一尝试占有一下锁（那么对于已经进入阻塞队列的线程就是非公平的，后来的可能会先执行）。那么对于后一种情况（非公平的），这里就只能通过tryAcquire去竞争一下。如果竞争失败了，只能再次park，等待下一次被唤醒；如果竞争成功了，则自己成为阻塞队列的头结点，然后一路退出调用栈，直到回到<code>lock.lock()</code>处，就可以继续执行后面的代码了。  </p>
<h4 id="共享锁获取失败后"><span class="post-title-index">1.4.2.2. </span><a href="#共享锁获取失败后" class="headerlink" title="共享锁获取失败后"></a>共享锁获取失败后</h4><p>对于共享锁而言，当<code>tryAcquireShared()</code>之后，直接调用<code>doAcquireShared(arg)</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#doAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，除了把<code>addWaiter(Node.SHARED)</code>搬到了里面之外，基本上是一样的。<br>后半段也是<code>shouldParkAfterFailedAcquire</code>和<code>parkAndCheckInterrupt</code>。在被唤醒之后，尝试获取共享锁<code>tryAcquireShared(arg)</code>，获取成功的话则将自己设为设置阻塞队列的头结点，并传播，然后一路返回到自己在业务代码中被阻塞的位置，继续执行。<br>这里需要注意的是这个函数<code>setHeadAndPropagate(node, r)</code>。<code>node</code>就是当前结点，<code>r</code>就是本结点获取锁之后，可能还剩的可占用锁的数量。设为头结点这个可以理解，但为什么要propagate呢。propagate是繁殖、传播的意思，因为共享锁是允许被多个线程持有的，一旦有一个线程被唤醒，只要剩余的共享锁的数量足够，就可以将其他的线程唤醒，所以要通过这个函数将队列中的其他线程唤醒，让他们也来尝试获取这个共享锁（毕竟<code>r</code>是不准确的，所以这些线程还是要经历“竞争”这个过程）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#setHeadAndPropagate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// 记录当前头结点，也就是本结点的前驱结点</span></span><br><span class="line">    setHead(node); <span class="comment">// 将本结点设为头结点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的可获取共享锁数量是足够的</span></span><br><span class="line">        <span class="comment">// 或者而且原来的头结点是有效的</span></span><br><span class="line">        <span class="comment">// 或者现在的头结点是有效的</span></span><br><span class="line">        <span class="comment">// 则</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 若有后继结点且后继结点是共享锁，则继续释放共享锁</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#doReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不断循环</span></span><br><span class="line">        Node h = head;  <span class="comment">// 获得当前的头结点（可能会变化）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 队列中存在被阻塞的结点（不算头结点）</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 如果需要唤醒后继结点</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">// 将其状态改为0，表示正在释放后继结点，失败了就自旋</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 状态修改好了，释放后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="comment">// 释放完毕后，尝试将状态修改为需要传播</span></span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="comment">// 如果头结点没变，则结束循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="释放锁入口"><span class="post-title-index">1.4.3. </span><a href="#释放锁入口" class="headerlink" title="释放锁入口"></a>释放锁入口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#release</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#releaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管要不要考虑中断，锁释放的过程都是一致的，所以只有独占锁和共享锁的2种释放方式。<br>首先都是<code>tryRelease</code>或者<code>tryReleaseShared</code>。它们的主要作用就是修改<code>state</code>的值。<br>然后在try成功之后根据独占或共享锁，分别执行<code>unparkSuccessor()</code>或<code>doReleaseShared()</code>具体执行所释放的阻塞队列操作。  </p>
<h4 id="独占锁释放时的操作"><span class="post-title-index">1.4.3.1. </span><a href="#独占锁释放时的操作" class="headerlink" title="独占锁释放时的操作"></a>独占锁释放时的操作</h4><p>独占锁执行<code>unparkSuccessor(Node head)</code>。由于锁是独占的，所以传入的head在此过程中不会发生变化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果头结点的waitStatus是有效的，则将其先置为0</span></span><br><span class="line">        <span class="comment">// 不过就算失败了也没有关系</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取头结点的后继结点，如果是null或者是无效的，那么就倒序寻找离头结点最近的有效结点</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果找到了，就unpark</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>首先将waitStatus置为0，失败了也没有关系。这里<code>waitStatus</code>只要<code>&lt;0</code>，那么只要其他地方的程序写的没有问题，就必然是<code>SIGNAL</code>。因为几个负值，<code>CONDITION</code>只能用于condition等待队列中，<code>PROPAGATE</code>只能用于共享锁。<br>然后获取头结点的后继结点（因为根据<code>SIGNAL</code>的要求，应当唤醒后继结点）。如果获取的后继结点是无效的，或者next指针指向了null，那么就从tail开始倒序查找（前面也说了，next可能是不连通的，但prev是可靠的连通的）。<br>最后，如果找到了的话，就将这个结点对应的线程唤醒。  </p>
<p>这时，就回到了<code>acquireQueue()</code>方法中的自旋循环中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizor#acquireQueue</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取node的前驱结点</span></span><br><span class="line">    <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱是头结点，且本线程尝试获取锁成功</span></span><br><span class="line">        setHead(node); <span class="comment">// 本结点升级为头结点</span></span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// 头结点释放</span></span><br><span class="line">        failed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)</span><br><span class="line">    &amp;&amp; parkAndCheckInterrupt())     <span class="comment">// 从这里被唤醒</span></span><br><span class="line">        <span class="comment">// 因为parkAndCheckInterrupt()返回了true</span></span><br><span class="line">        <span class="comment">// 所以在park时发生了中断，记录下来</span></span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#setHead</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个线程从<code>parkAndCheckInterrupt()</code>中被唤醒。重新自旋回到上面，获取这个被唤醒的结点的前驱结点（因为是被头结点唤醒的，头结点只会唤醒其后继结点，而且线程是阻塞的，只有一个被唤醒，这就意味着此时<code>head</code>属性不会发生变化，<code>node</code>的前驱结点<code>p</code>必然是<code>head</code>。所以直接进行<code>tryAcquire</code>。<br>这里需要解释一下，为什么还需要进行<code>tryAcquire</code>而不能让<code>node</code>直接占有锁呢？这就要考虑到前一篇中的公平锁与非公平锁了。在线程阻塞排队时，公平锁根据FIFO的原则按照先进先出的顺序被阻塞和唤醒；而非公平锁，则除了FIFO之外，还需要与刚进入临界区，还没有进入FIFO队列的线程进行竞争。<br>如果<code>tryAcquire</code>失败了，那么就需要重新park，等待下一次唤醒。如果成功了，就执行<code>if</code>中的3行，也就是将本结点设为头结点，释放头结点（从交给GC），然后结束<code>acquireQueue</code>方法，并逐层返回至业务代码（调用类似<code>lock.lock()</code>处，结束阻塞，继续向下。直到这个线程也执行到<code>lock.unlock()</code>释放队列中的下一个线程的阻塞。  </p>
<h4 id="共享锁释放时的操作"><span class="post-title-index">1.4.3.2. </span><a href="#共享锁释放时的操作" class="headerlink" title="共享锁释放时的操作"></a>共享锁释放时的操作</h4><p>共享锁的<code>doReleaseShared()</code>是这样写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#doReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 不断循环</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 如果头结点的waitStatus是SIGNAL的话</span></span><br><span class="line">                <span class="comment">// 就将其置为0，并唤醒1个后继结点</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">// 如果将h的waitStatus从SIGNAL置为0失败，就不断自旋直到成功</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// h的waitStatus从SIGNAL置为0成功</span></span><br><span class="line">                <span class="comment">// 释放1个后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="comment">// 如果头结点waitStatus是0</span></span><br><span class="line">                <span class="comment">// 则尝试将其置为PROPAGATE</span></span><br><span class="line">                <span class="comment">// 失败的话就自旋</span></span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="comment">// 在此过程中，如果头结点没有发生变化，就结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里有3个状态的判断。<br>首先判断当前的头结点的<code>waitStatus</code>是否是<code>SIGNAL</code>。因为<code>SIGNAL</code>状态要求在自己释放或者<code>unpark</code>后，要唤醒后继结点。为了防止重复唤醒，所以先将<code>waitStatus</code>置为<code>0</code>，成功后再<code>unparkSuccessor</code>。<br>如果不是<code>SIGNAL</code>而是<code>0</code>的话，则该结点可能是刚初始化的结点，将其设为<code>PROPAGATE</code>，失败则自旋。<br>在前两个都执行完后，如果头结点发生了变化，那么再次自旋，本线程承担新头结点的唤醒工作。直到头结点不再发生变化，结束<code>doReleaseShared</code>，这时，层层返回，直到业务层代码，继续执行。<br>而后继结点被unpark之后，就会开始在它的<code>doAcquireShared</code>中继续执行。在其自旋循环中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#doAcquireShared</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">    <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            setHeadAndPropagate(node, r);</span><br><span class="line">            p.next = <span class="keyword">null</span>; </span><br><span class="line">            <span class="keyword">if</span> (interrupted)</span><br><span class="line">                selfInterrupt();</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#setHeadAndPropagate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结束park后从<code>parkAndCheckInterrupt</code>返回，然后掉头回到上面。获得当前结点<code>node</code>的前驱结点，如果它不是是头结点，那么重新去park。如果是头结点，那么就将本结点设为头结点并传播（setHeadAndPropagate）、该抛中断异常就抛中断异常（selfInterrupt)，然后返回调用栈直到业务代码（比如<code>lock.lock()</code>）并结束阻塞，继续向下执行到<code>lock.unlock</code>释放本线程的共享锁。<br>这里还有最后一个方法<code>setHeadAndPropagate(Node node, int propagate)</code>。一起来看一下。<br>入参<code>node</code>就是当前结点，<code>int</code>参数<code>propagate</code>就是传入的r，也就是<code>node</code>在获取锁之后，可能还剩余的共享锁的数量。然后再来看代码。<br><code>setHead(node)</code>没什么好说的，主要就是这个<code>if</code>语句，一个一个来分析一下。  </p>
<ul>
<li><code>propagate &gt; 0</code>：进入条件是<code>r&gt;=0</code>，所以这里是有可能<code>propagate == 0</code>从而不满足的。如果可能已经没有剩余的共享锁供阻塞队列中的其他线程去竞争，就不要去唤醒它们了。等其他占有锁的线程释放之后，依然有机会释放它们。  </li>
<li><code>h == null || h.waitStatus &lt; 0</code>：这两个可以一起看，<code>h</code>存在且其<code>waitStatus</code>指示它是有效的。<code>h</code>是上面获取的头结点。但是明明在<code>doReleaseShared</code>中，调用<code>unparkSuccessor</code>前已经通过CAS将<code>waitStatus</code>设为0了呀，这里怎么会<code>&lt;0</code>呢？这只能说明，就在此时（在原线程中将原来的头结点<code>waitStatus</code>设为0之后，在本线程中执行<code>setHead(node)</code>之前），有其他的线程释放了共享锁，这样就进入了<code>doReleaseShared</code>的<code>if (ws == 0 &amp;&amp;!compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</code>语句，成功将原头结点的<code>waitStatus</code>设为了<code>PROPAGATE(-3)</code>。  </li>
<li><code>(h = head) == null || h.waitStatus &lt; 0</code>：前一个<code>h.waitStatus&lt;0</code>是常态，因为上面这种情况发生的概率比较小。那么在<code>propagate == 0</code>时大部分情况都会落到这一个判断中。这里的<code>head</code>很有可能就是入参<code>node</code>，也就是当前线程结点，因为才刚被设为头结点，所以<code>waitStatus</code>应当还是<code>SIGNAL</code>。  </li>
</ul>
<p>对于后两个情况，既然<code>propagate == 0</code>已经是0了，为什么还要去唤醒阻塞队列中后面的线程呢？这个在源码的注释中也提到了。其实被唤醒也没有关系，如果此时共享锁不足，会在<code>doReleaseShared</code>里的自旋之后继续<code>park</code>。</p>
<h4 id="PROPAGATE状态的作用"><span class="post-title-index">1.4.3.3. </span><a href="#PROPAGATE状态的作用" class="headerlink" title="PROPAGATE状态的作用"></a>PROPAGATE状态的作用</h4><p>到这里，似乎还没有完全弄懂PROPAGATE这个状态的作用。也确实，这个状态并不是在一开始就存在的，而是在jdk低版本中出现bug之后才增加的。<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6801020" target="_blank" rel="noopener">报告的bug</a>和<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java?r1=1.73&amp;r2=1.74" target="_blank" rel="noopener">修复的代码</a>。可以看到这是一个2009年的bug了。那时候我还只是一个用Pascal做NOIP、只会一点点vb写点小玩具的高中生。。。  </p>
<p>假设没有PROPAGATE，我们来设想一种状态。<br>有2个线程<code>t1``和t2</code>同时向获取共享锁但是由于锁不足被阻塞着。这时，有2个线程<code>t3</code>和<code>t4</code>同时释放共享锁。  </p>
<ul>
<li>时刻1：<code>t3</code>线程<code>tryReleaseShared</code>成功，这时<code>state = 1</code>。调用<code>unparkSuccessor</code>将头结点的<code>waitStatus</code>设为<code>0</code>，然后唤醒阻塞队列中优先级较高的<code>t1</code>。</li>
<li>时刻2：<code>t1</code>线程调用<code>tryAcquireShared</code>成功，<code>state</code>回到<code>0</code>，并作为<code>propagate</code>值传入<code>setHeadAndPropagate</code>。</li>
<li>时刻3：<code>t4</code>线程<code>tryReleaseShared</code>成功。但是在<code>releaseShared</code>方法中不满足<code>h.waitStatus != 0</code>，所以不唤醒<code>t2</code>。</li>
<li>时刻4：回到<code>t1</code>，在<code>setHeadAndPropagate</code>中，执行<code>setHead</code>将自己升级为头结点。由于此时<code>propagate = 0</code>，不满足<code>propagate &gt; 0</code>的条件，不执行<code>unparkSuccessor(node)</code>。因此<code>t1</code>不唤醒<code>t2</code>。  </li>
</ul>
<p>所以这样来看，如果<code>t1</code>不释放的话，<code>t2</code>就永远不会被唤醒了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原版的releaseShared方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// doAcquireShared方法，新旧版基本没有变化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原版的setHeadAndPropagate方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> &amp;&amp; node.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原版unparkSuccessor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    compareAndSetWaitStatus(node, Node.SIGNAL, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个过程大致如下图：<br><img src="/2020/12/26/Concurrent-AQS/BugWithoutPROPAGATE.png" alt="Bug Without PROPAGATE"><br>按照预期，应该在<code>t4</code>的<code>releaseShared</code>或者<code>t1</code>的<code>setHeadAndPropagate</code>中唤醒<code>t2</code>，结果都错过了。</p>
<p>在旧版的代码中，不能将<code>setHeadAndPropagate</code>中的条件判断简单修改为<code>if (propagate &gt; 0 || node.waitStatus &lt; 0)</code>，因为在上面这种线程切换方式下，这两个条件依然是无法满足的。<br>为此，新版的代码中增加了<code>doReleaseShared</code>方法和<code>PROPAGATE</code>状态。<br>我们来看一下在新代码的情况下，如果发生了上述线程切换过程，会怎么样：</p>
<ul>
<li>时刻1：<code>t3</code>线程<code>tryReleaseShared</code>成功，这是<code>state = 1</code>。调用<code>doReleaseShared</code>方法。这是由于阻塞队列中存在<code>t1</code>和<code>t2</code>，所以头结点的状态必然是<code>SIGNAL</code>，所以通过CAS将其置为<code>0</code>（如果失败的话，那就是<code>t4</code>在与<code>t3</code>竞争，那把<code>t4</code>当做<code>t3</code>就好了，也是一样的），然后通过<code>unparkSuccessor</code>唤醒<code>t1</code>线程。</li>
<li>时刻2：<code>t1</code>线程被唤醒，恢复在<code>doAcquireShared</code>的执行。通过<code>for(;;)</code>自旋后，因为node的前驱必然是头结点，所以可以调用<code>tryAcquireShared</code>。由于此时<code>state = 1</code>，所以有剩余的共享锁，获取之后<code>state</code>又回到<code>0</code>。接下来在<code>r &gt;= 0</code>的条件下，将<code>r = 0</code>作为<code>propagate</code>传入<code>setHeadAndPropagate</code>。</li>
<li>时刻3：<code>t4</code>开始释放共享锁。<code>tryReleaseShared</code>成功之后（这样<code>state</code>变成了<code>1</code>），现在不需要再进行任何判断，直接进入<code>doReleaseShared</code>。由于<code>t1</code>还没将自己升级为头结点，所以这是<code>t4</code>发现头结点（还是原来的头结点）的状态变成了0，就通过CAS将其设为了<code>PROPAGATE(-3)</code>。</li>
<li>时刻4：<code>t1</code>继续在<code>setHeadAndPropagate</code>中执行，将自己设为头结点，然后虽然传入的<code>propagate</code>（即过时的<code>state</code>）是<code>0</code>，但是头结点的状态已经被<code>t4</code>修改成了<code>PROPAGATE(-3)</code>，满足<code>waitStatus &lt; 0</code>，所以可以尝试唤醒后继节点。这样，<code>t2</code>就可以被唤醒了。  </li>
</ul>
<p>当然，如果时刻4和时刻3交换一下，也没有关系，也就是<code>t1</code>先<code>setHead</code>，然后<code>t4</code>再释放，那么<code>t4</code>中获得的<code>head</code>就是<code>t1</code>的结点了，这个结点的状态必然是<code>SIGNAL</code>所以，会由<code>t4</code>来唤醒<code>t2</code>。  </p>
<p>从这个角度来说的话，<code>t4</code>线程将头结点的状态设为<code>PROPAGATE</code>的目的就是：我知道有个线程刚刚被唤醒并获得了共享锁，但还没来得及将自己设为阻塞队列的头结点（因为此时<code>t4</code>查询到的头结点的<code>waitStatus</code>是<code>0</code>，而且因为自己还在队列中，所以肯定不是队列才刚刚初始化造成<code>waitStatus = 0</code>的，那就只可能是被另一个刚刚释放锁的线程置为<code>0</code>的了），那么这个还没来得及将自己设为头结点的结点，因为我这里又释放了一个共享搜，你待会儿记得通知一下其他被阻塞的线程，可以去抢我释放的这个共享锁了。  </p>
<p>所以，换句话说，如果没有<code>t4</code>插一脚的话，<code>t1</code>读取到的<code>waitStatus &lt; 0</code>的条件就不满足了，就不会去唤醒其他线程（当然，因为没有<code>t4</code>插一脚，就不会有额外的共享锁供准备被唤醒的线程去获取，自然也就不需要唤醒后继的线程了）。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在的releaseShared方法 jdk1.8.0_161</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在的doAcquireShared方法，没有发生关键性变化</span></span><br><span class="line"><span class="comment">// 现在的setHeadAndPropagate方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增的doReleaseShared方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Condition下的等待和通知"><span class="post-title-index">1.4.4. </span><a href="#Condition下的等待和通知" class="headerlink" title="Condition下的等待和通知"></a>Condition下的等待和通知</h3><p>前面是共享锁和独占锁的加锁、释放和竞争过程。相对而言Condition就简单多了。<br>Condition</p>
<h4 id="Condition的基本结构"><span class="post-title-index">1.4.4.1. </span><a href="#Condition的基本结构" class="headerlink" title="Condition的基本结构"></a>Condition的基本结构</h4><p>Condition是一个接口，具体的实现由<code>AbstractQueuedSynchronizer.ConditionObject</code>内部类来实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><br>其中有两个成员属性，用来记录首个waiter结点，和末尾waiter结点。再联系到Node中存在nextWaiter属性，可以知道，每一个Condition都对应一个等待队列，这个队列是一个单向链表。结构比阻塞队列要简单的多。  </p>
<h4 id="Condition的阻塞"><span class="post-title-index">1.4.4.2. </span><a href="#Condition的阻塞" class="headerlink" title="Condition的阻塞"></a>Condition的阻塞</h4><p>当调用<code>condition.await()</code>时，开始阻塞：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConditionObject#await()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 将节点添加到waiter队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 记录并释放此时的重入次数</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 如果不在阻塞队列中了，在waiter队列中进行park</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 下面是在waiter队列中被通知唤醒后</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果是因为中断而被唤醒的，直接break</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在阻塞队列中竞争，竞争成功后，根据需要进行中断或恢复中断标志</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大致流程就是，新建一个结点，并将这个节点加入到等待队列中，然后将本线程的重入次数记录下来，并且释放这些重入次数。接下来通过<code>LockSupport.park</code>，使当前线程进入等待状态，每一次被唤醒，就检查本线程是否已经进入阻塞队列，如果不在阻塞队列中，则继续等待。当被唤醒并且本线程已经在阻塞队列中时，说明<code>condition.signal</code>系列函数被执行了，需要去争抢锁的占有权，因此进入阻塞队列。争抢成功后，根据需要抛出<code>InterruptException</code>异常进行中断，或者调用<code>Thread.interrupt()</code>恢复中断标志位。  </p>
<p>先看如何加入等待队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取目前的等待队列队尾节点</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 如果队尾节点是CANCELLED状态，将其从等待队列中清除</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建节点，其waitStatus为CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果队伍为空，则将节点作为等待队列队首节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 将本节点追加到队尾</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>整个流程比较简单。唯一需要注意的有这两个地方：</p>
<ul>
<li>为什么通过<code>t.waitStatus != Node.CONDITION</code>就可以判断队尾节点的状态？因为<code>Condition</code>中的节点，其可选的状态原则上只有<code>CANCELLED</code>和<code>CONDITION</code>两种。那么如果不是<code>CONDITION</code>，就一定是被取消的或者其他非法的状态。  </li>
<li>如果倒数第二个结点也是<code>CANCELLED</code>怎么办？可以自己看一下<code>unlinkCancelledWaiters</code>的源码，这里面从头到尾进行的遍历，把所有的<code>!= Node.CONDITION</code>的节点都清除掉了。  </li>
</ul>
<p>接下来是释放并记录重入次数，这一步很重要。由于进入Condition状态时，本线程被挂起，需要其他阻塞队列中的线程去竞争，如果重入次数不清除，那么后续从阻塞队列中来竞争的线程，会发现剩余的锁不足。而如果不记录重入次数，在本线程结束condition的等待并获得线程原本的锁后，进行释放来清除重入次数时，就会发生错误。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 返回重入次数</span></span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断是否在阻塞队列中的目的，是确保本节点不会被阻塞队列中的前驱结点唤醒；等待队列中被唤醒后，再次判断是否在阻塞队列中，可以确保接下来参与竞争时不会发生错误。<br>检查是否在阻塞队列中还是比较简单粗暴的，最坏的情况就是从尾到头遍历一遍阻塞结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer#isOnSyncQueue</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#findNodeFromTail</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，进入Condition的等待状态就差不多结束了。</p>
<h4 id="Condition的释放"><span class="post-title-index">1.4.4.3. </span><a href="#Condition的释放" class="headerlink" title="Condition的释放"></a>Condition的释放</h4><p>condition通知释放时可通过<code>condition.signal()</code>来唤醒等待时间最长的线程（也就是等待队列中的首个），也可以通过<code>condition.signalAll()</code>来唤醒所有。通常会使用<code>signalAll()</code>。  </p>
<p>在通知前，首先会判断当前模式是不是独占的（因为Condition不支持共享模式）。<br>之后调用<code>doSignalAll()</code>方法执行具体的通知逻辑。<code>doSignalAll()</code>中会从头到尾遍历等待队列，并调用<code>transferForSignal()</code>方法将这些节点的状态从<code>CONDITION</code>修改为<code>0</code>、将他们依次加入阻塞队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.ConditionObject#signalAll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是独占模式</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 通知等待队列中的所有结点</span></span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer.ConditionObject#doSignalAll</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从first开始往后遍历等待队列中的所有结点</span></span><br><span class="line">    <span class="keyword">do</span> &#123; transfer</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 转移每一个结点至阻塞队列</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#transferForSignal</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改结点装从CONDITION至0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 加入阻塞队列</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果Condition被取消，或者修改状态为SIGNAL失败，就直接提前将其唤醒（没有关系，反正还是要通过acquireQueue方法竞争锁）</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在被强制唤醒、或在阻塞队列中排队结束被唤醒之后，原来在等待状态的线程，就会恢复在<code>await()</code>中的执行，继续下面的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.ConditionObject#await()</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><br>可以看到，这里将之前保存的<code>savedState</code>作为参数传入了<code>qcquireQueue</code>，这样当该线程争取到锁之后，就会立刻将state恢复为<code>condition.await()</code>之前的重入次数。<br>在获取锁之后，通过<code>unlinkCancelledWaiters</code>清理等待队列，通过<code>reportInterruptAfterWait</code>发出<code>InterruptException</code>中断异常或用<code>Thread.interrupt()</code>恢复中断标记。然后一路清空调用栈，继续<code>condition.await()</code>之后的业务代码。</p>
<h2 id="结束"><span class="post-title-index">1.5. </span><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>至此，AQS内阻塞队列和等待队列的流程就梳理完成了。<br>可以看出来，锁的竞争过程本身并不复杂，但是在多线程下，这个问题的复杂度立刻就升上了，特别是在高并发下，两个看似相邻的指令，可能会因为高并发的问题，中间被其他线程插入很多的甚至可能会修改状态的其他指令。<br>不得不佩服大牛们设计的算法，也不得不感谢先行的前辈们为我们踩坑。  </p>
<h1 id="几个常用AQS实现的具体实现方式"><span class="post-title-index">2. </span><a href="#几个常用AQS实现的具体实现方式" class="headerlink" title="几个常用AQS实现的具体实现方式"></a>几个常用AQS实现的具体实现方式</h1><h2 id="ReentrantLock-可重入锁"><span class="post-title-index">2.1. </span><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock 可重入锁"></a>ReentrantLock 可重入锁</h2><p>先看一下<code>ReentrantLock</code>是如何实现的。</p>
<h3 id="公平与非公平"><span class="post-title-index">2.1.1. </span><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h3><p>首先看一下加锁。<code>ReentrantLock.lock()</code>中只有一句话：<code>sync.lock()</code>。而根据<code>new ReentrantLock(boolean fair)</code>中<code>fair=true</code>或<code>fair=false</code>（默认为<code>false</code>，sync可能有2种实现：<code>ReentrantLock.FairSync</code>和<code>ReentrantLock.NonfairSync</code>，也就是公平锁与非公平锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.FairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock.NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 通过CAS将state从0设为1成功，即说明抢占成功</span></span><br><span class="line">        <span class="comment">// 将锁的独占线程设为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 抢占失败，走正常的上锁逻辑</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以说，公平锁就是走正常的获取锁流程；而非公平锁，则首先抢占式先通过CAS的方式改变一下锁的<code>state</code>（将<code>state</code>通过CAS设为<code>1</code>，如过成功，则将锁的独占线程<code>thread</code>变量设为当前线程），失败的话，再走正常的获取锁流程。  </p>
<h3 id="尝试获取锁"><span class="post-title-index">2.1.2. </span><a href="#尝试获取锁" class="headerlink" title="尝试获取锁"></a>尝试获取锁</h3><p>在公平情况或者非公平但是开门竞争失败的情况下，两者都会调用<code>acquire</code>方法。这个方法在<a href="#上锁入口">上面</a>已经分析过了。会调用<code>tryAcquire</code>的方法，在<code>FairSync</code>中直接实现了<code>tryAcquire()</code>，而<code>UnfaireSync</code>的<code>tryAcquire()</code>中调用了<code>nonfairTryAcquire()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.FairSync#tryAcquire</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 锁没有被占用</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 阻塞队列中没有等待时间更长的结点，且</span></span><br><span class="line">            <span class="comment">// 锁竞争成功，则</span></span><br><span class="line">            <span class="comment">// 将本线程设为该锁的独占线程，并返回尝试获取锁成功</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程本来就是该锁的独占线程，则重入次数增加</span></span><br><span class="line">        <span class="comment">// 并返回尝试获取锁成功</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则说明现在锁正在被别的线程占有，或者有更优先的结点</span></span><br><span class="line">    <span class="comment">// 返回尝试获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock.UnfairSync#nonfairTryAcquire</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 锁没有被占有</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 不管FIFO，直接竞争锁成功，则</span></span><br><span class="line">            <span class="comment">// 将本线程设为锁的独占线程，并返回尝试获取锁成功</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 说明现在锁正在被别的线程占有，返回尝试获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出来，公平与非公平主要体现在2个地方。第一个是lock的时候，非公平会猜测现在的<code>state</code>是<code>0</code>，直接去将其改为<code>1</code>，搏一搏单车变摩托。第二个就是在<code>tryAcquire</code>中，公平锁即使在发现<code>state == 0</code>，也会先判断一下<code>hasQueuedPredecessors</code>，也就是队列中是否已经排有其他的结点，如果有的话，此时如果本线程再去抢占锁，就不符合FIFO的公平原则，所以会放弃竞争；而非公平锁无所谓，捡着空就上。<br>如果竞争失败了，无论公平锁还是非公平锁，都会进入<code>doAcquireXXX</code>系列的方法中，就不赘述了。  </p>
<h3 id="尝试释放锁"><span class="post-title-index">2.1.3. </span><a href="#尝试释放锁" class="headerlink" title="尝试释放锁"></a>尝试释放锁</h3><p><code>ReentrantLock.Sync</code>只有一个<code>tryRelease</code>的实现，无论<code>FairSync</code>还是<code>UnFairSync</code>都直接继承了该方法。<br>这个方法主要做了2件事情，一个是削减重入次数，一个是当重入次数为0时将锁的独占线程由自己设为<code>null</code>。所以还是比较简单的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ReentrantReadWriteLock-可重入读写锁"><span class="post-title-index">2.2. </span><a href="#ReentrantReadWriteLock-可重入读写锁" class="headerlink" title="ReentrantReadWriteLock 可重入读写锁"></a>ReentrantReadWriteLock 可重入读写锁</h2><p>可重入读写锁<code>ReentrantReadWriteLock</code>包含了一个<code>ReadLock</code>和一个<code>WriteLock</code>，并且共享了同一个<code>Sync</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock#ReentrantReadWriteLock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.ReadLock#ReadLock</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">    sync = lock.sync;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.WriteLock#WriteLock </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">    sync = lock.sync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们知道，读锁是共享的，写锁是独占的。当读锁上锁的时候，其他想要获取读锁的线程是允许获取读锁的；但当读锁上锁时，想要获取写锁是不可以的，需要阻塞直到所有读锁都被释放。而当写锁上锁时，其他想要获得锁的（无论是想要获得读锁还是写锁），都会被阻塞，直到这个写锁被释放，然后再竞争。所以，必须要通过这样的设计，让读锁与写锁的状态是互相可见的，才能确保读写锁的正确上锁与释放。  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">已经上了读锁</th>
<th style="text-align:center">已经上了写锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同线程尝试上读锁</td>
<td style="text-align:center">成功</td>
<td style="text-align:center">成功</td>
</tr>
<tr>
<td style="text-align:center">同线程尝试上写锁</td>
<td style="text-align:center">成功</td>
<td style="text-align:center">成功</td>
</tr>
<tr>
<td style="text-align:center">异线程尝试上读锁</td>
<td style="text-align:center">成功</td>
<td style="text-align:center">阻塞</td>
</tr>
<tr>
<td style="text-align:center">异线程尝试上写锁</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">阻塞</td>
</tr>
</tbody>
</table>
</div>
<p>在开始正式分析读写锁分别的上锁和释放锁的过程之前，先来看看<code>ReentrantReadWriteLock.Sync</code>中几个比较有意思的常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">* Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">* The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">* and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>根据注释，读写锁的<code>Sync</code>，将AQS的state当做了前后两个unsigned short来使用。高2个字节用于存放共享锁（读锁），低2个字节用于存放独占锁（写锁）。这样也就解释了这4个常量的含义。  </p>
<ul>
<li><code>SHARED_SHIFT</code>：共享计数要偏移16位。  </li>
<li><code>SHARED_UNIT</code>：本来获取锁或者释放锁是对state进行+1或-1操作。而在读写锁中，写锁还是保持不变，读锁获取锁或者释放锁，是增加或者减少<code>SHARED_UNIT</code>。  </li>
<li><code>MAX_COUNT</code>：读锁与写锁的加锁上限，超过的的话，就意味着加锁次数溢出了。</li>
<li><code>EXCLUSIVE_MASK</code>：独占锁重入次数的掩码。可以通过<code>state &amp; EXCLUSIVE_MASK</code>快速获取独占锁的次数。</li>
</ul>
<p>接下来看一下读锁与写锁的上锁与释放锁的过程。</p>
<h3 id="上写锁"><span class="post-title-index">2.2.1. </span><a href="#上写锁" class="headerlink" title="上写锁"></a>上写锁</h3><p>写锁是支持重入的独占锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.WriteLock#lock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.Sync#tryAcquire</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取写锁重入次数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c!=0 且 w == 0 表示读锁次数不为0</span></span><br><span class="line">        <span class="comment">// 如果存在读锁，或者读写锁被其他线程占有，则此次尝试获取锁失败，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 执行到这里，说明是锁重入，是线程安全的</span></span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 更新重入次数，返回尝试获取锁成功</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行到这里，说明需要竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="comment">// 竞争失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 执行到这里，说明竞争成功，将锁的独占线程设为本线程，返回尝试获取锁成功</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在判断时，<code>c!=0</code>表示现在存在写锁或者读锁的占用情况。<code>w==0</code>表示写锁为0，那么必然此时存在读锁，不应该获取写锁，所以返回false。<br>这里的<code>writerShouldBlock</code>根据公平或非公平，有两种不同的实现。如果是非公平的，那么直接进行一次CAS来增加重入次数；而公平锁只有在阻塞队列中本节点的前驱为空时，才能尝试通过CAS增加重入次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.FairSync#writerShouldBlock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.NonfairSync#writerShouldBlock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后更新锁的当前独占线程为本线程。<br>至此，读锁的加锁过程完成。中间如果有任何一个位置返回false，则需要在进入AQS的<code>acquireQueued</code>中进行阻塞排队。  </p>
<h3 id="释放写锁"><span class="post-title-index">2.2.2. </span><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><p>写锁的释放很简单，在调用AQS的<code>release</code>方法后，回到<code>ReentrantReadWriteLock.Sync</code>的<code>tryRelease</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.WriteLock#unlock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.Sync#tryRelease</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 获取释放后的重入次数</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">// 如果重入次数为0，则将锁的独占线程设为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 修改重入次数</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="上读锁"><span class="post-title-index">2.2.3. </span><a href="#上读锁" class="headerlink" title="上读锁"></a>上读锁</h3><p>读锁是支持重入的共享锁。在调用AQS的<code>acquireShared</code>方法后，回到<code>ReentrantReadWriteLock.Sync</code>的<code>tryAcquireShared</code>。这里的<code>tryAcquireShared</code>只是一个为了效率进行的简易版尝试获取共享锁。如果获取失败了，才会通过<code>fullyTryAcquireShared</code>进行完整版尝试获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.ReadLock#lock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.Sync#tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">// 如果写锁存在，且不是本线程占有，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 运行到这里有2种情况</span></span><br><span class="line">    <span class="comment">// 1. 写锁不存在</span></span><br><span class="line">    <span class="comment">// 2. 写锁存在，但写锁由本线程独占</span></span><br><span class="line">    <span class="comment">// 针对第二种情况，如果读锁获取成功，那就是可能会进行锁降级</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 不会溢出，且竞争成功</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是读锁归零后首个获得读锁的线程，则记录到这两个变量中</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程是读锁归零后首个获得读锁的线程，则更新下面这个变量</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是读锁归零厚度首个线程，将信息记录到ThreadLocalHoldCounter中</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要读阻塞或者获取读锁会溢出或者CAS失败，执行该函数</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>前面的过程比较简单，如果当前已经是被其他线程加上写锁，则此次获取失败，返回-1。<br><code>readerShouldBlock()</code>同样有公平与非公平两个实现。所谓<code>readerShouldBlock</code>就是说需不需要先进入阻塞队列中。对于公平情况，如果阻塞队列中有前驱结点，那就需要进入阻塞队列中去排队。对于非公平情况，查看一下阻塞队列中，如果第一个有效结点（head的后继节点）是写锁，那么本线程也就去乖乖排队了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.FairSync#readerShouldBlock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.NonfairSync#readerShouldBlock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#apparentlyFirstQueuedIsExclusive</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="comment">// head的后继s不为空且s是独占的</span></span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后如果不溢出，且CAS成功的话，根据条件更新firstReader和firstReaderHoldCount这两个变量，或者执行下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.Sync#tryAcquireShared</span></span><br><span class="line">HoldCounter rh = cachedHoldCounter;</span><br><span class="line"><span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">    readHolds.set(rh);</span><br><span class="line">rh.count++;</span><br></pre></td></tr></table></figure><br>这里的readHolds是<code>ReentrantReadWriteLock.Sync</code>的一个内部类（也就是<code>ReentrantReadWriteLock</code>内部类的内部类），是用<code>HoldCounter</code>实化的<code>ThreadLocal</code>。而<code>HoldCounter</code>同样是<code>ReentrantReadWriteLock.Sync</code>的一个内部类，里面记录线程ID和一个<code>count</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里使用Thread.tid这个private属性，而不是这个线程的引用</span></span><br><span class="line">    <span class="comment">// 是为了方式这个HoldCounter组织GC回收这个线程对象。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的<code>cachedHoldCounter</code>用于记录上一个成功获取锁的线程的<code>HoldCounter</code>。<br>如果<code>rh</code>也就是<code>cachedHoldCounter</code>是<code>null</code>或者不属于本线程，则通过<code>readHolds</code>这个<code>ThreadLocal</code>去获取一个（或者通过<code>ThreadLocalHoldCounter.initialValue</code>创造一个专属本线程的<code>HoldCounter</code>。然后将count自增。<br>这样就在每个线程中记录下了读锁重入的次数。<br>而如果上面的操作失败（判断reader需要被阻塞、获取锁后会溢出、CAS失败），则执行<code>Sync#fullTryAcquireShared</code>，在进行一次完整版的<code>tryAcquireShared</code>。  </p>
<p>所以说这里利用了两个缓存，一个是<code>firstReader</code>，对于并发程度不激烈的情况，重入或者申请后立刻释放发生的概率比和其他线程交替获取释放锁的概率要高。第二个是<code>cachedHoldCounter</code>，也就是同一个线程连续上锁或释放锁，同样基于并发不严重的情况。在这两个都不满足的情况下，才会利用ThreadLocal去存储各个线程自己的重入次数，从这种程度来说，也是为了集中管理这些次数记录，而不是分散在各个线程之中。  </p>
<h3 id="释放读锁"><span class="post-title-index">2.2.4. </span><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><p>读锁的释放就相对比较简单了。调用AQS的<code>releaseShared</code>方法，回到<code>ReentrantReadWriteLock.Sync</code>的<code>tryReleaseShared</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantReadWriteLock.ReadLock#unlock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantReadWriteLock.Sync#tryReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// 当前线程与firstReader相同</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">// 如果不是上一个进入的线程，则从ThreadLocal中查询</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 本次释放后应该会归零，所以从ThreadLocal中删除</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// CAS方式减少一个共享锁的数量，失败的话自旋</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断是否是第一个获取锁的线程，不是的话，再判断是否是上一个获取锁的线程，还不是的话去<code>ThreadLocal</code>中取出<code>HoldCounter</code>对象。<br>然后利用<code>CAS</code>操作，将共享锁的数量减一。如果释放后已共享的锁为<code>0</code>，则返回<code>true</code>，这时AQS就可以调用<code>doReleaseShared</code>去操作阻塞队列唤醒相关线程进行锁竞争了。  </p>
<h3 id="读写锁的降级"><span class="post-title-index">2.2.5. </span><a href="#读写锁的降级" class="headerlink" title="读写锁的降级"></a>读写锁的降级</h3><p>考虑这样一个场景。在某个线程中，首先需要修改一个可能被其他线程修改或读取的数据，但是在这个线程后期还需要使用这个数据。这时根据其他线程的情况可能发生两种情况，如下图的上面两个。  </p>
<p><img src="/2020/12/26/Concurrent-AQS/UsageOfDegradeReadWriteLock.png" alt="UsageOfDegradeReadWriteLock"></p>
<p>为了让其他线程能够尽早访问到被修改的<code>data</code>，本线程在<code>modify</code>之后立刻释放了<code>writelock</code>。但这时，有一个线程过来修改了<code>data</code>，导致本线程在后续使用<code>data</code>时，这个值已经不对了。这就是左上角的流程。<br>那为了避免上面这种情况，如果从头到尾将写锁上锁，一直到本线程<code>use(data)</code>结束再解写锁呢？这时如果有其他线程来仅仅是读<code>data</code>，却也需要被阻塞。这就是右上角的流程。</p>
<p>这时，我们可以利用写锁的降级，将其转换为读锁。也就是“写上锁→修改→读上锁→写释放→使用→读释放”这样的过程。<br>这样，由于在写释放前，因为是同一个线程，是可重入的，所以顺利加上了读锁，从而避免其他线程修改<code>data</code>的值。而在写释放了之后，该锁现在仅仅是读锁的状态，如果有其他线程想要读，那么是可共享的；如果有其他线程想要写，那么就排队等读锁释放之后才能写，这也就是左下角的流程。而由于AQS是准FIFO的，所以如果其他线程先想获取写，再想获取读，那就要等写完成了，才能获取读，这也就是右下角的流程。</p>
<p>参考这样一段<a href="https://github.com/discko/learnconcurrent/blob/master/basicconcurrent/src/main/java/space/wudi/learnconcurrent/basicconcurrent/test06/Main06.java" target="_blank" rel="noopener">代码</a>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.learnconcurrent.basicconcurrent.test06;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> startTime = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        startTime= System.currentTimeMillis();</span><br><span class="line">        ReentrantReadWriteLock rrwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            rrwl.writeLock().lock();</span><br><span class="line">            modify();</span><br><span class="line">            rrwl.readLock().lock(); <span class="comment">// A</span></span><br><span class="line">            System.out.println(<span class="string">"gained read lock and unlocking write lock"</span> + <span class="string">" time elapsed "</span>+(System.currentTimeMillis() - startTime));</span><br><span class="line">            rrwl.writeLock().unlock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"in "</span>+Thread.currentThread().getName() + <span class="string">" time elapsed "</span>+(System.currentTimeMillis() - startTime));</span><br><span class="line">            rrwl.readLock().unlock();   <span class="comment">// A</span></span><br><span class="line">        &#125;, <span class="string">"ReadWriteThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            rrwl.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"in "</span>+Thread.currentThread().getName() + <span class="string">" time elapsed "</span>+(System.currentTimeMillis() - startTime));</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">        &#125;,<span class="string">"ReadThread1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            rrwl.writeLock().lock();</span><br><span class="line">            modify();</span><br><span class="line">            rrwl.writeLock().unlock();</span><br><span class="line">        &#125;, <span class="string">"WriteThread"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            rrwl.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">"in "</span>+Thread.currentThread().getName() + <span class="string">" time elapsed "</span>+(System.currentTimeMillis() - startTime));</span><br><span class="line">            rrwl.readLock().unlock();</span><br><span class="line">        &#125;,<span class="string">"ReadThread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Modified in "</span>+Thread.currentThread().getName() + <span class="string">" time elapsed "</span>+(System.currentTimeMillis() - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>开启了4个线程。<br><code>ReadWriteThread</code>线程会先后执行加写锁→加读锁→释放写锁→释放读锁。在释放写锁与释放读锁之间，sleep一段时间以模仿耗时比较长的业务逻辑。<br><code>ReadThread</code>有两个，分别表现为两个不同的时机下上读锁读取数据。<br><code>WriteThread</code>是通过写锁来修改数据。<br>下面就是上面代码的输出： </p>
<blockquote>
<p>Modified data to 1 in ReadWriteThread time elapsed 49<br>gained read lock and unlocking write lock time elapsed 49<br>read data = 1 in ReadThread1 time elapsed 1050<br>read data = 1 in ReadWriteThread time elapsed 5053<br>Modified data to 2 in WriteThread time elapsed 5053<br>read data = 2 in ReadThread2 time elapsed 5053     </p>
</blockquote>
<p>ReadThread1在writeLock释放后很顺利就获得了读锁。而ReadThread2因为WriteThread先来，所以被其阻塞，直到WriteThread在ReadWriteThread释放读锁从而获得写锁并释放写锁之后，才获得了读锁。</p>
<p>总结而言，锁降级，就是为了在本线程又要写又要读的情况下，提升其他线程的性能。</p>
<h2 id="CountDownLatch"><span class="post-title-index">2.3. </span><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>ReentrantLock是独占的，接下来来看一个共享的锁，<code>CountDownLatch</code>。<br>先看一下<code>CountDownLatch</code>的初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch#CountDownLatch</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync#Sync</span></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#setState</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，CDL直接将输入的<code>count</code>作为形参，构造了<code>sync</code>对象。而Sync的构造函数中，直接调用AQS中的<code>setState</code>将AQS的state设为了<code>count</code>。</p>
<h3 id="CountDownLatch的倒数计数"><span class="post-title-index">2.3.1. </span><a href="#CountDownLatch的倒数计数" class="headerlink" title="CountDownLatch的倒数计数"></a>CountDownLatch的倒数计数</h3><p>我们先看一下CountDownLatch是如何倒数计数的。调用<code>countdownLatch.countDown()</code>之后，直接调用<code>sync</code>的<code>releaseShared(1)</code>，也就是释放一把共享锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch#countDown</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CountDownLatch.Sync#tryReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// 只有当剩余的共享锁数量是0时，才认为释放成功</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么什么情况下认为尝试释放共享锁成功呢？从<code>tryReleaseShared</code>可以看出来，它会自旋尝试将state的数量减1。且只有当剩余的共享锁数量为0时，才认为释放成功。接下来去调用<code>doReleaseShared()</code>去唤醒阻塞的线程。<br>从前面的分析我们知道<code>doReleaseShared()</code>是几乎不会阻塞线程的，所以整个<code>countdown()</code>方法也不会阻塞倒数线程。</p>
<h3 id="CountDownLatch的阻塞等待"><span class="post-title-index">2.3.2. </span><a href="#CountDownLatch的阻塞等待" class="headerlink" title="CountDownLatch的阻塞等待"></a>CountDownLatch的阻塞等待</h3><p>CountDownLatch的上锁指令是<code>await()</code>，里面调用<code>sync.acquireSharedInterruptibly(1)</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch#await()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer#acquireSharedInterruptibly</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以会先落到由·实现的<code>tryAcquireShared</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch.Sync#tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法异常简单。而且逻辑上也不难理解，什么时候state的数量被减到0了，就表示尝试获取锁成功（甚至都不需要记录谁获取了锁，获取了多少锁），然后再调用<code>doAcquireSharedInterruptibly</code>去更新阻塞队列，就ok了。</p>
<h2 id="CyclicBarrier"><span class="post-title-index">2.4. </span><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code>与<code>CountDownLatch</code>有一定的相似性，都有计数和阻塞等待执行的作用。做个不恰当的比喻。<br><code>CountDownLatch</code>可以认为有2个角色，一个是金库管理员组，一个是要去金库取东西的人，而<code>CountDownLatch</code>就是这个金库的门。当要去金库取东西的人到达金库门口后，被阻塞（<code>cdl.await()</code>）挡在金库门前。这时，金库管理员一个个先后解开自己管理的一把锁（<code>cdl.countdown()</code>）然后就自己做自己的事情去了（倒数时不会阻塞线程）。当金库门达到所需的解锁数量时，金库大门打开，要去金库去东西的人结束阻塞，开始执行后续的动作。而且这个门是不可重复使用的，再也不会响应<code>await</code>指令了。<br><code>CyclicBarrier</code>更像高铁站安检前控制人流的那个限流员。人流走到这边就被阻塞了（<code>cb.await()</code>），直到人数达到<code>CyclicBarrier</code>设置的数量，然后放行，并清零计数，进行下一轮阻拦人流和放行。  </p>
<p><code>CyclicBarrier</code>可以接受一个<code>int</code>型的参数，也可以再额外接受一个回调函数作为第二个参数。这个<code>int</code>参数就是被阻塞的数量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier中的关键属性"><span class="post-title-index">2.4.1. </span><a href="#CyclicBarrier中的关键属性" class="headerlink" title="CyclicBarrier中的关键属性"></a>CyclicBarrier中的关键属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个可重入锁，在进入Condition时会被释放</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// trip是绊住的意思。利用Condition实现阻塞和唤醒所有的功能</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">// 记录需要等待的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">// 解除阻塞时的回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">// 用于分代，解除阻塞后换代可以继续阻塞</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"><span class="comment">// 记录当前await的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>这里通过<code>parties</code>记录需要阻塞的总量，用<code>count</code>记录次轮已经到达<code>await</code>的数量。<br>利用<code>lock</code>去生成<code>trip</code>这个<code>Condition</code>，因为Condition是支持signalAll来唤醒所有被阻塞（等待）的线程的。<br>利用<code>generation</code>来区分不同的代，每一批一起等待的呗认为是一代，当一起阻塞的呗唤醒后，会切换成下一代。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒所有</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 恢复等待计数</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 切换代别</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier的实现过程"><span class="post-title-index">2.4.2. </span><a href="#CyclicBarrier的实现过程" class="headerlink" title="CyclicBarrier的实现过程"></a>CyclicBarrier的实现过程</h3><p>当调用<code>cb.await()</code>时，其值执行的是<code>CyclicBarrier.dowait()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.CyclicBarrier#await</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);   <span class="comment">// false 为不需要定时，0L在定时时表示最长await的时长</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// 非定时情况下，不可能执行到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    </span><br><span class="line">    <span class="comment">// 同一时刻只有一个线程可以执行下面的</span></span><br><span class="line">    <span class="comment">// 比如初始化为5，目前有4个阻塞。这时来了2个线程await</span></span><br><span class="line">    <span class="comment">// 那么只能有一个线程执行下面的程序，并被唤醒</span></span><br><span class="line">    <span class="comment">// 另一个线程将作为下一批中的线程，先阻塞着</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录当前代别</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 响应中断</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = --count;    <span class="comment">// count用于记录此代await的数量</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 此代等待数量已满，可以执行回调</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 切换代别，并唤醒所有</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 循环直到达到终止条件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">// 针对没有定时的情况</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">// 针对定时的情况，nanos表示此次await后还剩余的时间</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 苏醒了，但是发现没有换代，说明是本线程被打断了</span></span><br><span class="line">                    <span class="comment">// 标记barrier为broken，然后唤醒所有同cb的线程</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="comment">// 当trip被唤醒或者定时时间到</span></span><br><span class="line">                <span class="comment">// 如果代别发生了变化，则返回</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 定时了，且定时时间到，</span></span><br><span class="line">                <span class="comment">// 则抛出TimeoutException异常</span></span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于一个线程可以使用多个CyclicBarrier，而任何一个CycliBarrier中的condition.await()都可能被诸如Thread.interrupt()中断而唤醒。如果唤醒后，发现还没有换代的话，那么就会通过breakBarrier方法，唤醒所有的等待线程。<br>可以看一下breakBarrier的实现，可以发现，只要有一个线程执行了breakBarrier，那么所有等待线程都会被唤醒：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CyclicBarrier流程总结"><span class="post-title-index">2.4.3. </span><a href="#CyclicBarrier流程总结" class="headerlink" title="CyclicBarrier流程总结"></a>CyclicBarrier流程总结</h3><p>当预定数量的线程执行到await之后，这些线程将直接被一起唤醒，停止阻塞。<br>当某个线程被<code>Thread.interrupt()</code>打断后，该线程被唤醒，并抛出<code>InterruptException</code>，其他阻塞的线程也会被唤醒，并抛出<code>BrokenBarrierException</code>。<br>当某个线程通过<code>await(time, unit)</code>进行阻塞，时间结束仍然没有凑满预定数量的线程，则这个线程被唤醒，并抛出<code>TimeoutException</code>；其他阻塞的线程也会被唤醒，并抛出<code>BrokenBarrierException</code>。  </p>
<h2 id="Semaphore-信号量"><span class="post-title-index">2.5. </span><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>最后来看<code>Semaphore</code>信号量。这个就简单很多了。<br><code>Semaphore</code>的官方解释是这样的：</p>
<blockquote>
<p>A counting semaphore.  Conceptually, a semaphore maintains a set of permits.  Each {@link #acquire} blocks if necessary until a permit is available, and then takes it.  Each {@link #release} adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the {@code Semaphore} just keeps a count of the number available and acts accordingly.  </p>
</blockquote>
<p>大致翻译一下：</p>
<blockquote>
<p>这是一个计数信号量。从概念上来说，semaphore维护着一组许可证。每一次acquire都可能阻塞线程直到获得一个许可证；每一次release都会添加一个许可证，并且顺便在需要的情况下释放一个被阻塞的线程。然而，在semaphore中没有真正的许可证对象，semaphore仅仅计数可用许可证的数量。  </p>
</blockquote>
<p>所以对于semaphore而言，最主要的就是<code>acquire</code>和<code>release</code>两个方法。对于<code>acquireInterruptibly</code>在流程上是基本相似的，就不去介绍了。  </p>
<p><code>acquire</code>和<code>release</code>都有无参和接受一个<code>int</code>作为参数的两个版本。这个int参数表示需要获取或者释放（后面会说到，其实<code>release</code>翻译为“添加”其实跟合理）的许可证的数量。  </p>
<h3 id="获取许可证"><span class="post-title-index">2.5.1. </span><a href="#获取许可证" class="headerlink" title="获取许可证"></a>获取许可证</h3><p><code>acquire</code>方法调用<code>sync.acquireSharedInterruptibly</code>，进入AQS后，先调用<code>tryAcquireShared</code>，如果失败的话则调用<code>doAcquireShared</code>将其加入阻塞队列。重新回到<code>Semaphore</code>的<code>Sync</code>中，<code>Semaphore.Sync</code>有两个老生常谈的实现，分别是<code>FairSync</code>和<code>UnfairSync</code>，所以也就对应着2个<code>tryAcquireShared</code>的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Semaphore.FairSync#tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="comment">// 如果阻塞队列中已经存在正在等待的，则返回失败</span></span><br><span class="line">            <span class="comment">// 接下来去调用doAcquireShared方法</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="comment">// 如果本次获取后剩余的许可证小于0，则直接返回</span></span><br><span class="line">            <span class="comment">// 或者剩余许可证数量不少于0，则CAS直到成功</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Semaphore.NonfairSync#tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Semaphore.Sync#nonfairTryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 不需要去判断队列中是否存在，先抢一波</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>逻辑上和<code>ReentrantLock</code>的公平锁与非公平锁非常相似，甚至比<code>ReentrantLock</code>还要简单，因为这个是共享的，不需要去判断独占性。  </p>
<h3 id="增加许可证"><span class="post-title-index">2.5.2. </span><a href="#增加许可证" class="headerlink" title="增加许可证"></a>增加许可证</h3><p>释放许可证也很简单，<code>relase</code>方法调用<code>sync.releaseShared</code>，进入AQS后，先调用<code>tryReleaseShared</code>，如果成功则继续调用<code>doReleaseShared</code>去处理阻塞队列。<code>tryReleaseShared</code>的实现也很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Semaphore.Sync#tryReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) </span><br><span class="line">            <span class="comment">// 如果释放许可证之后，许可证反而变小了</span></span><br><span class="line">            <span class="comment">// 要么是超过Integer.MAX_VALUE后溢出了</span></span><br><span class="line">            <span class="comment">// 要么releases是负的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next)) <span class="comment">// 失败就自旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这里来看，<code>tryReleaseShared</code>仅仅只做<code>next&lt;current</code>这一个判断，用来保证没有溢出（或者释放了负数个许可证），所以释放后的许可证数量是可以超过初始化时许可证的数量的。所以“释放”这个词就不太合适了，使用“增加”更合适一些。  </p>
<h3 id="一些其他方法"><span class="post-title-index">2.5.3. </span><a href="#一些其他方法" class="headerlink" title="一些其他方法"></a>一些其他方法</h3><p>除了<code>acquire</code>和<code>release</code>之外，还有一个比较有意思的方法：<code>drainPermits</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从逻辑上来看，将剩余的许可证数量返回，并将剩余许可证数量归零。可能在某些情况下会使用吧。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/15/Concurrent-InProcessConcurrent/" rel="prev" title="多线程与高并发-进程内高并发">
      <i class="fa fa-chevron-left"></i> 多线程与高并发-进程内高并发
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS的基本构造"><span class="nav-text">1. AQS的基本构造</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构"><span class="nav-text">1.1. 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-text">1.2. 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法执行顺序"><span class="nav-text">1.3. 方法执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具体源码分析"><span class="nav-text">1.4. 具体源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上锁入口"><span class="nav-text">1.4.1. 上锁入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尝试获取锁失败后"><span class="nav-text">1.4.2. 尝试获取锁失败后</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独占锁尝试获取失败后"><span class="nav-text">1.4.2.1. 独占锁尝试获取失败后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享锁获取失败后"><span class="nav-text">1.4.2.2. 共享锁获取失败后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放锁入口"><span class="nav-text">1.4.3. 释放锁入口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独占锁释放时的操作"><span class="nav-text">1.4.3.1. 独占锁释放时的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享锁释放时的操作"><span class="nav-text">1.4.3.2. 共享锁释放时的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PROPAGATE状态的作用"><span class="nav-text">1.4.3.3. PROPAGATE状态的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition下的等待和通知"><span class="nav-text">1.4.4. Condition下的等待和通知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition的基本结构"><span class="nav-text">1.4.4.1. Condition的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition的阻塞"><span class="nav-text">1.4.4.2. Condition的阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition的释放"><span class="nav-text">1.4.4.3. Condition的释放</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束"><span class="nav-text">1.5. 结束</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#几个常用AQS实现的具体实现方式"><span class="nav-text">2. 几个常用AQS实现的具体实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-可重入锁"><span class="nav-text">2.1. ReentrantLock 可重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#公平与非公平"><span class="nav-text">2.1.1. 公平与非公平</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尝试获取锁"><span class="nav-text">2.1.2. 尝试获取锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尝试释放锁"><span class="nav-text">2.1.3. 尝试释放锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantReadWriteLock-可重入读写锁"><span class="nav-text">2.2. ReentrantReadWriteLock 可重入读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上写锁"><span class="nav-text">2.2.1. 上写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放写锁"><span class="nav-text">2.2.2. 释放写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上读锁"><span class="nav-text">2.2.3. 上读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放读锁"><span class="nav-text">2.2.4. 释放读锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁的降级"><span class="nav-text">2.2.5. 读写锁的降级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-text">2.3. CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch的倒数计数"><span class="nav-text">2.3.1. CountDownLatch的倒数计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch的阻塞等待"><span class="nav-text">2.3.2. CountDownLatch的阻塞等待</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-text">2.4. CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier中的关键属性"><span class="nav-text">2.4.1. CyclicBarrier中的关键属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier的实现过程"><span class="nav-text">2.4.2. CyclicBarrier的实现过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier流程总结"><span class="nav-text">2.4.3. CyclicBarrier流程总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore-信号量"><span class="nav-text">2.5. Semaphore 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取许可证"><span class="nav-text">2.5.1. 获取许可证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加许可证"><span class="nav-text">2.5.2. 增加许可证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些其他方法"><span class="nav-text">2.5.3. 一些其他方法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴迪"
      src="/images/avatar.jpg?raw=true">
  <p class="site-author-name" itemprop="name">吴迪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备17000391号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴迪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      var config = {
        theme:'default',
        logLevel:'fatal',
        securityLevel:'strict',
        startOnLoad:true,
        arrowMarkerAbsolute:false,

        er:{
          diagramPadding:20,
          layoutDirection:'TB',
          minEntityWidth:100,
          minEntityHeight:75,
          entityPadding:15,
          stroke:'gray',
          fill:'honeydew',
          fontSize:12,
          useMaxWidth:true,
        },
        flowchart:{
          diagramPadding:8,
          htmlLabels:true,
          curve:'linear',
        },
        sequence:{
          diagramMarginX:50,
          diagramMarginY:10,
          actorMargin:50,
          width:150,
          height:65,
          boxMargin:10,
          boxTextMargin:5,
          noteMargin:10,
          messageMargin:35,
          messageAlign:'center',
          mirrorActors:true,
          bottomMarginAdj:1,
          useMaxWidth:true,
          rightAngles:false,
          showSequenceNumbers:false,
        },
        gantt:{
          titleTopMargin:25,
          barHeight:20,
          barGap:4,
          topPadding:50,
          leftPadding:75,
          gridLineStartPadding:35,
          fontSize:11,
          fontFamily:'"Open-Sans", "sans-serif"',
          numberSectionStyles:4,
          axisFormat:'%Y-%m-%d',
        }
      };
      mermaid.initialize(config);
    }
  </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
