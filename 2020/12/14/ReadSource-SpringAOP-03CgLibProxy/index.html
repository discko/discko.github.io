<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wudi.space","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前一篇文章主要分析了一下JdkDynamicProxy的调用方法和生成过程。本文将切换到CG Lib的动态代理，来看看有没有什么不一样的地方。">
<meta property="og:type" content="article">
<meta property="og:title" content="阅读源码-SpringAOP-03CgLibProxy">
<meta property="og:url" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/index.html">
<meta property="og:site_name" content="吴迪小站">
<meta property="og:description" content="前一篇文章主要分析了一下JdkDynamicProxy的调用方法和生成过程。本文将切换到CG Lib的动态代理，来看看有没有什么不一样的地方。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/FastClassList.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/WhatInAdvisedSupport.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/DescriptionOfIsStatic.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/EnhancerKeyFields.png">
<meta property="og:image" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/ObjeenesisWorthTrying.png">
<meta property="article:published_time" content="2020-12-14T01:28:32.000Z">
<meta property="article:modified_time" content="2020-12-17T01:52:29.632Z">
<meta property="article:author" content="吴迪">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="AOP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/FastClassList.png">

<link rel="canonical" href="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>阅读源码-SpringAOP-03CgLibProxy | 吴迪小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴迪小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          阅读源码-SpringAOP-03CgLibProxy
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-14 09:28:32" itemprop="dateCreated datePublished" datetime="2020-12-14T09:28:32+08:00">2020-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-17 09:52:29" itemprop="dateModified" datetime="2020-12-17T09:52:29+08:00">2020-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">阅读源码</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/">前一篇文章</a>主要分析了一下JdkDynamicProxy的调用方法和生成过程。本文将切换到CG Lib的动态代理，来看看有没有什么不一样的地方。<br><a id="more"></a></p>
<h1 id="自己写一个代理（通过继承）"><span class="post-title-index">1. </span><a href="#自己写一个代理（通过继承）" class="headerlink" title="自己写一个代理（通过继承）"></a>自己写一个代理（通过继承）</h1><p>前一篇文章使用Jdk Dynamic Proxy，其核心是获取目标对象的接口，然后根据这些接口，实现所有接口中的方法，并在这些方法中调用目标对象的同名方法，并在调用前后做一些处理。由于使用了InvocationHandler，所以其核心是通过反射来执行原被代理的目标对象的方法。代理对象和目标对象两者是平级的，都是某个或某些接口的实现。<br>在较早版本的java中，运行时的反射效率比较低，而且JdkDynamicProxy只能代理接口中的方法，所以CgLib换成了另外一个思路。<br>除了使用接口来获得某个对象的方法外，还可以使用继承。CgLib就是这样，创建一个新的类，并继承自目标对象。然后覆盖目标方法，在其中调用父对象（也就是目标对象类）的同名方法，并在前后增加一些切面处理。大概就是下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="comment">// package space.wudi.readsourceaop.cglibproxy.codemyself</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"in target method"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">extends</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before target method"</span>);</span><br><span class="line">        <span class="keyword">super</span>.method();</span><br><span class="line">        System.out.println(<span class="string">"after target method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Proxy();</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就完成了代理。<br>最终输出结果如下：</p>
<blockquote>
<p>before target method<br>in target method<br>after target method   </p>
</blockquote>
<h1 id="使用CgLib生成代理并调用"><span class="post-title-index">2. </span><a href="#使用CgLib生成代理并调用" class="headerlink" title="使用CgLib生成代理并调用"></a>使用CgLib生成代理并调用</h1><p>这次为了简单，使用了public static void main去调用CgLib直接生成代理并调用，来看看其执行过程是什么样子的。</p>
<h2 id="编写代码并执行"><span class="post-title-index">2.1. </span><a href="#编写代码并执行" class="headerlink" title="编写代码并执行"></a>编写代码并执行</h2><p>创建一个目标对象<code>TargetObject</code>，为其增加2个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.cglibproxy.createproxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String to)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hi, "</span>+to+<span class="string">"!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">whoAreYou</span><span class="params">(String from)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Hi %s, it's WuDi"</span>, from);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建一个方法拦截器，继承自<code>MethodInterceptor</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.cglibproxy.createproxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    MyMethodInterceptor(String id)&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object sub, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before from "</span>+id);</span><br><span class="line">        Object rtVal = methodProxy.invokeSuper(sub, args);</span><br><span class="line">        System.out.println(<span class="string">"after from "</span>+id+<span class="string">" with rtVal: "</span>+rtVal);</span><br><span class="line">        <span class="keyword">return</span> rtVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.cglibproxy.createproxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.core.DebuggingClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String SAVE_PATH = <span class="string">"/Users/wudi/program/javaworkspace/readsource/readsource-aop/target"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TargetObject <span class="title">createByNormalInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, SAVE_PATH);</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(TargetObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;<span class="keyword">new</span> MyMethodInterceptor(<span class="string">"a"</span>), <span class="keyword">new</span> MyMethodInterceptor(<span class="string">"b"</span>)&#125;);</span><br><span class="line">        <span class="comment">//如果method名字包含"say"则使用callbacks[0]否则使用callbacks[1]</span></span><br><span class="line">        enhancer.setCallbackFilter(method -&gt; method.getName().contains(<span class="string">"say"</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (TargetObject)enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.readsourceaop.cglibproxy.createproxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TargetObject to = ProxyCreator.createByNormalInterceptor();</span><br><span class="line">        to.sayHi(<span class="string">"WuDi"</span>);</span><br><span class="line">        String response = to.whoAreYou(<span class="string">"stranger"</span>);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最终在控制台可以看到如下输入：  </p>
<blockquote>
<p>before from a<br>Hi, WuDi!<br>after from a with rtVal: null<br>before from b<br>after from b with rtVal: Hi stranger, it’s WuDi<br>Hi stranger, it’s WuDi   </p>
</blockquote>
<h2 id="调用过程"><span class="post-title-index">2.2. </span><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h2><p>那么调用过程是怎样的呢？  </p>
<p>可以想见，实际调用的并非<code>TargetObject</code>，而应该是其代理对象。<br>由于上面开启了将CGLib生成的对象输出到文件的选项(<code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, SAVE_PATH);</code>)，所以可以在<code>SAVE_PATH</code>指定的位置根据目标对象的包名找到新生成的3个对象。<br><img src="/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/FastClassList.png" alt="FastClassList"><br>这三个对象分别是：  </p>
<ul>
<li><code>TargetObject$$EnhancerByCGLIB$$5307ad86.class</code>：这个就是CGLib增强后的代理类。</li>
<li><code>TargetObject$$EnhancerByCGLIB$$5307ad86$$FastClassByCGLIB$$a80b111f.class</code>：这个名字超长的是上面那个代理类的辅助索引类，也就是所谓的代理类的FastClass。  </li>
<li><code>TargetObject$$FastClassByCGLIB$$799a8d8d.class</code>：这个是目标类的辅助索引FastClass。<br>这三个文件怎么用呢，我们接下去看。</li>
</ul>
<h3 id="CG代理对象中的调用"><span class="post-title-index">2.2.1. </span><a href="#CG代理对象中的调用" class="headerlink" title="CG代理对象中的调用"></a>CG代理对象中的调用</h3><p>将生成的代理类class文件反编译后，可以看到它继承自<code>TargetObject</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span>$$<span class="title">EnhancerByCGLIB</span>$$5307<span class="title">ad86</span> <span class="keyword">extends</span> <span class="title">TargetObject</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="comment">//xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后是继承的两个方法，由于一个有返回值，一个没有返回值，所以后半部分不太一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用目标对象（也就是父类）的sayHi方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> CGLIB$sayHi$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="keyword">super</span>.sayHi(var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理目标对象（也就是父类）的sayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$sayHi$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$sayHi$<span class="number">0</span>$Proxy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.sayHi(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用目标对象（也就是父类）的whoAreYou方法</span></span><br><span class="line"><span class="keyword">final</span> String CGLIB$whoAreYou$<span class="number">1</span>(String var1) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.whoAreYou(var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理目标对象（也就是父类）的whoAreYou方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> String <span class="title">whoAreYou</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_1;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$whoAreYou$<span class="number">1</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$whoAreYou$<span class="number">1</span>$Proxy) : <span class="keyword">super</span>.whoAreYou(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>两个方法的前半部分都是获取本方法需要使用的方法拦截器，如果获取失败了，就通过懒加载，将callbacks列表绑定到<code>this.CGLIB$CALLBACK_n</code>（这个<code>n</code>应该就是callbacks数组中的序号了，看来在编译时就已经将callback与目标方法一一硬编码配对上了） ，然后调用方法拦截器的<code>intercept()</code>方法就可以了。而这个方法，就是我们在<code>MyMethodInterceptor</code>中实现的那个方法。  </p>
<p>可以看到，<code>intercept(Object sub, Method method, Object[] args, MethodProxy methodProxy)</code>有4个参数：</p>
<ul>
<li>Object sub：增强后的对象（也即代理对象），所以传入了<code>this</code></li>
<li>Method method：需要调用的目标对象中的方法，所以传入了格式类似于<code>CGLIB$目标方法名$方法索引$Method</code>这样的变量，如<code>CGLIB$sayHi$0$Method</code></li>
<li>Object[] args：调用方法的参数，直接将入参传入</li>
<li>MethodProxy methodProxy：一个方法代理器，命名格式大致是<code>CGLIB$目标方法名$方法索引$Proxy</code>，如<code>CGLIB$sayHi$0$Proxy</code>。</li>
</ul>
<p><code>sub</code>和<code>args</code>应该问题不大。我们首先来看看method和proxy是如何绑定的。全局有一个static方法块，里面调用了<code>CGLIB$STATICHOOK1()</code>，而这个函数里面对对这个代理对象中的所有奇怪属性进行了初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// var0是代理对象的class</span></span><br><span class="line">        Class var0 = Class.forName(<span class="string">"space.wudi.readsourceaop.cglibproxy.createproxy.TargetObject$$EnhancerByCGLIB$$5307ad86"</span>);</span><br><span class="line">        <span class="comment">// var1是目标对象的class，在初始化Method[] var10000时定义</span></span><br><span class="line">        Class var1;</span><br><span class="line">        <span class="comment">// 获取sayHi和whoAreYou等自定义方法</span></span><br><span class="line">        Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"sayHi"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"whoAreYou"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>&#125;, (var1 = Class.forName(<span class="string">"space.wudi.readsourceaop.cglibproxy.createproxy.TargetObject"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$sayHi$<span class="number">0</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">        CGLIB$sayHi$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"sayHi"</span>, <span class="string">"CGLIB$sayHi$0"</span>);</span><br><span class="line">        CGLIB$whoAreYou$<span class="number">1</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">        CGLIB$whoAreYou$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>, <span class="string">"whoAreYou"</span>, <span class="string">"CGLIB$whoAreYou$1"</span>);</span><br><span class="line">        <span class="comment">// 获取equals、toString、hashCode、clone这4个自带的方法</span></span><br><span class="line">        var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"hashCode"</span>, <span class="string">"()I"</span>, <span class="string">"clone"</span>, <span class="string">"()Ljava/lang/Object;"</span>&#125;, (var1 = Class.forName(<span class="string">"java.lang.Object"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"equals"</span>, <span class="string">"CGLIB$equals$2"</span>);</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"toString"</span>, <span class="string">"CGLIB$toString$3"</span>);</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Method = var10000[<span class="number">2</span>];</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"()I"</span>, <span class="string">"hashCode"</span>, <span class="string">"CGLIB$hashCode$4"</span>);</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Method = var10000[<span class="number">3</span>];</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"()Ljava/lang/Object;"</span>, <span class="string">"clone"</span>, <span class="string">"CGLIB$clone$5"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="目标对象的Method对象的生成"><span class="post-title-index">2.2.1.1. </span><a href="#目标对象的Method对象的生成" class="headerlink" title="目标对象的Method对象的生成"></a>目标对象的Method对象的生成</h4><p>从这里面看到，method是通过<code>ReflectUtils.findMethods()</code>来获取的，而proxy是通过<code>MethodProxy.create()</code>来生成的。<br>先看看method：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.core.ReflectUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Method[] findMethods(String[] namesAndDescriptors, Method[] methods) &#123;</span><br><span class="line">		Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">			Method method = methods[i];</span><br><span class="line">			map.put(method.getName() + Type.getMethodDescriptor(method), method);</span><br><span class="line">		&#125;</span><br><span class="line">		Method[] result = <span class="keyword">new</span> Method[namesAndDescriptors.length / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">			result[i] = (Method) map.get(namesAndDescriptors[i * <span class="number">2</span>] + namesAndDescriptors[i * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (result[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> error?</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>初看比较费解，这不是什么事情都没有干么，就将入参method返回出去。仔细一想，应该是在目标类中可能存在不需要代理的方法，传入的String[]中描述了所有需要代理的方法，通过这种方式过滤一遍，只将需要方法的组成数组再传出去。  </p>
<h4 id="方法代理MethodProxy的生成"><span class="post-title-index">2.2.1.2. </span><a href="#方法代理MethodProxy的生成" class="headerlink" title="方法代理MethodProxy的生成"></a>方法代理MethodProxy的生成</h4><p>然后再看MethodProxy。<code>MethodProxy.create()</code>以及MethodProxy中的一个内部类CreateInfo在这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.proxy.MethodProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c1对应于var1，也就是目标类；c2对应于var0，也就是代理类</span></span><br><span class="line">    MethodProxy proxy = <span class="keyword">new</span> MethodProxy();</span><br><span class="line">    proxy.sig1 = <span class="keyword">new</span> Signature(name1, desc);</span><br><span class="line">    proxy.sig2 = <span class="keyword">new</span> Signature(name2, desc);</span><br><span class="line">    proxy.createInfo = <span class="keyword">new</span> CreateInfo(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateInfo</span> </span>&#123;</span><br><span class="line">    Class c1;</span><br><span class="line">    Class c2;</span><br><span class="line">    NamingPolicy namingPolicy;</span><br><span class="line">    GeneratorStrategy strategy;</span><br><span class="line">    <span class="keyword">boolean</span> attemptLoad;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateInfo</span><span class="params">(Class c1, Class c2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c1 = c1;</span><br><span class="line">        <span class="keyword">this</span>.c2 = c2;</span><br><span class="line">        AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();</span><br><span class="line">        <span class="keyword">if</span> (fromEnhancer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            namingPolicy = fromEnhancer.getNamingPolicy();</span><br><span class="line">            strategy = fromEnhancer.getStrategy();</span><br><span class="line">            attemptLoad = fromEnhancer.getAttemptLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以全局变量createInfo中的c1就是目标类的class，c2就是代理类的class。而MethodProxy的sig1就是用于代理父类目标方法的方法签名（比如上面代理类中的sayHi，sig2就是实际可以调用父类目标方法的方法签名（比如上面代理类中的CGLIB$sayHi$0）。<br>换句话说，1就是目标类相关的，2就是代理类相关的。</p>
<h3 id="使用MethodProxy"><span class="post-title-index">2.2.2. </span><a href="#使用MethodProxy" class="headerlink" title="使用MethodProxy"></a>使用MethodProxy</h3><p>method和methodProxy都生成之后，传入intercept()方法就可以调用了。接下来<br>来看看方法代理器MethodProxy是如何工作的。我</p>
<h4 id="生成FastClassInfo并获取对应方法的索引"><span class="post-title-index">2.2.2.1. </span><a href="#生成FastClassInfo并获取对应方法的索引" class="headerlink" title="生成FastClassInfo并获取对应方法的索引"></a>生成FastClassInfo并获取对应方法的索引</h4><p>将相关的代码都贴在下面。可以看出来，这里调用init()，然后获取FastClassInfo，最后利用FastClassInfo去调用。流程很清晰，具体是怎么做的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.proxy.MethodProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        FastClassInfo fci = fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (initLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                CreateInfo ci = createInfo;</span><br><span class="line">                FastClassInfo fci = <span class="keyword">new</span> FastClassInfo();</span><br><span class="line">                fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                fci.i1 = fci.f1.getIndex(sig1);</span><br><span class="line">                fci.i2 = fci.f2.getIndex(sig2);</span><br><span class="line">                fastClassInfo = fci;</span><br><span class="line">                createInfo = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FastClass <span class="title">helper</span><span class="params">(CreateInfo ci, Class type)</span> </span>&#123;</span><br><span class="line">    FastClass.Generator g = <span class="keyword">new</span> FastClass.Generator();</span><br><span class="line">    g.setType(type);</span><br><span class="line">    <span class="comment">// SPRING PATCH BEGIN</span></span><br><span class="line">    g.setContextClass(type);</span><br><span class="line">    <span class="comment">// SPRING PATCH END</span></span><br><span class="line">    g.setClassLoader(ci.c2.getClassLoader());</span><br><span class="line">    g.setNamingPolicy(ci.namingPolicy);</span><br><span class="line">    g.setStrategy(ci.strategy);</span><br><span class="line">    g.setAttemptLoad(ci.attemptLoad);</span><br><span class="line">    <span class="keyword">return</span> g.create();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span> </span>&#123;</span><br><span class="line">    FastClass f1;</span><br><span class="line">    FastClass f2;</span><br><span class="line">    <span class="keyword">int</span> i1;</span><br><span class="line">    <span class="keyword">int</span> i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先调用<code>init()</code>，对全局变量<code>fastClassInfo</code>初始化。<code>fastClassInfo</code>来自于MethodProxy对象中的createInfo对象。可以看到FastClassInfo中也存在两组<code>f</code>和<code>i</code>，是与createInfo中的<code>c</code>一一对应的，1表示目标对象中的，2表示代理对象中的。利用<code>helper()</code>将create中的两个<code>c</code>，生成对应的FastClass，从而得到2个<code>f</code>。然后调用这两个<code>fastClass中的getIndex()</code>，为<code>i</code>赋值。那么可以猜想，<code>i</code>表示的应该就是<code>index</code>也就是索引了。<br><code>getIndex</code>怎么做的呢，那就需要利用上面生成的3个class的后两个来看了。<br>首先是目标对象的<code>getIndex()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class file: TargetObject$$FastClassByCGLIB$$799a8d8d.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Signature var1)</span> </span>&#123;</span><br><span class="line">    String var10000 = var1.toString();</span><br><span class="line">    <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1119198413</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"sayHi(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">256920502</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"whoAreYou(Ljava/lang/String;)Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，通过<code>createInfo</code>中生成的<code>Signature</code>，将其<code>toString()</code>之后的字符串对象的<code>hashcode</code>，硬编码成了对应的<code>index</code>。<br>那么同理，在代理对象中也是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class file: TargetObject$$EnhancerByCGLIB$$5307ad86$$FastClassByCGLIB$$a80b111f.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Signature var1)</span> </span>&#123;</span><br><span class="line">    String var10000 = var1.toString();</span><br><span class="line">    <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1870561232</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$findMethodProxy(Lorg/springframework/cglib/core/Signature;)Lorg/springframework/cglib/proxy/MethodProxy;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1745842178</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"setCallbacks([Lorg/springframework/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1641413109</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"newInstance([Lorg/springframework/cglib/proxy/Callback;)Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1457535688</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$STATICHOOK1()V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1411812934</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$hashCode$4()I"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1119198413</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"sayHi(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1034266769</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$SET_STATIC_CALLBACKS([Lorg/springframework/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">1025895669</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$SET_THREAD_CALLBACKS([Lorg/springframework/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">988317324</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"newInstance([Ljava/lang/Class;[Ljava/lang/Object;[Lorg/springframework/cglib/proxy/Callback;)Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">508378822</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"clone()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">385262742</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$sayHi$0(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -<span class="number">256920502</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"whoAreYou(Ljava/lang/String;)Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">374345669</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$equals$2(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">610042816</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"newInstance(Lorg/springframework/cglib/proxy/Callback;)Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1132856532</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"getCallbacks()[Lorg/springframework/cglib/proxy/Callback;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1246779367</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"setCallback(ILorg/springframework/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1364367423</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"getCallback(I)Lorg/springframework/cglib/proxy/Callback;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1388004980</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$whoAreYou$1(Ljava/lang/String;)Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1517819849</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$toString$3()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2011844968</span>:</span><br><span class="line">        <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$clone$5()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（太tm长了）可以看到，里面不但有代理方法和调用父类的方法，还有其他的各种奇奇怪怪但确实在代理类中存在的方法。  </p>
<h3 id="通过索引调用方法"><span class="post-title-index">2.2.3. </span><a href="#通过索引调用方法" class="headerlink" title="通过索引调用方法"></a>通过索引调用方法</h3><p>接下来就是调用了。<code>fci.f2.invoke(fci.i2, obj, args)</code>。从这里可以看出来，直接通过f2（也就是代理对象的FastClass）去调用目标对象中的索引为i2的那个方法。需要注意的是，这里的obj其实是就是代理类的实例（因为在调用intercept时传入的是this）。这样，查看代理类的FastClass，看看invoke：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in class file: TargetObject$$EnhancerByCGLIB$$5307ad86$$FastClassByCGLIB$$a80b111f.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="comment">// 5307ad86是被反编译识别错误的代理类</span></span><br><span class="line">    <span class="number">5307</span>ad86 var10000 = (<span class="number">5307</span>ad86)var2;</span><br><span class="line">    <span class="keyword">int</span> var10001 = var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(var10001) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.sayHi((String)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.whoAreYou((String)var3[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            var10000.setCallbacks((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="number">5307</span>ad86.CGLIB$STATICHOOK1();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            var10000.CGLIB$sayHi$<span class="number">0</span>((String)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.CGLIB$whoAreYou$<span class="number">1</span>((String)var3[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Boolean(var10000.CGLIB$equals$<span class="number">2</span>(var3[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.CGLIB$toString$<span class="number">3</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(var10000.CGLIB$hashCode$<span class="number">4</span>());</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.CGLIB$clone$<span class="number">5</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5307</span>ad86.CGLIB$findMethodProxy((Signature)var3[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            var10000.setCallback(((Number)var3[<span class="number">0</span>]).intValue(), (Callback)var3[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            <span class="number">5307</span>ad86.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">            <span class="number">5307</span>ad86.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.getCallback(((Number)var3[<span class="number">0</span>]).intValue());</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.getCallbacks();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Boolean(var10000.equals(var3[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.toString();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(var10000.hashCode());</span><br><span class="line">        <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.clone();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.newInstance((Callback)var3[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.newInstance((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">            <span class="keyword">return</span> var10000.newInstance((Class[])var3[<span class="number">0</span>], (Object[])var3[<span class="number">1</span>], (Callback[])var3[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(var4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot find matching method/constructor"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于类名中含有$$<code>符号，被反编译工具认为成了子类，以至于在import的时候因为名字上出现</code>$$$而认为是某个空类的子类，最终认为某个类名叫做<code>5307ad86</code>。所以这个<code>5307ad86</code>可以认为就是代理类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> space.wudi.readsourceaop.cglibproxy.createproxy.TargetObject..EnhancerByCGLIB..<span class="number">5307</span>ad86;</span><br></pre></td></tr></table></figure><br>由于代理类中调用的sayHi()中使用的是<code>CGLIB$sayHi$0$Proxy</code>，而这个MethodProxy是通过<code>CGLIB$sayHi$0$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/String;)V&quot;, &quot;sayHi&quot;, &quot;CGLIB$sayHi$0&quot;);</code>生成的，所以其sig2就是<code>new Signature(&quot;CGLIB$sayHi$0&quot;, &quot;(Ljava/lang/String;)V&quot;)</code>，<code>toString()</code>之后就是<code>&quot;CGLIB$sayHi$0(Ljava/lang/String;)V&quot;)&quot;</code>，通过在代理类的FastClass中通过<code>getIndex()</code>获取到的索引就是<code>4</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> -<span class="number">385262742</span>:</span><br><span class="line">    <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$sayHi$0(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>所以，最后invoke的时候进入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    var10000.CGLIB$sayHi$<span class="number">0</span>((String)var3[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><br>也就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> CGLIB$sayHi$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="keyword">super</span>.sayHi(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>终于千辛万苦调用到了父类的方法。</p>
<h2 id="总结一下"><span class="post-title-index">2.3. </span><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>就是在启动后初始化时通过硬编码的方式，生成代理类的FastClass，其中存放了各个可以调用的方法的索引。<br>在需要调用时，由于调用的是子类覆盖的方法，所以可以可以执行一些自定义的代理（也就是callback），然后通过MethodProxy，利用其中存放的方法索引，快速找到父类被覆盖方法，并通过super去调用。</p>
<p>这样一来，调用时就不会通过反射了，某种程度上增快了速度。<br>不过jdk7之后对反射进行了优化，实际测试下来，jdkDynamic的速度反而要快一点，特别是调用次数很多的情况下，更为明显。</p>
<pre class="mermaid">graph TB;
A((启动))--"CGLib初始化"-->B["硬编码生成代理类和FastClass"]
B-."调用代理".->C[访问子类方法]
C-->D[执行callback]
D--"查询方法索引"-->E[执行父类方法]
E-->F[返回]</pre>


<h1 id="CGLib在Spring中创建代理的过程"><span class="post-title-index">3. </span><a href="#CGLib在Spring中创建代理的过程" class="headerlink" title="CGLib在Spring中创建代理的过程"></a>CGLib在Spring中创建代理的过程</h1><h2 id="创建开始的地方"><span class="post-title-index">3.1. </span><a href="#创建开始的地方" class="headerlink" title="创建开始的地方"></a>创建开始的地方</h2><p>前面是通过CGLib创建了一个代理，用来对自己编写的简单类进行代理。如果是在Spring框架中，会怎么做呢？<br>我们在<a href="(/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/">前一篇文章</a>)中已经介绍了切面和责任链是是如何初始化，这在CGLib中是一样的，从前面的AOP注册，一直到这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.DefaultAopProxyFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IN_NATIVE_IMAGE &amp;&amp;</span><br><span class="line">            (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当<code>target</code>没有接口，或者是Proxy的实现（且已经在<code>ProxyCache</code>中），就用<code>ObjenesisCglibAopProxy</code>来初始化。（然后调用其<code>getProxy()</code>方法就能获得动态代理对象了）。<br>从Spring 4开始，<code>ObjenesisCglibAopProxy</code>就是默认的CgLib动态代理对象的生成器。它与原本的<code>CglibAopProxy</code>没有很大的区别，主要就是不会代理构造方法。<br>下面就是<code>ObjenesisCglibAopProxy</code>类的注释</p>
<blockquote>
<p>Objenesis-based extension of {@link CglibAopProxy} to create proxy instances without invoking the constructor of the class. Used by default as of Spring 4.</p>
</blockquote>
<p>那我们就跟着调试工具继续往下看。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.ObjenesisCglibAopProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjenesisCglibAopProxy</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用父类也就是<code>CglibAopProxy</code>的同名构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CglibAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.getAdvisorCount() == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.advised = config;</span><br><span class="line">    <span class="keyword">this</span>.advisedDispatcher = <span class="keyword">new</span> AdvisedDispatcher(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们先回顾一下AdvisedSupport里有些什么。从下面的图里可以看到，最主要的是2个，一个是目标对象的引用，还有一个是advisor链。<br><img src="/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/WhatInAdvisedSupport.png" alt="WhatInAdvisedSupport"><br><code>CgLibProxy</code>初始化之后，一路返回至<code>org.springframework.aop.framework.ProxyFactory</code>调用生成的<code>ObjenesisCglibAopProxy</code>的<code>getProxy()</code>方法。在这里面会经过以下几步，并最终生成代理对象：<br>验证目标对象合法性→生成Enhancer→生成callbacks列表→创建代理实例。</p>
<h3 id="验证目标对象合法性"><span class="post-title-index">3.1.1. </span><a href="#验证目标对象合法性" class="headerlink" title="验证目标对象合法性"></a>验证目标对象合法性</h3><p>通过<code>validateClassIfNecessary(proxySuperClass, classLoader);</code>指令，调用后进入到这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doValidateClass</span><span class="params">(Class&lt;?&gt; proxySuperClass, @Nullable ClassLoader proxyClassLoader, Set&lt;Class&lt;?&gt;&gt; ifcs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proxySuperClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        Method[] methods = proxySuperClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = method.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isStatic(mod) &amp;&amp; !Modifier.isPrivate(mod)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Modifier.isFinal(mod)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; implementsInterface(method, ifcs)) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Unable to proxy interface-implementing method ["</span> + method + <span class="string">"] because it is marked as final: Consider using interface-based JDK proxies instead!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Final method ["</span> + method + <span class="string">"] cannot get proxied via CGLIB: "</span> +</span><br><span class="line">                                <span class="string">"Calls to this method will NOT be routed to the target instance and "</span> +</span><br><span class="line">                                <span class="string">"might lead to NPEs against uninitialized fields in the proxy instance."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !Modifier.isPublic(mod) &amp;&amp; !Modifier.isProtected(mod) &amp;&amp; proxyClassLoader != <span class="keyword">null</span> &amp;&amp; proxySuperClass.getClassLoader() != proxyClassLoader) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Method ["</span> + method + <span class="string">"] is package-visible across different ClassLoaders and cannot get proxied via CGLIB: Declare this method as public or protected if you need to support invocations through the proxy."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doValidateClass(proxySuperClass.getSuperclass(), proxyClassLoader, ifcs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里主要就是用来先行验证被代理的类和方法的可继承性和可访问性。  </p>
<h3 id="生成Enhancer"><span class="post-title-index">3.1.2. </span><a href="#生成Enhancer" class="headerlink" title="生成Enhancer"></a>生成Enhancer</h3><p>前面我们自己已经自己创建过Enhancer对象了，这里是大同小异的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">                ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));</span><br></pre></td></tr></table></figure><br>唯一需要关注一下的，就是多了一个<code>SmartClassLoader</code>的判断。这是Spring中的一个接口，如果<code>SmartClassLoader.isClassReloadable() == true</code>，就认为该类是可以reload的，那么就不需要将生成的代理对象缓存下来了。<br>然后将目标类作为superclass传入enhancer，然后再将目标类的接口列表合并上SpringAOP必须要带上的<code>org.springframework.aop.SpringProxy</code>、<code>org.springframework.aop.framework.Advised</code>两个接口。不过如果开启了<code>spring.aop.proxy-target-class=false</code>的话，目标类有接口的应该都被JdkDynamicProxy代理掉了，这里可能就只有Spring自带的2个接口了。<br>接下来传入命名规则<code>SpringNamingPolicy.INSTANCE</code>，这是一个Spring的CGLib自建的命名规则，这样在生成名字的时候，就能把原来class名字上的一个tag<code>&quot;ByCGLIB&quot;</code>替换成<code>&quot;BySpringCGLIB&quot;</code>。在<code>SpringNamingPolicy</code>继承的基类<code>DefaultNamingPolicy</code>中还有具体的命名构造规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.core.DefaultNamingPolicy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> STRESS_HASH_CODE = Boolean.getBoolean(<span class="string">"org.springframework.cglib.test.stressHashCodes"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(String prefix, String source, Object key, Predicate names)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prefix = <span class="string">"org.springframework.cglib.empty.Object"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix.startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line">        prefix = <span class="string">"$"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    String base = prefix + <span class="string">"$$"</span> + source.substring(source.lastIndexOf(<span class="number">46</span>) + <span class="number">1</span>) + <span class="keyword">this</span>.getTag() + <span class="string">"$$"</span> + Integer.toHexString(STRESS_HASH_CODE ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">    String attempt = base;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">2</span>; names.evaluate(attempt); attempt = base + <span class="string">"_"</span> + var7++) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attempt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大概的格式就是<code>目标类名$$来源和tag$$hashcode</code>，其中来源就是Enhancer或者FastClass之类的，tag就是上面提到的<code>&quot;ByCGLIB&quot;</code>或者<code>&quot;BySpringCGLIB&quot;</code>。<br>最后传入生成器策略<code>new ClassLoaderAwareGeneratorStrategy(classLoader)</code>，最后通过这个对象，才能生成代理。  </p>
<h3 id="生成callbacks列表"><span class="post-title-index">3.1.3. </span><a href="#生成callbacks列表" class="headerlink" title="生成callbacks列表"></a>生成callbacks列表</h3><p>callbacks列表通过<code>Callback[] callbacks = getCallbacks(rootClass);</code>这个函数来生成。看上去很长，其实不复杂：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 准备参数</span></span><br><span class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line">    <span class="comment">// 创建切面入口MethodInterceptor，用于普通的advisor</span></span><br><span class="line">    Callback aopInterceptor = <span class="keyword">new</span> DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</span><br><span class="line">    <span class="comment">// 创建一个不需要插入advice，但是需要return this的MethodInterceptor</span></span><br><span class="line">    Callback targetInterceptor;</span><br><span class="line">    <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">        <span class="comment">// 需要向内部过程暴露proxy</span></span><br><span class="line">        targetInterceptor = (isStatic ?</span><br><span class="line">                <span class="keyword">new</span> StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">                <span class="keyword">new</span> DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要向内部过程暴露proxy</span></span><br><span class="line">        targetInterceptor = (isStatic ?</span><br><span class="line">                <span class="keyword">new</span> StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">                <span class="keyword">new</span> DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个在不需要插入代码，而且不需要返回this的callback，</span></span><br><span class="line">    <span class="comment">// 其中StaticDispatcher implements Dispathcer</span></span><br><span class="line">    <span class="comment">// 而Dispatcher implements implements Callback</span></span><br><span class="line">    Callback targetDispatcher = (isStatic ?</span><br><span class="line">            <span class="keyword">new</span> StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) : <span class="keyword">new</span> SerializableNoOp());</span><br><span class="line">    <span class="comment">// 组合成Callbacks列表</span></span><br><span class="line">    Callback[] mainCallbacks = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">            aopInterceptor,  <span class="comment">// 0.给切面方法使用的拦截器</span></span><br><span class="line">            targetInterceptor,  <span class="comment">// 1.给需要返回this而没有切面的方法的拦截器</span></span><br><span class="line">            <span class="keyword">new</span> SerializableNoOp(),  <span class="comment">// 2.不会被使用</span></span><br><span class="line">            targetDispatcher,  <span class="comment">// 3.不会返回this也不没有切面的方法的拦截器</span></span><br><span class="line">            <span class="keyword">this</span>.advisedDispatcher, <span class="comment">// 4.可以返回advisedConfig对象的调度器</span></span><br><span class="line">            <span class="keyword">new</span> EqualsInterceptor(<span class="keyword">this</span>.advised),    <span class="comment">// 5.equals拦截器</span></span><br><span class="line">            <span class="keyword">new</span> HashCodeInterceptor(<span class="keyword">this</span>.advised)   <span class="comment">// 6.hashCode拦截器</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Callback[] callbacks;</span><br><span class="line">    <span class="comment">// 如果目标对象是静态的（单例），而且被冻结了</span></span><br><span class="line">    <span class="comment">// (所谓冻结是ProxyConfig中的一个属性，表示这里面的advice不应当被修改)</span></span><br><span class="line">    <span class="keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">        <span class="comment">// 这面的看上去比较复杂，暂时还没有深究</span></span><br><span class="line">        Method[] methods = rootClass.getMethods();</span><br><span class="line">        Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</span><br><span class="line">        <span class="keyword">this</span>.fixedInterceptorMap = CollectionUtils.newHashMap(methods.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; x++) &#123;</span><br><span class="line">            Method method = methods[x];</span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, rootClass);</span><br><span class="line">            fixedCallbacks[x] = <span class="keyword">new</span> FixedChainStaticTargetInterceptor(chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line">            <span class="keyword">this</span>.fixedInterceptorMap.put(method, x);</span><br><span class="line">        &#125;</span><br><span class="line">        callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">        System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</span><br><span class="line">        System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line">        <span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        callbacks = mainCallbacks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这里可以看出来，getCallbacks()生成了一个callbacks列表。从0到6一共有7个元素，我们倒着看。最后2个分别是给<code>equals()</code>方法和<code>hashCode()</code>方法使用的。<br>所谓代理对象的equals，就需要另一个对象也是一种代理对象，它们代理的是同一个对象，而且代理着相同的interface、有相同的advisor。注意Arrays.equals不但要求列表中的元素数量相同、元素彼此相同，而且要求元素顺序相同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.AopProxyUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equalsInProxy</span><span class="params">(AdvisedSupport a, AdvisedSupport b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b ||</span><br><span class="line">            (equalsProxiedInterfaces(a, b) &amp;&amp; equalsAdvisors(a, b) &amp;&amp; a.getTargetSource().equals(b.getTargetSource())));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equalsProxiedInterfaces</span><span class="params">(AdvisedSupport a, AdvisedSupport b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(a.getProxiedInterfaces(), b.getProxiedInterfaces());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equalsAdvisors</span><span class="params">(AdvisedSupport a, AdvisedSupport b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.getAdvisorCount() == b.getAdvisorCount() &amp;&amp; Arrays.equals(a.getAdvisors(), b.getAdvisors());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>hashCode()的代理相对简单，代理对象的<code>hashcode = CglibAopProxy.class.hashCode() * 13 + 目标对象.hashCode()</code>。</p>
<p>第4个<code>this.advisedDispatcher</code>暂时还没悟透，以后再说。<br>第3个<code>targetDispatcher</code>，如果<code>advisedConfig.isStatic()==true</code>就使用<code>StaticDispatcher</code>，如果是<code>false</code>就是用<code>SerializableNoOp</code>。所谓<code>isStatic</code>，文档中是这么说的：<br><img src="/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/DescriptionOfIsStatic.png" alt="DescriptionOfIsStatic"><br>也就是说，只要target不会发生变化，那么就是static的。这里的Target大部分都是单例的（因为bean默认是单例的），所以这里也是static的，就要创建一个<code>StaticDispatcher</code>。如果真的是non-static的，那么就返回一个空接口，什么都不做。而对于<code>StaticDispatcher</code>，源码超简单，也就是把传入的目标对象，保存起来，在需要的时候通过<code>loadObject</code>再取出来。使用这个调度器作为callback，由于不会在其中插入任何代码，所以效率最好，但只应当使用在不需要return this的时候，因为如果使用这个对象来调用return this的话，返回的就是一个没有进过增强的原始目标对象了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDispatcher</span><span class="params">(@Nullable Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来是第1个，targetInterceptor，也就是在需要返回this但是不需要插入其他advisor的情况下使用的方法拦截器。它会根据条件在4种拦截器中实例化。分别是<code>StaticUnadvisedExposedInterceptor</code>、<code>DynamicUnadvisedExposedInterceptor</code>、<code>StaticUnadvisedInterceptor</code>、<code>DynamicUnadvisedInterceptor</code>。<br>看上去很复杂，但看过源码之后会觉得很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数都是讲传入的targetSource保存起来，就不重复了</span></span><br><span class="line"><span class="comment">// StaticUnadvisedExposedInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">        Object retVal = methodProxy.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">        <span class="keyword">return</span> processReturnType(proxy, <span class="keyword">this</span>.target, method, retVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// StaticUnadvisedInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object retVal = methodProxy.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">    <span class="keyword">return</span> processReturnType(proxy, <span class="keyword">this</span>.target, method, retVal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DynamicUnadvisedInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object target = <span class="keyword">this</span>.targetSource.getTarget();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object retVal = methodProxy.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> processReturnType(proxy, target, method, retVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DynamicUnadvisedExposedInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    Object target = <span class="keyword">this</span>.targetSource.getTarget();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">        Object retVal = methodProxy.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> processReturnType(proxy, target, method, retVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对比一下，所谓static的，就是直接使用目标对象<code>target</code>，而dynamic的在使用外<code>target</code>之后，还需要调用<code>this.targetSource.releaseTarget(target);</code>，当然，这在上面<code>isStatic()</code>的注释中也提到了。<br>而expose和non-expose的区别就在于，在调用前后是否需要把proxy这个代理对象缓存到AopContext这个ThreadLocal中，以方便本线程中的其他过程获取该proxy代理对象。<br>最后就是第0个，生成AopInterceptor了，这里虽然是用<code>DynamicAdvisedInterceptor</code>去装载的，但是在其内部实现中，还是会去判断<code>isStatic</code>，再决定需不需要调用<code>releaseTarget(target)</code>方法。其中具体的执行过程，我们后面再说。<br>接下来，如果是static而且被冻结了，就要对callbacks列表进行进一步处理。所谓冻结，是ProxyConfig中的一个属性，表示这里面的advice不应当被修改。通常用于优化过程中。这一部分我还没有深究，所以就不过多探讨了。<br>最终将callbacks列表返回，就完成了<code>getCallbacks()</code>函数了。  </p>
<h3 id="生成callbackfilter"><span class="post-title-index">3.1.4. </span><a href="#生成callbackfilter" class="headerlink" title="生成callbackfilter"></a>生成callbackfilter</h3><p>接下来设置callbackfilter，会生成一个<code>ProxyCallbackFilter</code>对象，该对象的构造需要好3个参数，第一个是将advised复制了一份（但其中的targetSource被设为了空，后两个都是在getCallback时如果是frozen的则对callbacks列表进行修改时创建的，否则一个是EmptyMap，一个是0。<br><code>new ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)</code><br>在前面自己写CgLib代理的例子中，我使用了一个简单的CallbackFilter。<code>enhancer.setCallbackFilter(method -&gt; method.getName().contains(&quot;say&quot;) ? 0 : 1);</code>也就是根据method的名字来指定对应应当使用的callback在callbacks列表中的索引。下面就来看看ProxyCallbackFilter中，是如何将一个个需要代理的方法和callback对应起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy中定义的常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AOP_PROXY = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_TARGET = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_OVERRIDE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_TARGET = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_ADVISED = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_EQUALS = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVOKE_HASHCODE = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy.ProxyCallbackFilter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果方法被final修饰，则使用new SerializableNoOp</span></span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isFinalizeMethod(method)) &#123;</span><br><span class="line">        logger.trace(<span class="string">"Found finalize() method - using NO_OVERRIDE"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_OVERRIDE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前方法所在的类继承或实现自interface Advised，则使用this.advisedDispatcher</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.isOpaque() &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">            method.getDeclaringClass().isAssignableFrom(Advised<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Method is declared on Advised interface: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DISPATCH_ADVISED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用的是equals，则使用new EqualsInterceptor(this.advised)</span></span><br><span class="line">            <span class="keyword">new</span> HashCodeInterceptor(<span class="keyword">this</span>.advised) </span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Found 'equals' method: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INVOKE_EQUALS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果调用的是hashCode，则使用new HashCodeInterceptor(this.advised)</span></span><br><span class="line">    <span class="keyword">if</span> (AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Found 'hashCode' method: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INVOKE_HASHCODE;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; targetClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">    <span class="comment">// 获取前面创建的advice链</span></span><br><span class="line">    List&lt;?&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    <span class="keyword">boolean</span> haveAdvice = !chain.isEmpty();</span><br><span class="line">    <span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">    <span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line">    <span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">    <span class="keyword">if</span> (haveAdvice || !isFrozen) &#123;</span><br><span class="line">        <span class="comment">// 如果存在advice或者没有被冻结</span></span><br><span class="line">        <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// 如果允许暴露Proxy，选择aopInterceptor</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Must expose proxy on advised method: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AOP_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isStatic &amp;&amp; isFrozen &amp;&amp; <span class="keyword">this</span>.fixedInterceptorMap.containsKey(method)) &#123;</span><br><span class="line">            <span class="comment">// 如果在getCallbacks中进入过了isStatic &amp;&amp; isFrozen</span></span><br><span class="line">            <span class="comment">// 那么应该根据这个map和offset去获取callback</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Method has advice and optimizations are enabled: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We know that we are optimizing so we can use the FixedStaticChainInterceptors.</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.fixedInterceptorMap.get(method);</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="keyword">this</span>.fixedInterceptorOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不然的话，就是什么都没做，还是用aopInterceptor去执行</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Unable to apply any optimizations to advised method: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AOP_PROXY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// See if the return type of the method is outside the class hierarchy of the target type.</span></span><br><span class="line">        <span class="comment">// If so we know it never needs to have return type massage and can use a dispatcher.</span></span><br><span class="line">        <span class="comment">// If the proxy is being exposed, then must use the interceptor the correct one is already</span></span><br><span class="line">        <span class="comment">// configured. If the target is not static, then we cannot use a dispatcher because the</span></span><br><span class="line">        <span class="comment">// target needs to be explicitly released after the invocation.</span></span><br><span class="line">        <span class="comment">// 如果执行到这里了，那么应该就是没有advice了。</span></span><br><span class="line">        <span class="comment">// 就在targetInterceptor和targetDispatcher中选择</span></span><br><span class="line">        <span class="keyword">if</span> (exposeProxy || !isStatic) &#123;</span><br><span class="line">            <span class="comment">// 如果需要暴露Proxy或者是非静态的，就选择targetInterceptor</span></span><br><span class="line">            <span class="keyword">return</span> INVOKE_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; returnType.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">            <span class="comment">// 如果返回this，就选择targetInterceptor</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Method return type is assignable from target type and "</span> +</span><br><span class="line">                        <span class="string">"may therefore return 'this' - using INVOKE_TARGET: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INVOKE_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不然的话，就是无返回值，选择targetDispatcher</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Method return type ensures 'this' cannot be returned - "</span> +</span><br><span class="line">                        <span class="string">"using DISPATCH_TARGET: "</span> + method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> DISPATCH_TARGET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="生成代理对象"><span class="post-title-index">3.1.5. </span><a href="#生成代理对象" class="headerlink" title="生成代理对象"></a>生成代理对象</h3><p>调用<code>createProxyClassAndInstance()</code>生成代理类字节码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成代理类字节码</span></span><br><span class="line">    Class&lt;?&gt; proxyClass = enhancer.createClass();</span><br><span class="line">    Object proxyInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (objenesis.isWorthTrying()) &#123;</span><br><span class="line">        <span class="comment">// 如果允许通过objenesis实例化代理对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成代理对象</span></span><br><span class="line">            proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Unable to instantiate proxy using Objenesis, falling back to regular proxy construction"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proxyInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不允许通过objenesis实例化，或者实例化失败，则通过传统方法生成</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;?&gt; ctor = (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> ?</span><br><span class="line">                    proxyClass.getDeclaredConstructor(<span class="keyword">this</span>.constructorArgTypes) :</span><br><span class="line">                    proxyClass.getDeclaredConstructor());</span><br><span class="line">            ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">            proxyInstance = (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> ?</span><br><span class="line">                    ctor.newInstance(<span class="keyword">this</span>.constructorArgs) : ctor.newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unable to instantiate proxy using Objenesis, and regular proxy instantiation via default constructor fails as well"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将callbacks列表放入代理对象中</span></span><br><span class="line">    ((Factory) proxyInstance).setCallbacks(callbacks);</span><br><span class="line">    <span class="keyword">return</span> proxyInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>主流程还是很清楚的，首先创建代理类的字节码，然后利用<code>objenesis.newInstance()</code>生成代理对象，如果实例化失败的话，就调用常规方法通过反射去生成。最后，由于<code>createClass()</code>方法不支持传入<code>callbacks</code>，所以还需要将<code>callbacks</code>设置到代理对象中。<br>接下来分步看一下这几个环节</p>
<h4 id="Enhancer生成代理类字节码"><span class="post-title-index">3.1.5.1. </span><a href="#Enhancer生成代理类字节码" class="headerlink" title="Enhancer生成代理类字节码"></a>Enhancer生成代理类字节码</h4><p>代码调用<code>Objenesis.createClass()</code>方法中的<code>createHelper()</code>。<br>这里面首先会对参数们进行校验，主要是<code>callbacks</code>的数量和<code>callbackfilter</code>。如果<code>callbackfilter</code>没有设置且<code>callbacks</code>数量为1的话，就会自动使用<code>ALL_ZERO</code>这个预设的过滤器，也就是所有方法的访问，<code>callbackfilter</code>都会让代理去访问<code>callbacks[0]</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.proxy.Enhancer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CallbackFilter ALL_ZERO = <span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>接下来利用<code>KEY_FACTORY</code>来生成了一个<code>key</code>。传入的参数很多，看一下最终生成的<code>key</code>是个什么：<br><img src="/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/EnhancerKeyFields.png" alt="EnhancerKeyFields"><br>大致来说，里面存放了目标类的类名、2个额外的接口（SpringProxy和Advised）、callbackFilter的弱引用、callbacks的类型、各个主要方法的签名，以及51个质数组成的数组。<br>然后利用这个<code>key</code>，调用父类也就是<code>org.springframework.cglib.core.AbstractClassGenerator</code>的<code>create</code>方法。从缓存中获取ClassLoaderData后，调用<code>data.get()</code>方法。如果ClassGenerator不允许使用缓存的话，就直接调用自身的<code>generate()</code>方法；如果允许使用缓存的话，就先尝试通过缓存获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.cglib.core.AbstractClassGenerator</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ClassLoader loader = getClassLoader();</span><br><span class="line">    Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">    ClassLoaderData data = cache.get(loader);</span><br><span class="line">    <span class="comment">// blabla</span></span><br><span class="line">    Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.cglib.core.AbstractClassGenerator.ClassLoaderData</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">        <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.cglib.core.internal.LoadingCache</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    KK cacheKey = <span class="keyword">this</span>.keyMapper.apply(key);</span><br><span class="line">    Object v = <span class="keyword">this</span>.map.get(cacheKey);</span><br><span class="line">    <span class="comment">// 如果缓存中的value不为空，而且缓存的对象不是一个正在执行的任务，就返回value，否则就新建FutureTask去生成代理类字节码</span></span><br><span class="line">    <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; !(v <span class="keyword">instanceof</span> FutureTask) ? v : <span class="keyword">this</span>.createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在最后，对map中取出的缓存进行判断，如果<code>v!=null</code>（v不为空）且<code>!(v instanceof FutureTask)</code>（v不是一个任务），那么就返回v；否则就调用<code>this.createEntry()</code>方法。<br>那么来看看最终调用的<code>createEntry()</code>方法，估计这里就是生成代理类字节码的地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.core.internal.LoadingCache</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> V <span class="title">createEntry</span><span class="params">(<span class="keyword">final</span> K key, KK cacheKey, Object v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> creator = <span class="keyword">false</span>;</span><br><span class="line">    FutureTask task;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 防止task还在执行过程中，就再次调用createEntry()造成重复</span></span><br><span class="line">        task = (FutureTask)v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Callable&lt;V&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 这个key也就是data.get(this)处的this</span></span><br><span class="line">                <span class="comment">// 也即是我们创建的那个Enhancer（继承自AbstractClassGenerator）</span></span><br><span class="line">                <span class="keyword">return</span> LoadingCache.<span class="keyword">this</span>.loader.apply(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// task初始化完成后，就将task放入map中，如果发生了覆盖，resuilt就是被替换掉的旧值</span></span><br><span class="line">        result = <span class="keyword">this</span>.map.putIfAbsent(cacheKey, task);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            creator = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 启动futureTask</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(result <span class="keyword">instanceof</span> FutureTask)) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            task = (FutureTask)result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待任务执行</span></span><br><span class="line">        result = task.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Interrupted while loading cache item"</span>, var9);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException var10) &#123;</span><br><span class="line">        Throwable cause = var10.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException)cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load cache item"</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (creator) &#123;</span><br><span class="line">        <span class="comment">// 将任务执行结果放入map中缓存起来</span></span><br><span class="line">        <span class="keyword">this</span>.map.put(cacheKey, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>流程上看起来就是启动一个异步线程执行<code>LoadingCache.this.loader.apply(key)</code>，待完成后，获取其执行结果，并放入map中缓存起来。那么这个<code>loader.apply</code>是哪儿来的呢？<br>往上看28行，可以看到<code>LoadingCache</code>的构造方法，loader是传进来的。继续往前回溯，可以看到<code>LoadingCache</code>的构造被调用的地方，回到了<code>AbstractClassGenerator</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.core.internal.LoadingCache</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadingCache</span><span class="params">(Function&lt;K, KK&gt; keyMapper, Function&lt;K, V&gt; loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.keyMapper = keyMapper;</span><br><span class="line">    <span class="keyword">this</span>.loader = loader;</span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.cglib.core.AbstractClassGenerator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderData</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"classLoader == null is not yet supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.classLoader = <span class="keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);</span><br><span class="line">    Function&lt;AbstractClassGenerator, Object&gt; load =</span><br><span class="line">            <span class="keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(AbstractClassGenerator gen)</span> </span>&#123;</span><br><span class="line">                    Class klass = gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> gen.wrapCachedClass(klass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    generatedClasses = <span class="keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到<code>FutureTask</code>中执行的那个<code>loader</code>就是这里的<code>load</code>。代理类就是在这里调用<code>gen.generate</code>创建的。由于我们的gen是一个Enhancer，所以会首先进入<code>Enhancer.generater</code>，然后设置好类名前缀后，进入父类<code>AbstractClassGenerator.generater</code>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.cglib.proxy.Enhancer</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">generate</span><span class="params">(ClassLoaderData data)</span> </span>&#123;</span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (superclass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        setNamePrefix(superclass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interfaces != <span class="keyword">null</span>) &#123;</span><br><span class="line">        setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.generate(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">generate</span><span class="params">(ClassLoaderData data)</span> </span>&#123;</span><br><span class="line">    Class gen;</span><br><span class="line">    <span class="comment">// 如果本线程中有的话，就取出来，最后再放回去</span></span><br><span class="line">    Object save = CURRENT.get();</span><br><span class="line">    <span class="comment">// 将当前classGenerator放入当前线程的ThreadLocal中</span></span><br><span class="line">    CURRENT.set(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader classLoader = data.getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ClassLoader is null while trying to define class "</span> + getClassName() + <span class="string">". It seems that the loader has been expired from a weak reference somehow. Please file an issue at cglib's issue tracker."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (classLoader) &#123;</span><br><span class="line">            <span class="comment">// 同步下生成新类的名字，并占用下来</span></span><br><span class="line">            String name = generateClassName(data.getUniqueNamePredicate());</span><br><span class="line">            data.reserveName(name);</span><br><span class="line">            <span class="keyword">this</span>.setClassName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (attemptLoad) &#123;</span><br><span class="line">            <span class="comment">// 尝试加载，由于是新类还没有生成，肯定不可能加载成功，所以目前而言attempLoad必为false</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                gen = classLoader.loadClass(getClassName());</span><br><span class="line">                <span class="keyword">return</span> gen;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用策略生成字节码，存放在byte数组中</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = strategy.generate(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 从字节码中获取类名</span></span><br><span class="line">        String className = ClassNameReader.getClassName(<span class="keyword">new</span> ClassReader(b));</span><br><span class="line">        ProtectionDomain protectionDomain = getProtectionDomain();</span><br><span class="line">        <span class="keyword">synchronized</span> (classLoader) &#123; </span><br><span class="line">            <span class="comment">// 为了以防万一，还是采用同步方式将字节码加入jvm</span></span><br><span class="line">            gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain, contextClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        CURRENT.set(save);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>流程不复杂，获取类加载器，同步生成类名，利用策略strategy生成字节码数组，将字节码数组加载到jvm中（为了以防万一，也采用同步方式）并获得Class对象，返回新生成的Class对象。<br>这里的策略strategy是在enhancer初始化时设置的，还记得么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy#getProxy</span></span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareGeneratorStrategy(classLoader));</span><br></pre></td></tr></table></figure><br>所以这里的策略器是<code>org.springframework.cglib.core.ClassLoaderAwareGeneratorStrategy</code>，最后导航回Enhancer中，调用<code>org.springframework.cglib.proxy.Enhancer.generateClass()</code>方法生成字节码。<br>生成字节码的过程就不去细看了。跳过~</p>
<h4 id="实例化代理对象"><span class="post-title-index">3.1.5.2. </span><a href="#实例化代理对象" class="headerlink" title="实例化代理对象"></a>实例化代理对象</h4><p>字节码生成后，就可以实例化代理对象了。这里有一个<code>objenesis.isWorthTrying()</code>，下面是其说明，大致翻译一下就是”如果被识别到类字节码不是在本机生成的，或者设置了spring.objenesis.ignore=true“，那么就不使用<code>objenesis.newInstance()</code>。<br><img src="/2020/12/14/ReadSource-SpringAOP-03CgLibProxy/ObjeenesisWorthTrying.png" alt="ObjeenesisWorthTrying"><br>这里是worth trying的，所以利用newInstance去实例化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.objenesis.SpringObjenesis</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> newInstantiatorOf(clazz).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getInstantiatorOf(clazz).newInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ObjectInstantiator&lt;T&gt; <span class="title">getInstantiatorOf</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectInstantiator&lt;?&gt; instantiator = <span class="keyword">this</span>.cache.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (instantiator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ObjectInstantiator&lt;T&gt; newInstantiator = newInstantiatorOf(clazz);</span><br><span class="line">        instantiator = <span class="keyword">this</span>.cache.putIfAbsent(clazz, newInstantiator);</span><br><span class="line">        <span class="keyword">if</span> (instantiator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instantiator = newInstantiator;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ObjectInstantiator&lt;T&gt;) instantiator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，先获取该类的实例化器的缓存，如果不存在，则调用实例化器生成策略，去创建一个实例化器，并缓存下来。这里就不贴代码了，里面林林总总写了10个Instantiator，甚至还有Android上的（可能是因为Spring也能用于Android吧，<a href="https://spring.io/projects/spring-android" target="_blank" rel="noopener">见这里</a>）。反正由于我是用的OpenJDK，最终选择了<code>SunReflectionFactoryInstantiator</code>这个实例化器（Oracle的应该也是这个）。<br>因为在实例化器创建过程中，会根据需要实例化的类去反射调用，所以CgLib也会将实例化器缓存下来。<br>这样，就可以调用该实例化器去newInstance了。  </p>
<h4 id="传入callbacks列表"><span class="post-title-index">3.1.5.3. </span><a href="#传入callbacks列表" class="headerlink" title="传入callbacks列表"></a>传入callbacks列表</h4><p>最后，由于前面生成的callbacks列表是已经实例化的对象数组，没有写入代理对象中，所以需要将其传入代理对象。调用代理对象的<code>setCallbacks()</code>方法，完成设置callbacks列表。其源码位于代理类的字节码中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// space.wudi.readsourceaop.cglibproxy.service.CgLibDynamicService$$EnhancerBySpringCGLIB$$dcb1951</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_1 = (MethodInterceptor)var1[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_2 = (NoOp)var1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_3 = (Dispatcher)var1[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_4 = (Dispatcher)var1[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_5 = (MethodInterceptor)var1[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">this</span>.CGLIB$CALLBACK_6 = (MethodInterceptor)var1[<span class="number">6</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，代理对象就生成好了。</p>
<h1 id="代理对象的调用"><span class="post-title-index">4. </span><a href="#代理对象的调用" class="headerlink" title="代理对象的调用"></a>代理对象的调用</h1><p>代理对象的方法进入之后，根据class文件，会调用callback。比如<code>useGcLibDynamicProxy()</code>这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// space.wudi.readsourceaop.cglibproxy.service.CgLibDynamicService$$EnhancerBySpringCGLIB$$dcb1951</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">useCgLibDynamicProxy</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$useCgLibDynamicProxy$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$useCgLibDynamicProxy$<span class="number">0</span>$Proxy) : <span class="keyword">super</span>.useCgLibDynamicProxy(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于我们需要代理的方法，大多数都是由<code>DynamicAdvisedInterceptor</code>进行拦截的。所以以此为例进行说明，其他的源码可以自行查看，相信看到之后都会直呼简单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// 如果是可以expose的，则将proxy保存到ThreadLocal中</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="comment">// 如果advice是空的，而且目标方法是可以访问的</span></span><br><span class="line">            <span class="comment">// 那么就可以跳过生成MethodInvocation，直接访问目标方法</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// advice链不为空，则创建一个MethodInvocation去调用advice链</span></span><br><span class="line">            retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对返回值进行处理，通常而言就是将返回的this替换成代理对象</span></span><br><span class="line">        retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            <span class="comment">// 非静态情况下需要调用releaseTarget</span></span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// 恢复ThreadLocal中的proxy</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>CglibMethodInvocation</code>继承自<code>ReflectiveMethodInvocation</code>，其proceed()过程也是直接使用了父类的proceed()，在<code>MethodInvocation.proceed()</code>中不断调用advice，最终执行<code>methodProxy.invoke()</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.CglibAopProxy.CglibMethodInvocation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ReflectionUtils.declaresException(getMethod(), ex.getClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而<a href="#方法代理MethodProxy的生成">前面</a>MethodProxy的生成和使用过程我们已经说过了，通过FastClass生成对应方法的索引，然后用硬编码的方式根据索引直接执行目标方法。</p>
<h1 id="总结"><span class="post-title-index">5. </span><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过源码追踪，总算把CGLib的生成和调用过程分析完了。可以看出来，CGLib的核心思想就是能不用反射，就尽量不用反射，能在初始化期完成，就绝不拖到运行期。所以在创建代理类的时候，虽然会不可避免的使用到反射，但是在方法代理调用的过程中，全部都是通过索引，直接运行的目标方法。这也是为什么在早期，CGLib的运行时效率比JdkDynamic要高的原因。<br>本文中所涉及的代码，都已经上传至了<a href="https://github.com/discko/ReadSource" target="_blank" rel="noopener">我的github</a>，包括本文中分析到的那几个CGLib生成的class（位于resource文件夹中），如有需要，欢迎取用。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/AOP/" rel="tag"># AOP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/12/ReadSource-SpringAOP-02JdkDynamicProxy/" rel="prev" title="阅读源码-SpringAOP-02JdkDynamicProxy">
      <i class="fa fa-chevron-left"></i> 阅读源码-SpringAOP-02JdkDynamicProxy
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/15/Concurrent-InProcessConcurrent/" rel="next" title="多线程与高并发-进程内高并发">
      多线程与高并发-进程内高并发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#自己写一个代理（通过继承）"><span class="nav-text">1. 自己写一个代理（通过继承）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用CgLib生成代理并调用"><span class="nav-text">2. 使用CgLib生成代理并调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编写代码并执行"><span class="nav-text">2.1. 编写代码并执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用过程"><span class="nav-text">2.2. 调用过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CG代理对象中的调用"><span class="nav-text">2.2.1. CG代理对象中的调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标对象的Method对象的生成"><span class="nav-text">2.2.1.1. 目标对象的Method对象的生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法代理MethodProxy的生成"><span class="nav-text">2.2.1.2. 方法代理MethodProxy的生成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用MethodProxy"><span class="nav-text">2.2.2. 使用MethodProxy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成FastClassInfo并获取对应方法的索引"><span class="nav-text">2.2.2.1. 生成FastClassInfo并获取对应方法的索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过索引调用方法"><span class="nav-text">2.2.3. 通过索引调用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结一下"><span class="nav-text">2.3. 总结一下</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CGLib在Spring中创建代理的过程"><span class="nav-text">3. CGLib在Spring中创建代理的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建开始的地方"><span class="nav-text">3.1. 创建开始的地方</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#验证目标对象合法性"><span class="nav-text">3.1.1. 验证目标对象合法性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成Enhancer"><span class="nav-text">3.1.2. 生成Enhancer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成callbacks列表"><span class="nav-text">3.1.3. 生成callbacks列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成callbackfilter"><span class="nav-text">3.1.4. 生成callbackfilter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成代理对象"><span class="nav-text">3.1.5. 生成代理对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Enhancer生成代理类字节码"><span class="nav-text">3.1.5.1. Enhancer生成代理类字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例化代理对象"><span class="nav-text">3.1.5.2. 实例化代理对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传入callbacks列表"><span class="nav-text">3.1.5.3. 传入callbacks列表</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代理对象的调用"><span class="nav-text">4. 代理对象的调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-text">5. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴迪"
      src="/images/avatar.jpg?raw=true">
  <p class="site-author-name" itemprop="name">吴迪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备17000391号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴迪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      var config = {
        theme:'default',
        logLevel:'fatal',
        securityLevel:'strict',
        startOnLoad:true,
        arrowMarkerAbsolute:false,

        er:{
          diagramPadding:20,
          layoutDirection:'TB',
          minEntityWidth:100,
          minEntityHeight:75,
          entityPadding:15,
          stroke:'gray',
          fill:'honeydew',
          fontSize:12,
          useMaxWidth:true,
        },
        flowchart:{
          diagramPadding:8,
          htmlLabels:true,
          curve:'linear',
        },
        sequence:{
          diagramMarginX:50,
          diagramMarginY:10,
          actorMargin:50,
          width:150,
          height:65,
          boxMargin:10,
          boxTextMargin:5,
          noteMargin:10,
          messageMargin:35,
          messageAlign:'center',
          mirrorActors:true,
          bottomMarginAdj:1,
          useMaxWidth:true,
          rightAngles:false,
          showSequenceNumbers:false,
        },
        gantt:{
          titleTopMargin:25,
          barHeight:20,
          barGap:4,
          topPadding:50,
          leftPadding:75,
          gridLineStartPadding:35,
          fontSize:11,
          fontFamily:'"Open-Sans", "sans-serif"',
          numberSectionStyles:4,
          axisFormat:'%Y-%m-%d',
        }
      };
      mermaid.initialize(config);
    }
  </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
