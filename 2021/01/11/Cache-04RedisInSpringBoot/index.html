<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wudi.space","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前面几篇文章介绍了Redis的一些理论和通过redis-cli的用法。本文将在Spring Boot中通过Spring-Data-Redis来操作Redis，并简要看一下Spring-Data-Redis是如何操作Redis的。">
<meta property="og:type" content="article">
<meta property="og:title" content="缓存技术-04-使用SpringDataRedis并简单研究其源码">
<meta property="og:url" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/index.html">
<meta property="og:site_name" content="吴迪小站">
<meta property="og:description" content="前面几篇文章介绍了Redis的一些理论和通过redis-cli的用法。本文将在Spring Boot中通过Spring-Data-Redis来操作Redis，并简要看一下Spring-Data-Redis是如何操作Redis的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/RedisInSpringInitializer.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/DemoRedisTemplate.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/DemoChatRoom.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/RedisTemplateCommands.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/AutowiredGenericRedisTemplate.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/ResultOfGenericRedisTemplate.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/RedisTemplateDiagram.png">
<meta property="og:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/RedisOperationMethodList.png">
<meta property="article:published_time" content="2021-01-11T04:30:11.000Z">
<meta property="article:modified_time" content="2021-01-15T14:35:26.061Z">
<meta property="article:author" content="吴迪">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/RedisInSpringInitializer.png">

<link rel="canonical" href="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>缓存技术-04-使用SpringDataRedis并简单研究其源码 | 吴迪小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴迪小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2021/01/11/Cache-04RedisInSpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          缓存技术-04-使用SpringDataRedis并简单研究其源码
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-11 12:30:11" itemprop="dateCreated datePublished" datetime="2021-01-11T12:30:11+08:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-15 22:35:26" itemprop="dateModified" datetime="2021-01-15T22:35:26+08:00">2021-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">常用缓存技术原理与应用</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前面几篇文章介绍了Redis的一些理论和通过redis-cli的用法。本文将在Spring Boot中通过Spring-Data-Redis来操作Redis，并简要看一下Spring-Data-Redis是如何操作Redis的。  </p>
<a id="more"></a>
<h1 id="加入Spring-Data-Redis"><span class="post-title-index">1. </span><a href="#加入Spring-Data-Redis" class="headerlink" title="加入Spring-Data-Redis"></a>加入Spring-Data-Redis</h1><h2 id="Maven引入"><span class="post-title-index">1.1. </span><a href="#Maven引入" class="headerlink" title="Maven引入"></a>Maven引入</h2><p>创建一个Spring Boot（2.4.1）项目后，通过Initializer选择Nosql-Redis(Access and Driver)就能够自动加入Spring-Data-Redis。<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/RedisInSpringInitializer.png" alt="RedisInSpringInitializer"></p>
<p>当然也可以通过maven手动引入：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这其中除了包括了<code>spring-boot-starter</code>之外，还引入了<code>spring-data-redis</code>和<code>lettuce-core</code>。</p>
<p>所以该版本的<code>spring-data-redis</code>已经默认使用lettuce了。如果需要使用Jedis的话，首先需要在pom中加入<code>Jedis</code>的依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>然后要么要将配置中的<code>spring.redis.client-type</code>设为<code>jedis</code>（默认为<code>lettuce</code>）。要么将<code>spring-boot-starter-data-redis</code>中的<code>lettuce-core</code>依赖去掉：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">```java</span><br></pre></td></tr></table></figure>
<h2 id="SpringBoot默认使用Lettuce"><span class="post-title-index">1.2. </span><a href="#SpringBoot默认使用Lettuce" class="headerlink" title="SpringBoot默认使用Lettuce"></a>SpringBoot默认使用Lettuce</h2><p>为什么说Spring Boot 默认使用<code>Lettuce</code>呢？从源码中就可以看到。<code>Lettuce</code>和<code>Jedis</code>生成<code>Connection</code>都需要一个工厂类，而<code>Spring-Data-Redis</code>需要将这个工厂类实例化为一个<code>bean</code>。这个过程通过两个类来实现，分别是<code>LettuceConnectionConfiguration</code>和<code>JedisConnectionConfiguration</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// springboot-autoconfig.jar!/org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.redis.client-type"</span>, havingValue = <span class="string">"lettuce"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LettuceConnectionConfiguration</span> <span class="keyword">extends</span> <span class="title">RedisConnectionConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">LettuceConnectionFactory</span> <span class="title">redisConnectionFactory</span>(<span class="title">ObjectProvider</span>&lt;<span class="title">LettuceClientConfigurationBuilderCustomizer</span>&gt; <span class="title">builderCustomizers</span>, <span class="title">ClientResources</span> <span class="title">clientResources</span>) </span>&#123;</span><br><span class="line">		LettuceClientConfiguration clientConfig = getLettuceClientConfiguration(builderCustomizers, clientResources, getProperties().getLettuce().getPool());</span><br><span class="line">		<span class="keyword">return</span> createLettuceConnectionFactory(clientConfig);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.boot.autoconfigure.data.redis.JedisConnectionConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; GenericObjectPool<span class="class">.<span class="keyword">class</span>, <span class="title">JedisConnection</span>.<span class="title">class</span>, <span class="title">Jedis</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">RedisConnectionFactory</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.redis.client-type"</span>, havingValue = <span class="string">"jedis"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionConfiguration</span> <span class="keyword">extends</span> <span class="title">RedisConnectionConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="function">JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">(ObjectProvider&lt;JedisClientConfigurationBuilderCustomizer&gt; builderCustomizers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> createJedisConnectionFactory(builderCustomizers);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个Configuration的Conditional还是有一些区别的。<br><code>Lettuce</code>的要求是基本上没什么要求：classpath中必须存在<code>class RedisClient</code>，而这个class就在lettuce包中；配置参数<code>spring.redis.client-type</code>是<code>lettuce</code>，没有也可以。<br><code>Jedis</code>的要求相对多一些，classpath中必须存在3个class；配置参数<code>spring.redis.client-type</code>是<code>jedis</code>，没有也可以；最主要的是还没有加入<code>RedisConnectionFactory</code>类型的bean。<br>这时候，如果两者只有其一，那只要<code>spring.redis.client-type</code>不设置（或者设置对了），那就不会有问题；如果两者都有的话，无论先加载<code>Lettuce</code>还是<code>Jedis</code>的<code>Configuration</code>，最终保留下来的都是<code>Lettuce</code>。（先<code>Lettuce</code>，则在<code>Jedis</code>时发现已经有<code>RedisConnectionFactory</code>类型的bean了，就不创建bean了；如果先<code>Jedis</code>，则在<code>Lettuce</code>时根据bean的覆盖原则，<code>JedisConnectionFactory</code>就被<code>Lettuce</code>覆盖了，bean的覆盖顺序问题可以看<a href="https://cloud.tencent.com/developer/article/1497702" target="_blank" rel="noopener">这里</a>）。</p>
<h2 id="配置Redis"><span class="post-title-index">1.3. </span><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h2><p>redis在Spring Boot中的配置也很简单。<br><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础配置</span></span><br><span class="line"><span class="meta">spring.redis.host</span> = <span class="string">Redis地址</span></span><br><span class="line"><span class="meta">spring.redis.port</span> = <span class="string">Redis端口号</span></span><br><span class="line"><span class="meta">spring.redis.password</span> = <span class="string">Redis密码，如需</span></span><br><span class="line"><span class="meta">spring.redis.client-type</span> = <span class="string">客户端类型，lettuce或jedis二选一，默认lettuce</span></span><br><span class="line"><span class="meta">spring.redis.database</span> = <span class="string">连接的目标redis db编号，默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池，本节每一个lettuce都可以换成jedis</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span> = <span class="string">最大连接数，负数表示无限制，默认为8</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span> = <span class="string">最大阻塞等待时间</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span> = <span class="string">连接池中最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span> = <span class="string">连接池中最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.time-between-eviction-runs</span> = <span class="string">驱逐线程的调度时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sentinel哨兵</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.nodes</span> = <span class="string">哨兵节点列表</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.master</span> = <span class="string">哨兵监控的某一个master的name，表示需要连接到的主从群</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.password</span> = <span class="string">哨兵的密码  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster集群</span></span><br><span class="line"><span class="meta">spring.redis.cluster.nodes</span> = <span class="string">cluster结点列表</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.cluster.refresh.adaptive</span> = <span class="string">开启或关闭Cluster的拓扑结构自动刷新，默认关闭（当Cluster结点因为掉线或增加而变化后，可以利用该功能自动更新结点拓扑关系）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.cluster.refresh.dynamic-refresh-sources</span> = <span class="string">当为false时，刷新拓扑只会从spring.redis.cluster.nodes设置的节点开始；为true时从所有当前已发现的节点开始。默认为true</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.cluster.refresh.period</span> = <span class="string">自动刷新拓扑的周期，单位ms，默认60秒。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="简单使用"><span class="post-title-index">2. </span><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>相关代码都位于<a href="https://github.com/discko/learncache/tree/master/redis/src" target="_blank" rel="noopener">这里</a><br>搭建好Spring Boot Data Redis环境后，在配置<code>application.yml</code>中加入：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><br>由于不想使用Web框架，所以采用注入和获取bean的形式来进行测试。  </p>
<h2 id="Demo演示"><span class="post-title-index">2.1. </span><a href="#Demo演示" class="headerlink" title="Demo演示"></a>Demo演示</h2><h3 id="基本RedisTemplate的使用"><span class="post-title-index">2.1.1. </span><a href="#基本RedisTemplate的使用" class="headerlink" title="基本RedisTemplate的使用"></a>基本RedisTemplate的使用</h3><p>先编写一个测试<code>RedisTemplate</code>的<code>Component</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.learncache.redis;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSetGet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String, String&gt; stringTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, Duration withExpire)</span></span>&#123;</span><br><span class="line">        stringTemplate.opsForValue().set(key, value, withExpire);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在启动类中增加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.learncache.redis;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(RedisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        testRedisTemplate(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRedisTemplate</span><span class="params">(ApplicationContext context)</span></span>&#123;</span><br><span class="line">        RedisSetGet redis = context.getBean(RedisSetGet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String key = <span class="string">"todaykey3"</span>;</span><br><span class="line">        String value = <span class="string">"valueof"</span>+key;</span><br><span class="line">        Duration expire = Duration.ofMinutes(<span class="number">5</span>);</span><br><span class="line">        System.out.println(redis.get(key));</span><br><span class="line">        redis.set(key, value, expire);</span><br><span class="line">        String redisReturn = (String)redis.get(key);</span><br><span class="line">        System.out.println(redisReturn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其运行结果如下：<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/DemoRedisTemplate.png" alt="Demo for RedisTemplate"></p>
<h3 id="基本PubSub的使用"><span class="post-title-index">2.1.2. </span><a href="#基本PubSub的使用" class="headerlink" title="基本PubSub的使用"></a>基本PubSub的使用</h3><p>然后再测试一个PubSub，演示一个异常简单的聊天室。新建一个<code>RedisPubSub.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.learncache.redis;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.MessageListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPubSub</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">// 注册消息监听容器</span></span><br><span class="line">    <span class="function">RedisMessageListenerContainer <span class="title">redisMessageListenerContainer</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(factory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String name, String channel, String message)</span></span>&#123;</span><br><span class="line">        redisTemplate.convertAndSend(channel, String.format(<span class="string">"%s:%s"</span>,name, message));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WudiChatRoomMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;    <span class="comment">// 记录聊天消息发送者</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WudiChatRoomMessageListener</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span>   <span class="comment">// 重写MessageListener中的接收到消息的处理事件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">            String channel = <span class="keyword">new</span> String(message.getChannel());</span><br><span class="line">            String body = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">            <span class="keyword">int</span> pos = body.indexOf(<span class="string">":"</span>);</span><br><span class="line">            <span class="comment">// 消息格式为 name:sentence</span></span><br><span class="line">            String sender = body.substring(<span class="number">0</span>, pos);</span><br><span class="line">            String sentence = body.substring(pos+<span class="number">1</span>);</span><br><span class="line">            String status = sender.equals(name)?<span class="string">"send"</span>:<span class="string">"recv"</span>;</span><br><span class="line">            <span class="comment">// 打印消息，格式：[发送或接受]通道名-发送人:内容</span></span><br><span class="line">            System.out.printf(<span class="string">"[%s]Chatroom %s - %8s: %s\n"</span>, status, channel, sender, sentence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在启动器中增加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> space.wudi.learncache.redis;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.ChannelTopic;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = SpringApplication.run(RedisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        testRedisPubSub(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRedisPubSub</span><span class="params">(ApplicationContext context)</span></span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = context.getBean(RedisMessageListenerContainer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String myName = <span class="string">"WuDi"</span>;</span><br><span class="line">        String channel = <span class="string">"WudiChatRoom"</span>;</span><br><span class="line">        <span class="comment">// 注册监听事件，可以为多个人监听多个信道</span></span><br><span class="line">        container.addMessageListener(<span class="keyword">new</span> RedisPubSub.WudiChatRoomMessageListener(myName),</span><br><span class="line">                <span class="keyword">new</span> ChannelTopic(channel));</span><br><span class="line">        System.out.println(<span class="string">"START CHATTING ~"</span>);</span><br><span class="line">        RedisPubSub redisPubSub = context.getBean(RedisPubSub<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String message = <span class="keyword">null</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">while</span>(!<span class="string">"quit"</span>.equals(message))&#123;</span><br><span class="line">            message = scanner.nextLine();</span><br><span class="line">            redisPubSub.sendMessage(myName, channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最终效果：<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/DemoChatRoom.png" alt="Demo for pub &amp; sub">  </p>
<h2 id="其他高层API用法"><span class="post-title-index">2.2. </span><a href="#其他高层API用法" class="headerlink" title="其他高层API用法"></a>其他高层API用法</h2><p>当然，<code>RedisTemplate</code>已经为我们封装了很多各种用法。</p>
<p><img src="/2021/01/11/Cache-04RedisInSpringBoot/RedisTemplateCommands.png" alt="RedisTemplateCommands">。</p>
<p>这些高阶用法可以实现对redis几乎所有的操作。  </p>
<h2 id="字节型API"><span class="post-title-index">2.3. </span><a href="#字节型API" class="headerlink" title="字节型API"></a>字节型API</h2><p>前面的文章也说到了，Redis底层是二进制安全的，因为其底层的所有值数据都是以字节数组的形式存放的，而RedisTemplate已经将其封装过了。比如String会直接调用getBytes()方法获得其默认编码（<code>Charset.defaultCharset() == UTF-8</code>）下的字节数组，而Map、List等Java对象也会转换为相应的格式或命令组合。如果Redis的存取双方都是Java那没有关系，但如果存取有一方不是Java，那最简单的方式就是直接通过字节流的形式编码好再存入Redis，调用底层字节数组的方式是这样操作的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RedisConnection conn = redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">conn.hSet(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] field, <span class="keyword">byte</span>[] value);</span><br><span class="line">conn.redisTemplate.hashCommands().hSet(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] field, <span class="keyword">byte</span>[] value);</span><br></pre></td></tr></table></figure></p>
<p>当然，此外，redisTemplate还提供了修改序列化器的方式来修改对象与字节的转化关系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.setDefaultSerializer(<span class="keyword">new</span> RedisSerializer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String s) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(bytes, <span class="string">"gbk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>除了修改默认的序列化器，还可以通过<code>setKeySerializer</code>、<code>setStringSerializer</code>等方式指定key、value、hash等不同位置和类型的序列化器。  </p>
<h2 id="RedisTemplate的泛型绑定"><span class="post-title-index">2.4. </span><a href="#RedisTemplate的泛型绑定" class="headerlink" title="RedisTemplate的泛型绑定"></a>RedisTemplate的泛型绑定</h2><p>上面的代码中都是将RedisTemplate的泛型写全了<code>RedisTemplate&lt;String, String&gt;</code>。其实不写的话也可以。当然，结果会有一些变化。<br>从下图中可以看到，当把RedisTemplate的泛型去掉之后，或者泛型为<code>&lt;Object, Object&gt;</code>，这两个自动绑定的对象是一样的，而<code>RedisTemplate&lt;String, String&gt;</code>则是自动绑定了一个<code>StringRedisTemplate</code>类型的实例。<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/AutowiredGenericRedisTemplate.png" alt="AutowiredGenericRedisTemplate">  </p>
<p>接下来尝试执行下面两条语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Autowired</span></span><br><span class="line"><span class="comment">RedisTemplate redisTemplate;</span></span><br><span class="line"><span class="comment">@Autowired</span></span><br><span class="line"><span class="comment">RedisTemplate&lt;String, String&gt; stringTemplate;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">stringTemplate.opsForValue().set(<span class="string">"key2"</span>, <span class="string">"value2"</span>)</span><br><span class="line">System.out.println(<span class="string">"rT.get(key1)="</span>+redisTemplate.opsForValue().get(<span class="string">"key1"</span>));</span><br><span class="line">System.out.println(<span class="string">"sT.get(key1)="</span>+stringTemplate.opsForValue().get(<span class="string">"key1"</span>));</span><br><span class="line">System.out.println(<span class="string">"rT.get(key2)="</span>+redisTemplate.opsForValue().get(<span class="string">"key2"</span>));</span><br><span class="line">System.out.println(<span class="string">"sT.get(key2)="</span>+stringTemplate.opsForValue().get(<span class="string">"key2"</span>));</span><br></pre></td></tr></table></figure><br>可以在redis上看到这样的2条记录：<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/ResultOfGenericRedisTemplate.png" alt="ResultOfGenericRedisTemplate"></p>
<p>通过<code>StringRedisTemplate</code>执行的set操作符合直觉，而通过<code>RedisTemplate</code>的插入比想象中多了很多不可见字符。  </p>
<p>而在下面的4个get得到的输出是这样的：</p>
<blockquote>
<p>rT.get(key1)=value1<br>sT.get(key1)=null<br>rT.get(key2)=null<br>sT.get(key2)=value2   </p>
</blockquote>
<p>猜想这应该是Redis的二进制安全导致的。  </p>
<p>通过调试，逐步找到了输出的二进制的位置，可以看到，RedisTemplate的默认Serializer是<code>a</code>，其内部通过<code>org.springframework.core.serializer.DefaultSerializer</code>来序列化和反序列化。而<code>DefaultSerializer</code>的<code>serialize()</code>方是这样的，也即通过ObjectOutputStream将key和value序列化成字节流放入ByteArrayOutputStream中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.core.serializer.DefaultSerializer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object object, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Serializable)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(getClass().getSimpleName() + <span class="string">" requires a Serializable payload but received an object of type ["</span> + object.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">    objectOutputStream.writeObject(object);</span><br><span class="line">    objectOutputStream.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.core.serializer.Serializer#serializeToByteArray</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">byte</span>[] serializeToByteArray(T object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">    serialize(object, out);</span><br><span class="line">    <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而StringRedisTemplate的默认Serializer是<code>StringRedisSerializer</code>，其<code>serialize()</code>方法是这样的，直接获取<code>String</code>的<code>byte</code>数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.serializer.StringRedisSerializer#serialize</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> (string == <span class="keyword">null</span> ? <span class="keyword">null</span> : string.getBytes(charset));  <span class="comment">// charset = UTF-8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反序列化同理，<code>RedisTemplate</code>使用的是<code>DefaultDeserializer</code>，而<code>StringRedisTemplate</code>仍然使用的<code>StringRedisSerializer</code>。<br>这与<a href="#配置自动加载">下一章下一节</a>可以呼应起来看</p>
<h1 id="SpringDataRedis简易工作原理"><span class="post-title-index">3. </span><a href="#SpringDataRedis简易工作原理" class="headerlink" title="SpringDataRedis简易工作原理"></a>SpringDataRedis简易工作原理</h1><h2 id="配置自动加载"><span class="post-title-index">3.1. </span><a href="#配置自动加载" class="headerlink" title="配置自动加载"></a>配置自动加载</h2><p>由于不需要进行扫描或者<code>@Configuration</code>，在spring-data-redis.jar中也没有<code>@EnableAutoConfig</code>，所以只能去<code>spring-boot-autoconfig</code>。在<code>META-INF/spring.factories</code>中可以搜索到与redis相关的3个：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br></pre></td></tr></table></figure><br>所以自动配置是从<code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code>这个类开始的。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// springboot-autoconfig.jar</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.data.redis;</span><br><span class="line"><span class="comment">// import ...</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisOperations<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RedisProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123; LettuceConnectionConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">JedisConnectionConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line">	<span class="meta">@ConditionalOnSingleCandidate</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">RedisTemplate</span>&lt;<span class="title">Object</span>, <span class="title">Object</span>&gt; <span class="title">redisTemplate</span>(<span class="title">RedisConnectionFactory</span> <span class="title">redisConnectionFactory</span>) </span>&#123;</span><br><span class="line">		RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">		template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">		<span class="keyword">return</span> template;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="meta">@ConditionalOnSingleCandidate</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">StringRedisTemplate</span> <span class="title">stringRedisTemplate</span>(<span class="title">RedisConnectionFactory</span> <span class="title">redisConnectionFactory</span>) </span>&#123;</span><br><span class="line">		StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">		template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">		<span class="keyword">return</span> template;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会生成2个bean，一个是<code>RedisTemplate&lt;Object, Object&gt;</code>类型的名为<code>redisTemplate</code>，一个是<code>StringRedisTemplate</code>类型的名为<code>stringRedisTemplate</code>。进一步的，可以看到，<code>StringRedisTemplate</code>是继承自<code>RedisTemplate&lt;String, String&gt;</code>，而且在构造时，就将所有的序列化器都设置为了<code>UTF-8</code>编码的<code>StringRedisSerializer</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.StringRedisTemplate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		setKeySerializer(RedisSerializer.string());</span><br><span class="line">		setValueSerializer(RedisSerializer.string());</span><br><span class="line">		setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">		setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.serializer.RedisSerializer#string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> RedisSerializer&lt;String&gt; <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StringRedisSerializer.UTF_8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这两个bean所需要的RedisConnectionFactory又是从哪里生成的呢？从<code>RedisAutoConfiguration</code>类的注解<code>@Import</code>可以看到，引入两个Configuration，分别是<code>Lettuce</code>和<code>Jedis</code>。这两个就是在<a href="#firstConfig">一开始</a>介绍的对RedisConnectionFactory的两个不同的实现。以<code>Lettuce</code>为例：<br><a href="connectionFactory" &gt;></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LettuceConnectionFactory <span class="title">createLettuceConnectionFactory</span><span class="params">(LettuceClientConfiguration clientConfiguration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getSentinelConfig() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(getSentinelConfig(), clientConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getClusterConfiguration() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(getClusterConfiguration(), clientConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LettuceConnectionFactory(getStandaloneConfig(), clientConfiguration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从这里可以看出，sentinel的配置和cluster的配置是不可以同时起效的，sentinel优先。当两个都没有的时候，通过standalone的配置生成连接工厂。  </p>
<h2 id="调用Redis单结点"><span class="post-title-index">3.2. </span><a href="#调用Redis单结点" class="headerlink" title="调用Redis单结点"></a>调用Redis单结点</h2><p><code>RedisTemplate</code>生成好之后就可以通过<code>@Autowired</code>注入到业务代码中了。  </p>
<p><code>RedisTemplate</code>是一个什么呢？从其diagram可以看出来<code>RedisTemplate</code>继承或实现自三个类/接口。其中<code>BeanClassLoaderAware</code>提供了这个bean在构造时应当使用的<code>ClassLoader</code>，<code>RedisAccessor</code>是<code>RedisConnectionFactory</code>的容器，同时提供了在bean初始化完成后的校验功能（<code>afterPropertiesSet()</code>）。<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/RedisTemplateDiagram.png" alt="RedisTemplate Diagram">  </p>
<p>而<code>RedisOperations</code>则提供<code>RedisTemplate</code>则是一个接口，提供了Redis的基础操作，包括与类型无关的数据操作（<code>delete</code>、<code>expire</code>等）、事务相关操作（<code>multi</code>、<code>watch</code>）、针对各个Redis类型的具体操作指令集（如<code>opsForValue</code>、<code>opsForHash</code>等）、针对各个Redis类型的省略重复引用key的具体操作指令集（如<code>boundValueOps</code>、<code>boundHashOps</code>等），以及最重要的指令执行函数<code>execute</code>：<br><img src="/2021/01/11/Cache-04RedisInSpringBoot/RedisOperationMethodList.png" alt="RedisOperationMethodList"></p>
<p>直接写在RedisTemplate中的指令，都是通过execute方法，在RedisCallback这个回调中指定connection去调用特定方法的（也就是<a href="#字节型API">上面写的所谓的字节型API</a>）。<br>而各个Redis类型的具体操作指令集是直接返回的RedisTemplate实例中的常量对象（由于RedisTemplate是单例的，所以这些也是单例的）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisTemplate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ValueOperations&lt;K, V&gt; valueOps = <span class="keyword">new</span> DefaultValueOperations&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> ValueOperations&lt;K, V&gt; <span class="title">opsForValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valueOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相对的，绑定key（这样在后续使用时，就不需要再指定指令的key是什么）的操作指令集就是随用随创建的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisTemplate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BoundValueOperations&lt;K, V&gt; <span class="title">boundValueOps</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultBoundValueOperations&lt;&gt;(key, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但无论是哪一种操作指令集，都是通过execute方法，在RedisCallback这个回调中指定connection去调用特定方法的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.DefaultValueOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.get(rawKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.core.DefaultBoundValueOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的ops就是通过RedisTemplate.opsForValue()得到的DefaultValueOperations</span></span><br><span class="line">    <span class="comment">// 所以这里调用的其实就是上面这个方法</span></span><br><span class="line">    <span class="keyword">return</span> ops.get(getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建Redis连接"><span class="post-title-index">3.2.1. </span><a href="#创建Redis连接" class="headerlink" title="创建Redis连接"></a>创建Redis连接</h3><p>通过<code>RedisConnectionUtils</code>，可以看到2组静态方法<code>bindConnection</code>和<code>getConnection</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisConnectionUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisConnection <span class="title">bindConnection</span><span class="params">(RedisConnectionFactory factory, <span class="keyword">boolean</span> transactionSupport)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetConnection(factory, <span class="keyword">true</span>, <span class="keyword">true</span>, transactionSupport);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisConnection <span class="title">getConnection</span><span class="params">(RedisConnectionFactory factory, <span class="keyword">boolean</span> transactionSupport)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetConnection(factory, <span class="keyword">true</span>, <span class="keyword">false</span>, transactionSupport);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="绑定or创建？"><span class="post-title-index">3.2.1.1. </span><a href="#绑定or创建？" class="headerlink" title="绑定or创建？"></a>绑定or创建？</h4><p>那么就来看看<code>doGetConnection</code>是如何获取连接的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisConnection <span class="title">doGetConnection</span><span class="params">(RedisConnectionFactory factory, <span class="keyword">boolean</span> allowCreate, <span class="keyword">boolean</span> bind, <span class="keyword">boolean</span> transactionSupport)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    Assert.notNull(factory, <span class="string">"No RedisConnectionFactory specified"</span>);</span><br><span class="line">    <span class="comment">// 从ThreadLocal获取connectionHolder</span></span><br><span class="line">    RedisConnectionHolder conHolder = (RedisConnectionHolder) TransactionSynchronizationManager.getResource(factory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conHolder != <span class="keyword">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;</span><br><span class="line">        <span class="comment">// 如果holder存在，则通过它复用一个连接，内部实现是一个计数器自增1</span></span><br><span class="line">        conHolder.requested();</span><br><span class="line">        <span class="keyword">if</span> (!conHolder.hasConnection()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Fetching resumed Redis Connection from RedisConnectionFactory"</span>);</span><br><span class="line">            conHolder.setConnection(fetchConnection(factory));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conHolder.getRequiredConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则就说明holder不存在</span></span><br><span class="line">    <span class="keyword">if</span> (!allowCreate) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No connection found and allowCreate = false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">"Fetching Redis Connection from RedisConnectionFactory"</span>);</span><br><span class="line">    <span class="comment">// 通过factory获取一个连接</span></span><br><span class="line">    RedisConnection connection = fetchConnection(factory);</span><br><span class="line">    <span class="keyword">boolean</span> bindSynchronization = TransactionSynchronizationManager.isActualTransactionActive() &amp;&amp; transactionSupport;</span><br><span class="line">    <span class="keyword">if</span> (bind || bindSynchronization) &#123;</span><br><span class="line">        <span class="comment">// 如果需要绑定</span></span><br><span class="line">        <span class="keyword">if</span> (bindSynchronization &amp;&amp; isActualNonReadonlyTransactionActive()) &#123;</span><br><span class="line">            connection = createConnectionSplittingProxy(connection, factory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将connection加入connectionHolder之中</span></span><br><span class="line">            RedisConnectionHolder holderToUse = conHolder;</span><br><span class="line">            <span class="keyword">if</span> (holderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                holderToUse = <span class="keyword">new</span> RedisConnectionHolder(connection);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                holderToUse.setConnection(connection);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连接复用计数自增1</span></span><br><span class="line">            holderToUse.requested();</span><br><span class="line">            <span class="keyword">if</span> (bindSynchronization) &#123;</span><br><span class="line">                potentiallyRegisterTransactionSynchronisation(holderToUse, factory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将connectionHolder加入ThreadLocal中</span></span><br><span class="line">            <span class="keyword">if</span> (holderToUse != conHolder) &#123;</span><br><span class="line">                TransactionSynchronizationManager.bindResource(factory, holderToUse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123; <span class="comment">// 发生异常则释放连接</span></span><br><span class="line">            releaseConnection(connection, factory);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的核心是一个<code>RedisConnectionHolder</code>。首先尝试通过<code>TransactionSynchronizationManager.getResource()</code>取得这个holder。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.transaction.support.TransactionSynchronizationManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Object value = map.get(actualKey);</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">        map.remove(actualKey);</span><br><span class="line">        <span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">            resources.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到这里的类内常量属性<code>resources</code>就是一个<code>ThreadLocal</code>。<br>如果<code>conHolder</code>存在，则通过它获取一个连接，并且通过<code>conHolder.requested()</code>将connection的引用+1个。<br>如果<code>conHolder</code>，那么就要通过<code>fetchConnection(factory)</code>去获取<code>RedisConnection</code>了。<br>获取得到连接对象后，如果需要<code>bind</code>，则通过<code>TransactionSynchronizationManager.bindResource(factory, holderToUse);</code>将RedisConnectionHolder对象加入resources这个ThreadLocal中保留起来。这样下一个执行bindConnection的指令，就可以直接获取连接，而不需要去<code>fetchConnection</code>了。  </p>
<h4 id="Lettuce创建连接"><span class="post-title-index">3.2.1.2. </span><a href="#Lettuce创建连接" class="headerlink" title="Lettuce创建连接"></a>Lettuce创建连接</h4><p>再往下挖，看看<code>fetchConnection</code>是怎么做的。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisConnectionUtils</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RedisConnection <span class="title">fetchConnection</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factory.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是直接调用<code>factory</code>的<code>getConnection</code>方法。而RedisConnectionfactory在这里有2种实现，分别是Lettuce的和Jedis的。那就看看Lettuce的吧。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisConnection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClusterAware()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getClusterConnection();  <span class="comment">// 获取RedisCluster的连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    LettuceConnection connection;</span><br><span class="line">    connection = doCreateLettuceConnection(getSharedConnection(), connectionProvider, getTimeout(), getDatabase());<span class="comment">// 获取普通连接</span></span><br><span class="line">    connection.setConvertPipelineAndTxResults(convertPipelineAndTxResults);<span class="comment">//添加</span></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是通过<code>getClusterConnection</code>获取RedisCluster的连接的，下面是通过<code>doCreateLettuceConnection</code>获取普通连接的。集群连接我们先不去管，先看看<code>doCreateLettuceConnection</code>的几个参数。<br>这个函数除了第二个connectionProvider在前面已经生成好了（在初始化bean时，通过<code>afterPropertiesSet()</code>设置的），<code>getTimeout()</code>和<code>getDatabase()</code>都是从设置里直接取出来的，默认分别是<code>60s</code>和<code>0</code>。接下来还剩一个<code>getSharedConnection()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> shareNativeConnection = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">protected</span> StatefulRedisConnection&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; getSharedConnection() &#123;</span><br><span class="line">    <span class="comment">// shareNativeConnection == true</span></span><br><span class="line">    <span class="keyword">return</span> shareNativeConnection ? (StatefulRedisConnection) getOrCreateSharedConnection().getConnection() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> SharedConnection&lt;ByteBuffer&gt; <span class="title">getOrCreateSharedReactiveConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.connectionMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reactiveConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reactiveConnection = <span class="keyword">new</span> SharedConnection&lt;&gt;(reactiveConnectionProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.reactiveConnection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出来，Lettuce中使用的<code>StatefulRedisConnection</code>，是通过先创建<code>SharedConnection&lt;ByteBuffer&gt;</code>，再通过<code>SharedConnection.getConnection()</code>得到的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.SharedConnection</span></span><br><span class="line"><span class="function">StatefulConnection&lt;E, E&gt; <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.connectionMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.connection = getNativeConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getValidateConnection()) &#123;</span><br><span class="line">            validateConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>继续往下，getNativeConnection()，会根据初始化时选择的connectionPrivider去获取连接（根据配置去选择实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.SharedConnection</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> StatefulConnection&lt;E, E&gt; <span class="title">getNativeConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的connectionProvider根据LettuceConnectionFactory.afterPropertiesSet()来看，是ExceptionTranslatingConnectionProvider</span></span><br><span class="line">    <span class="keyword">return</span> connectionProvider.getConnection(StatefulConnection<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory.ExceptionTranslatingConnectionProvider</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends StatefulConnection&lt;?, ?&gt;&gt; <span class="function">T <span class="title">getConnection</span><span class="params">(Class&lt;T&gt; connectionType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ExceptionTranslatingConnectionProvider内的delegate也是一个ConnectionProvider</span></span><br><span class="line">        <span class="comment">// 根据LettuceCnnectionFactory.doCreateConnectionProvider来看有3种可能</span></span><br><span class="line">        <span class="keyword">return</span> delegate.getConnection(connectionType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> translateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> LettuceConnectionProvider <span class="title">doCreateConnectionProvider</span><span class="params">(AbstractRedisClient client, RedisCodec&lt;?, ?&gt; codec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">if</span> (isStaticMasterReplicaAware()) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StaticMasterReplicaConnectionProvider((RedisClient) client, codec, nodes, readFrom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isClusterAware()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClusterConnectionProvider((RedisClusterClient) client, codec, readFrom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandaloneConnectionProvider((RedisClient) client, codec, readFrom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那就先看看独立模式<code>StandaloneConnectionProvider</code>的<code>getConnection(connectionType)</code>吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends StatefulConnection&lt;?, ?&gt;&gt; <span class="function">T <span class="title">getConnection</span><span class="params">(Class&lt;T&gt; connectionType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">if</span> (StatefulConnection<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">connectionType</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectionType.cast(readFrom.map(it -&gt; <span class="keyword">this</span>.masterReplicaConnection(redisURISupplier.get(), it))</span><br><span class="line">                .orElseGet(() -&gt; client.connect(codec)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Connection type "</span> + connectionType + <span class="string">" not supported!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以最终返回的应当是<code>client.connect(codec)</code>返回的连接。这个client是一个<code>RedisClient</code>对象，如果设了密码的话，会经过<code>AuthenticatingRedisClient</code>做一个中转，还是会调用RedisClient去执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.RedisClient</span></span><br><span class="line"><span class="keyword">public</span> &lt;K, V&gt; <span class="function">StatefulRedisConnection&lt;K, V&gt; <span class="title">connect</span><span class="params">(RedisCodec&lt;K, V&gt; codec)</span> </span>&#123;</span><br><span class="line">    checkForRedisURI();</span><br><span class="line">    <span class="keyword">return</span> getConnection(connectStandaloneAsync(codec, <span class="keyword">this</span>.redisURI, getDefaultTimeout()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>connectStandaloneAsync</code>返回的是一个Future，而<code>getConnection</code>是将异步执行的Future同步get的方法，所以直接看<code>connectStandaloneAsync</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.RedisClient</span></span><br><span class="line"><span class="keyword">private</span> &lt;K, V&gt; ConnectionFuture&lt;StatefulRedisConnection&lt;K, V&gt;&gt; connectStandaloneAsync(RedisCodec&lt;K, V&gt; codec, RedisURI redisURI, Duration timeout) &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    DefaultEndpoint endpoint = <span class="keyword">new</span> DefaultEndpoint(getOptions(), getResources());</span><br><span class="line">    RedisChannelWriter writer = endpoint;</span><br><span class="line">    <span class="keyword">if</span> (CommandExpiryWriter.isSupported(getOptions())) &#123;</span><br><span class="line">        writer = <span class="keyword">new</span> CommandExpiryWriter(writer, getOptions(), getResources());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实例化connection，并在其中加入sync、async、react三种指令集</span></span><br><span class="line">    StatefulRedisConnectionImpl&lt;K, V&gt; connection = newStatefulRedisConnection(writer, endpoint, codec, timeout);</span><br><span class="line">    <span class="comment">// 创建connection的future对象</span></span><br><span class="line">    ConnectionFuture&lt;StatefulRedisConnection&lt;K, V&gt;&gt; future = connectStatefulAsync(connection, endpoint, redisURI,</span><br><span class="line">            () -&gt; <span class="keyword">new</span> CommandHandler(getOptions(), getResources(), endpoint));</span><br><span class="line">    <span class="comment">// 添加future的完成事件</span></span><br><span class="line">    future.whenComplete((channelHandler, throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里可以注意一下这个<code>newStatefulRedisConnection</code>方法，它返回了一个<code>StatefulRedisConnectionImpl</code>对象。这个对象里有什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.StatefulRedisConnectionImpl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StatefulRedisConnectionImpl</span><span class="params">(RedisChannelWriter writer, PushHandler pushHandler, RedisCodec&lt;K, V&gt; codec, Duration timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(writer, timeout);</span><br><span class="line">    <span class="keyword">this</span>.pushHandler = pushHandler;</span><br><span class="line">    <span class="keyword">this</span>.codec = codec;</span><br><span class="line">    <span class="keyword">this</span>.async = newRedisAsyncCommandsImpl();</span><br><span class="line">    <span class="keyword">this</span>.sync = newRedisSyncCommandsImpl();</span><br><span class="line">    <span class="keyword">this</span>.reactive = newRedisReactiveCommandsImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它里面包含了同步、异步、响应式3个<code>RedisCommands</code>的实现。以同步的为例看一看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.StatefulRedisConnectionImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RedisCommands&lt;K, V&gt; <span class="title">newRedisSyncCommandsImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入上面刚生成好的RedisCommands的异步实现async</span></span><br><span class="line">    <span class="keyword">return</span> syncHandler(async(), RedisCommands<span class="class">.<span class="keyword">class</span>, <span class="title">RedisClusterCommands</span>.<span class="title">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.lettuce.core.RedisChannelHandler</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">syncHandler</span><span class="params">(Object asyncApi, Class&lt;?&gt;... interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个JDK动态代理</span></span><br><span class="line">    FutureSyncInvocationHandler h = <span class="keyword">new</span> FutureSyncInvocationHandler((StatefulConnection&lt;?, ?&gt;) <span class="keyword">this</span>, asyncApi, interfaces);</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(AbstractRedisClient<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">interfaces</span>, <span class="title">h</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.lettuce.core.FutureSyncInvocationHandler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">handleInvocation</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method targetMethod = <span class="keyword">this</span>.translator.get(method);</span><br><span class="line">        <span class="comment">// 这里的method是Redis的get、set等指令，会去调用网络库进行通信，返回值是放有Redis服务器返回回来的值的Future对象</span></span><br><span class="line">        Object result = targetMethod.invoke(asyncApi, args);</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> RedisFuture&lt;?&gt;) &#123;</span><br><span class="line">            RedisFuture&lt;?&gt; command = (RedisFuture&lt;?&gt;) result;</span><br><span class="line">            <span class="keyword">if</span> (!isTxControlMethod(method.getName(), args) &amp;&amp; isTransactionActive(connection)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> timeout = getTimeoutNs(command);</span><br><span class="line">            <span class="comment">// 异步转同步，等待执行完成</span></span><br><span class="line">            <span class="keyword">return</span> Futures.awaitOrCancel(command, timeout, TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里通过将异步方式同步化，从而实现异步与同步使用同一套代码。而至于为什么使用代理，我猜想是为了<del>偷懒（😹不是）</del>代码复用，减少代码复杂度，毕竟可以去看一下<code>AbstractRedisAsyncCommands</code>写得有多长（2265行，所有的指令都实现了一遍，还有各种重载）。  </p>
<p>通过<code>connectStatefulAsync</code>，一路调用<code>initializeChannelAsync</code>和<code>initializeChannelAsync0</code>，终于到了最后的地方：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.AbstractRedisClient</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeChannelAsync0</span><span class="params">(ConnectionBuilder connectionBuilder, CompletableFuture&lt;Channel&gt; channelReadyFuture, SocketAddress redisAddress)</span> </span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"Connecting to Redis at &#123;&#125;"</span>, redisAddress);</span><br><span class="line">    <span class="comment">// 创建Netty客户端</span></span><br><span class="line">    Bootstrap redisBootstrap = connectionBuilder.bootstrap();</span><br><span class="line">    <span class="comment">// 连接成功以后的handler</span></span><br><span class="line">    ChannelInitializer&lt;Channel&gt; initializer = connectionBuilder.build(redisAddress);</span><br><span class="line">    redisBootstrap.handler(initializer);</span><br><span class="line">    <span class="comment">// 空指令</span></span><br><span class="line">    clientResources.nettyCustomizer().afterBootstrapInitialized(redisBootstrap);</span><br><span class="line">    <span class="comment">// 真正的连接过程</span></span><br><span class="line">    ChannelFuture connectFuture = redisBootstrap.connect(redisAddress);</span><br><span class="line">    channelReadyFuture.whenComplete((c, t) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CancellationException) &#123;</span><br><span class="line">            connectFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    connectFuture.addListener(future -&gt; &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="comment">// 在Netty连接成功之后，相应事件Handshaker的Future</span></span><br><span class="line">        RedisHandshakeHandler handshakeHandler = connectFuture.channel().pipeline().get(RedisHandshakeHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (handshakeHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            channelReadyFuture.completeExceptionally(<span class="keyword">new</span> IllegalStateException(<span class="string">"RedisHandshakeHandler not registered"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接成功且握手成功后的处理</span></span><br><span class="line">        handshakeHandler.channelInitialized().whenComplete((success, throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 没有发生异常的处理，省略部分</span></span><br><span class="line">                RedisChannelHandler&lt;?, ?&gt; connection = connectionBuilder.connection();</span><br><span class="line">                connection.registerCloseables(closeableResources, connection);</span><br><span class="line">                channelReadyFuture.complete(connectFuture.channel());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发生了异常的处理，省略</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<code>initializeChannelAsync0</code>中总共做了这么几件事情：  </p>
<ol>
<li>创建Bootstrap也就是Netty的客户端</li>
<li>向redisBootstrap中加入Netty连接成功之后的处理事件（也就是Redis连接的初始化，或者称之为handshake握手）</li>
<li>连接，生成connectionFuture</li>
<li>添加握手完成的处理事件。成功则将connectionFuture中netty连接好的channel放到channelReadyFuture中；失败则清理状态。  </li>
</ol>
<p>该函数通过channelReadyFuture将连接过程中的异常或者连接并握手完成的channel返回出去。  </p>
<h4 id="建立Netty-Channel后的握手"><span class="post-title-index">3.2.1.3. </span><a href="#建立Netty-Channel后的握手" class="headerlink" title="建立Netty Channel后的握手"></a>建立Netty Channel后的握手</h4><p>最后再简单看一下握手是如何进行的。<br>通过<code>initializeChannelAsync0</code>找到了连接成功后用于初始化的handler对象的生成代码：<code>ChannelInitializer&lt;Channel&gt; initializer = connectionBuilder.build(redisAddress);</code>，进去看看，发现创建了一个<code>PlainChannelInitializer</code>对象。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.ConnectionBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelInitializer&lt;Channel&gt; <span class="title">build</span><span class="params">(SocketAddress socketAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PlainChannelInitializer(<span class="keyword">this</span>::buildHandlers, clientResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象的构造函数的第一个参数是一个<code>Supplier&lt;List&lt;ChannelHandler&gt;&gt;</code>，那么看来就是通过<code>this::buildHandlers</code>方法去创建连接成功的初始化handler的（包括握手）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.ConnectionBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;ChannelHandler&gt; <span class="title">buildHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验</span></span><br><span class="line">    List&lt;ChannelHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    connection.setOptions(clientOptions);</span><br><span class="line">    <span class="comment">// 添加channel group的监听，通过event bus知晓netty channel group中增加/移除channel的情况</span></span><br><span class="line">    handlers.add(<span class="keyword">new</span> ChannelGroupListener(channelGroup, clientResources.eventBus()));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> CommandEncoder());</span><br><span class="line">    <span class="comment">// 握手事件</span></span><br><span class="line">    handlers.add(getHandshakeHandler());</span><br><span class="line">    handlers.add(commandHandlerSupplier.get());</span><br><span class="line">    handlers.add(<span class="keyword">new</span> ConnectionEventTrigger(connectionEvents, connection, clientResources.eventBus()));</span><br><span class="line">    <span class="keyword">if</span> (clientOptions.isAutoReconnect()) &#123;</span><br><span class="line">        <span class="comment">// 如果需要断线重连，添加ConnectionWatchdog，默认为true</span></span><br><span class="line">        handlers.add(createConnectionWatchdog());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>getHandshakeHandler()中就只返回了一个<code>new RedisHandshakeHandler(connectionInitializer, clientResources, timeout);</code>。<br>而在<code>RedisHandshakeHandler</code>的<code>channelActive</code>方法中还是要调用<code>connectionInitializer.initialize</code>方法。那么这个<code>connectionInitializer</code>是哪里来的呢，经过一番查找，发现来自于<code>io.lettuce.core.RedisClient#connectStatefulAsync</code>中，也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.RedisClient</span></span><br><span class="line"><span class="keyword">private</span> &lt;K, V, S&gt; <span class="function">ConnectionFuture&lt;S&gt; <span class="title">connectStatefulAsync</span><span class="params">(StatefulRedisConnectionImpl&lt;K, V&gt; connection, Endpoint endpoint, RedisURI redisURI, Supplier&lt;CommandHandler&gt; commandHandlerSupplier)</span> </span>&#123;</span><br><span class="line">    ConnectionBuilder connectionBuilder;</span><br><span class="line">    <span class="comment">// 省略创建和初始化connectionBuilder</span></span><br><span class="line">    <span class="comment">// 创建connectionHandler</span></span><br><span class="line">    connectionBuilder.connectionInitializer(createHandshake(state));</span><br><span class="line">    channelType(connectionBuilder, redisURI);</span><br><span class="line">    <span class="comment">// 从该函数进入initializeChannelAsync0，通过netty连接redis服务器</span></span><br><span class="line">    ConnectionFuture&lt;RedisChannelHandler&lt;K, V&gt;&gt; future = initializeChannelAsync(connectionBuilder);</span><br><span class="line">    <span class="keyword">return</span> future.thenApply(channelHandler -&gt; (S) connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个createHandshake也是一句话函数，返回了一个RedisHandshakedui对象<code>return new RedisHandshake(clientOptions.getConfiguredProtocolVersion(), clientOptions.isPingBeforeActivateConnection(),state)</code>。那么调用<code>connectionInitializer.initializer()</code>就是调用这个对象的<code>initializer</code>方法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.RedisHandshake</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">initialize</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;?&gt; handshake;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.requestedProtocolVersion == ProtocolVersion.RESP2) &#123;</span><br><span class="line">        handshake = initializeResp2(channel);</span><br><span class="line">        negotiatedProtocolVersion = ProtocolVersion.RESP2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.requestedProtocolVersion == ProtocolVersion.RESP3) &#123;</span><br><span class="line">        handshake = initializeResp3(channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.requestedProtocolVersion == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handshake = tryHandshakeResp3(channel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handshake = Futures.failed(<span class="keyword">new</span> RedisConnectionException(<span class="string">"Protocol version"</span> + <span class="keyword">this</span>.requestedProtocolVersion + <span class="string">" not supported"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handshake.thenCompose(ignore -&gt; applyPostHandshake(channel, getNegotiatedProtocolVersion()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里可以看到，根据Redis的<code>ProtocolVersion</code>是<code>RESP2</code>还是<code>RESP3</code>。初始时，<code>this.requestedProtocolVersion</code>为<code>null</code>，所以通过<code>tryHandshakeResp3(channel)</code>尝试使用高版本的进行握手。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletableFuture&lt;?&gt; tryHandshakeResp3(Channel channel) &#123;</span><br><span class="line">    CompletableFuture&lt;?&gt; handshake = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">// 首先通过RESP3握手</span></span><br><span class="line">    AsyncCommand&lt;String, String, Map&lt;String, Object&gt;&gt; hello = initiateHandshakeResp3(channel);</span><br><span class="line">    hello.whenComplete((settings, throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isUnknownCommand(hello.getError())) &#123;</span><br><span class="line">                <span class="comment">// 通过RESP3握手失败，滚落到通过RESP2握手</span></span><br><span class="line">                fallbackToResp2(channel, handshake);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handshake.completeExceptionally(throwable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handshake.complete(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> handshake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当尝试使用RESP3握手失败之后，再fallback到RESP2进行握手。那么RESP3和RESP2有什么区别呢？其实很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.RedisHandshake</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;?&gt; initiateHandshakeResp2(Channel channel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connectionState.hasUsername()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(channel, <span class="keyword">this</span>.commandBuilder.auth(connectionState.getUsername(), connectionState.getPassword()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connectionState.hasPassword()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(channel, <span class="keyword">this</span>.commandBuilder.auth(connectionState.getPassword()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.pingOnConnect) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(channel, <span class="keyword">this</span>.commandBuilder.ping());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> AsyncCommand&lt;String, String, Map&lt;String, Object&gt;&gt; initiateHandshakeResp3(Channel channel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connectionState.hasPassword()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(channel, <span class="keyword">this</span>.commandBuilder.hello(<span class="number">3</span>,</span><br><span class="line">                LettuceStrings.isNotEmpty(connectionState.getUsername()) ? connectionState.getUsername() : <span class="string">"default"</span>,</span><br><span class="line">                connectionState.getPassword(), connectionState.getClientName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatch(channel, <span class="keyword">this</span>.commandBuilder.hello(<span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, connectionState.getClientName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是说，<code>RESP2</code>是通过<code>AUTH</code>指令去握手的（当没有用户名密码时，发送一个<code>PING</code>指令），而<code>RESP3</code>是通过<code>HELLO</code>指令去握手的（有用户名密码时，带上用户名密码，用户名默认为<code>default</code>；没有时只发送一个通信协议版本3）。  </p>
<p>所以从这个角度来看，握手就是在进行身份认证。  </p>
<p>到这里，连接的过程就完成了。</p>
<h3 id="execute执行"><span class="post-title-index">3.2.2. </span><a href="#execute执行" class="headerlink" title="execute执行"></a>execute执行</h3><p>接下来再来看看如何执行Redis指令，也就是看看<code>execute</code>方法到底是如何执行的。execute追根到底一共有2个，一个是调用<code>RedisCallback</code>的，还有一个是调用<code>SessionCallback</code>的。</p>
<p><code>SessionCallback</code>使用的是bindConnection，而<code>RedisCallback</code>使用的是<code>getConnection</code>。这两个函数内部调用的函数是一样的，都是<code>doGetConnection</code>，只不过第三个参数<code>bind</code>，<code>SessionCallback</code>设的是<code>true</code>，而<code>RedisCallback</code>是<code>false</code>。根据<a href="#创建Redis连接">前一节</a>的描述可以知道，bindConnection在同一个线程中获取到的是同一个Netty Channel，而getConnection则不能保证是否是同一个。<br>因此SessionCallback通常用于执行Redis自带的事务（<code>multi</code>、<code>watch</code>、<code>discard</code>、<code>exec</code>之间的操作，这些命令要求必须在同一个Redis连接中完成），这种事务只能通过此种方式进行（见<a href="https://docs.spring.io/spring-data/redis/docs/2.4.3/reference/html/#tx" target="_blank" rel="noopener">Spring Data Redis官方文档</a>。<br>其执行过程大致是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisTemplate</span></span><br><span class="line">stringRedisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">        ValueOperations valueOperations = operations.opsForValue();</span><br><span class="line">        operations.multi();</span><br><span class="line">        operations.opsForValue().set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        operations.opsForValue().set(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        System.out.println(operations.opsForValue().get(<span class="string">"key1"</span>));</span><br><span class="line">        operations.exec();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisTemplate</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(SessionCallback&lt;T&gt; session)</span> </span>&#123;</span><br><span class="line">    Assert.isTrue(initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">    Assert.notNull(session, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line">    RedisConnectionFactory factory = getRequiredConnectionFactory();</span><br><span class="line">    <span class="comment">// 绑定连接</span></span><br><span class="line">    RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> session.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而RedisCallback的用法大概是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stringTemplate.opsForValue().set(<span class="string">"key"</span>, <span class="string">"value"</span>);</span><br><span class="line"><span class="comment">// org.springframework.data.redis.core.DefaultValueOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] rawValue = rawValue(value);</span><br><span class="line">    execute(<span class="keyword">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            connection.set(rawKey, rawValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验</span></span><br><span class="line">    RedisConnectionFactory factory = getRequiredConnectionFactory();</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    RedisConnection conn = RedisConnectionUtils.getConnection(factory, enableTransactionSupport);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line">        RedisConnection connToUse = preProcessConnection(conn, existingConnection);</span><br><span class="line">        <span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.openPipeline();</span><br><span class="line">        &#125;</span><br><span class="line">        RedisConnection connToExpose = (exposeConnection ? connToUse : createRedisConnectionProxy(connToUse));</span><br><span class="line">        T result = action.doInRedis(connToExpose);</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.closePipeline();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory, enableTransactionSupport);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出来，<code>SessionCallback</code>中其实调用的也是<code>RedisCallback</code>。那这两个有什么区别呢？可以看到，连接到redis服务器的连接<code>RedisConnection</code>，是在<code>execute()</code>方法中获得的，而用于执行<code>SessionCallback</code>和<code>RedisCallback</code>的两个<code>execute()</code>的重载，获取连接的方式并不一样。<code>SessionCallback</code>是通过<code>RedisConnectionUtils.bindConnection</code>来获取连接（连接通过<code>ConnectionHolder</code>放在<code>ThreadLocal</code>中，没有就创建）；而<code>RedisCallback</code>直接通过<code>RedisConnectionUtils.getConnection</code>来获取一个连接。<br>在<code>execute</code>中调用<code>action.doInRedis</code>，然后将doInRedis的返回值通过<code>postProcessResult</code>后处理再返回。</p>
<h4 id="指令的发送"><span class="post-title-index">3.2.2.1. </span><a href="#指令的发送" class="headerlink" title="指令的发送"></a>指令的发送</h4><p>针对不同的指令，在<code>doInRedis</code>中也是不一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.DefaultValueOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] rawValue = rawValue(value);</span><br><span class="line">    execute(<span class="keyword">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            connection.set(rawKey, rawValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.core.DefaultValueOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.get(rawKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.core.DefaultHashOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, HK hashKey, HV value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] rawKey = rawKey(key);</span><br><span class="line">    <span class="keyword">byte</span>[] rawHashKey = rawHashKey(hashKey);</span><br><span class="line">    <span class="keyword">byte</span>[] rawHashValue = rawHashValue(value);</span><br><span class="line">    execute(connection -&gt; &#123;</span><br><span class="line">        connection.hSet(rawKey, rawHashKey, rawHashValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，最终调用的<code>connection</code>中的字节指令。而在此之前，如果是string<br>指令集中的set相关的方法，需要通过<code>rawValue()</code>方法将<code>value</code>转换成<code>byte[]</code>；如果是hash指令集中的put相关方法，需要通过<code>rawKey</code>、<code>rawHashKey</code>、<code>rawHashValue</code>等方法将<code>key</code>、<code>hashkey</code>、<code>hashvalue</code>都转成<code>byte[]</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.AbstractOperations</span></span><br><span class="line"><span class="keyword">byte</span>[] rawValue(Object value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (valueSerializer() == <span class="keyword">null</span> &amp;&amp; value <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>[]) value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valueSerializer().serialize(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，当value的类型就是<code>byte[]</code>时直接使用，否则需要调用相应的序列化器转换成<code>byte[]</code>。<br>然后看看是如何发送的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.connection.DefaultStringRedisConnection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">set</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> convertAndReturn(delegate.set(key, value), identityConverter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.connection.DefaultedRedisConnection</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Boolean <span class="title">set</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stringCommands().set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// org.springframework.data.redis.connection.lettuce.LettuceStringCommands</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">set</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 省略pipeline模式和transaction模式的发送</span></span><br><span class="line">        <span class="comment">// 普通情况下调用这里的</span></span><br><span class="line">        <span class="keyword">return</span> Converters.stringToBoolean(getConnection().set(key, value));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> convertLettuceAccessException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过代理，最终到达<code>AbstractRedisAsyncCommands</code>（通过异步并等待的方式同步执行）中，这里的commandBuilder.set创建了一个<code>RedisCommand</code>，里面包含了指令类型SET、键key和值value，以及存储返回值的<code>StatusOutput</code>对象。然后调用dispatch进行执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.AbstractRedisAsyncCommands</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisFuture&lt;String&gt; <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(commandBuilder.set(key, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后通过<code>StatefulConnection</code>调用<code>dispatch</code>，并返回带有返回值的<code>dispatched</code>或者<code>asyncCommand</code>对象（都是一个<code>AsyncCommand</code>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.lettuce.core.AbstractRedisAsyncCommands</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">AsyncCommand&lt;K, V, T&gt; <span class="title">dispatch</span><span class="params">(RedisCommand&lt;K, V, T&gt; cmd)</span> </span>&#123;</span><br><span class="line">    AsyncCommand&lt;K, V, T&gt; asyncCommand = <span class="keyword">new</span> AsyncCommand&lt;&gt;(cmd);</span><br><span class="line">    RedisCommand&lt;K, V, T&gt; dispatched = connection.dispatch(asyncCommand);</span><br><span class="line">    <span class="keyword">if</span> (dispatched <span class="keyword">instanceof</span> AsyncCommand) &#123;</span><br><span class="line">        <span class="keyword">return</span> (AsyncCommand&lt;K, V, T&gt;) dispatched;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> asyncCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后经过层层调用，在<code>DefaultEndpoint</code>中的<code>channelWriteAndFlush</code>调用Netty的channel的<code>writeAndFlush</code>将消息发送出去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">channelWriteAndFlush</span><span class="params">(RedisCommand&lt;?, ?, ?&gt; command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">        logger.debug(<span class="string">"&#123;&#125; write() writeAndFlush command &#123;&#125;"</span>, logPrefix(), command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channel.writeAndFlush(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="指令返回值的处理"><span class="post-title-index">3.2.2.2. </span><a href="#指令返回值的处理" class="headerlink" title="指令返回值的处理"></a>指令返回值的处理</h4><p>上面说到了，<code>AbstractRedisAsyncCommands.dispatch</code>的返回值是一个Future，里面就存着Netty请求执行后的返回值。在经过同步等待后，在<code>Lettuce*Commands</code>系列类的指令方法中或得到<code>byte[]</code>返回值，然后一路返回，一直回到execute写的Callback完成，返回后继续执行<code>AbstractOperations</code>的<code>doInRedis</code>，利用<code>deserializer</code>转换所需的值类型（比如String、或特定的Object。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.AbstractOperations</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = inRedis(rawKey(key), connection);</span><br><span class="line">    <span class="keyword">return</span> deserializeValue(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="释放连接"><span class="post-title-index">3.2.3. </span><a href="#释放连接" class="headerlink" title="释放连接"></a>释放连接</h3><p>在<code>execute</code>方法中有一个finally代码块，里面就一句话，当任意一个Redis指令发送并返回（正常或异常）后，都会执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisTemplate</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略校验参数</span></span><br><span class="line">    RedisConnectionFactory factory = getRequiredConnectionFactory();</span><br><span class="line">    RedisConnection conn = RedisConnectionUtils.getConnection(factory, enableTransactionSupport);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 省略执行与返回</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory, enableTransactionSupport);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(SessionCallback&lt;T&gt; session)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验</span></span><br><span class="line">    RedisConnectionFactory factory = getRequiredConnectionFactory();</span><br><span class="line">    RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 省略执行与返回</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.unbindConnection(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同样对应于<code>getConnection</code>和<code>bindConnection</code>，这里有<code>releaseConnection</code>和<code>unbindConnection</code>两种释放连接的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(@Nullable RedisConnection conn, RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RedisConnectionHolder conHolder = (RedisConnectionHolder) TransactionSynchronizationManager.getResource(factory);</span><br><span class="line">    <span class="keyword">if</span> (conHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果被conHolder持有本连接</span></span><br><span class="line">        <span class="keyword">if</span> (conHolder.isTransactionActive()) &#123;</span><br><span class="line">            <span class="comment">// 说明在@Transactional事务中，还有其他指令执行，此时不应该断开连接</span></span><br><span class="line">            <span class="keyword">if</span> (connectionEquals(conHolder, conn)) &#123;</span><br><span class="line">                <span class="comment">// 省略日志</span></span><br><span class="line">                <span class="comment">// 复用计数自减1，不要关闭</span></span><br><span class="line">                conHolder.released();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 既然被conHolder持有，那么就先解绑一次</span></span><br><span class="line">        unbindConnection(factory);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 什么都不是，直接断开连接</span></span><br><span class="line">    doCloseConnection(conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unbindConnection</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从ThreadLocal中获取conHolder</span></span><br><span class="line">    RedisConnectionHolder conHolder = (RedisConnectionHolder) TransactionSynchronizationManager.getResource(factory);</span><br><span class="line">    <span class="keyword">if</span> (conHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略日志</span></span><br><span class="line">    <span class="keyword">if</span> (conHolder.isTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// 如果在@Transactional事务中，则什么都不做</span></span><br><span class="line">        <span class="comment">// 省略日志</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RedisConnection connection = conHolder.getConnection();</span><br><span class="line">        <span class="comment">// 与conHolder.requested()对应，释放复用计数自减1</span></span><br><span class="line">        conHolder.released();</span><br><span class="line">        <span class="keyword">if</span> (!conHolder.isOpen()) &#123;</span><br><span class="line">            <span class="comment">// 将conHolder从ThreadLocal中移除</span></span><br><span class="line">            TransactionSynchronizationManager.unbindResourceIfPossible(factory);</span><br><span class="line">            <span class="comment">// 释放连接</span></span><br><span class="line">            doCloseConnection(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Transactional事务的开启和提交"><span class="post-title-index">3.2.4. </span><a href="#Transactional事务的开启和提交" class="headerlink" title="@Transactional事务的开启和提交"></a>@Transactional事务的开启和提交</h3><p>这里需要明确一下，<code>@Transactional</code>标记的事务不是由<code>RedisClient</code>管理的，它是由TransactionManager管理的，由它通过AOP控制事务的开启、结束、提交、返回。详细信息可以参见<a href="https://docs.spring.io/spring-data/redis/docs/2.4.3/reference/html/#tx.spring" target="_blank" rel="noopener">官方文档</a>。这里<code>conHolder.isTransactionActive()</code>就是用来判断是否启用了这种事务，经过<code>RedisConnectionUtils.RedisConnectionHolder#setTransactionActive</code>方法的注释查看<code>PlatformTransactionManager</code>接口的注释，同样说明了这一点。如果启用了这样的事务，在<code>RedisConnectionUtils</code>中方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RedisConnectionUtils#doGetConnection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisConnection <span class="title">doGetConnection</span><span class="params">(RedisConnectionFactory factory, <span class="keyword">boolean</span> allowCreate, <span class="keyword">boolean</span> bind, <span class="keyword">boolean</span> transactionSupport)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">boolean</span> bindSynchronization = TransactionSynchronizationManager.isActualTransactionActive() &amp;&amp; transactionSupport;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">if</span> (bindSynchronization) &#123;</span><br><span class="line">        potentiallyRegisterTransactionSynchronisation(holderToUse, factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RedisConnectionUtils#potentiallyRegisterTransactionSynchronisation</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">potentiallyRegisterTransactionSynchronisation</span><span class="params">(RedisConnectionHolder connHolder,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Should go actually into RedisTransactionManager</span></span><br><span class="line">    <span class="keyword">if</span> (!connHolder.isTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// 就是这里设置的</span></span><br><span class="line">        connHolder.setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line">        connHolder.setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">        connHolder.requested();</span><br><span class="line">        RedisConnection conn = connHolder.getRequiredConnection();</span><br><span class="line">        <span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">        <span class="keyword">if</span> (!readOnly) &#123;</span><br><span class="line">            <span class="comment">// 通过conn发送MULTI指令</span></span><br><span class="line">            conn.multi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册一个事务同步器，用于管理这个@Transactional事务的状态</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> RedisTransactionSynchronizer(connHolder, conn, factory, readOnly));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而最后，当事务因为正常或异常而结束时，通过<code>RedisTransactionSynchronizer</code>提交或者丢弃事务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.data.redis.core.RedisConnectionUtils.RedisTransactionSynchronizer</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当@Transactional事务结束时，会调用这个方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readOnly) &#123;</span><br><span class="line">            <span class="comment">// 根据不同的结束状态，执行EXEC指令或者DISCARD指令</span></span><br><span class="line">            <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> TransactionSynchronization.STATUS_COMMITTED:</span><br><span class="line">                    connection.exec();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TransactionSynchronization.STATUS_ROLLED_BACK:</span><br><span class="line">                <span class="keyword">case</span> TransactionSynchronization.STATUS_UNKNOWN:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    connection.discard();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 省略日志</span></span><br><span class="line">        <span class="comment">// @Transactional事务状态切换为false，并释放连接</span></span><br><span class="line">        connHolder.setTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">        doCloseConnection(connection);</span><br><span class="line">        TransactionSynchronizationManager.unbindResource(factory);</span><br><span class="line">        connHolder.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/SpringBoot/" rel="tag"># SpringBoot</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/06/Cache-03RedisCluster/" rel="prev" title="缓存技术-03-Redis高可用">
      <i class="fa fa-chevron-left"></i> 缓存技术-03-Redis高可用
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/13/ExperienceOfMinerVirus/" rel="next" title="云主机被植入挖矿病毒后">
      云主机被植入挖矿病毒后 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#加入Spring-Data-Redis"><span class="nav-text">1. 加入Spring-Data-Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven引入"><span class="nav-text">1.1. Maven引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot默认使用Lettuce"><span class="nav-text">1.2. SpringBoot默认使用Lettuce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置Redis"><span class="nav-text">1.3. 配置Redis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#简单使用"><span class="nav-text">2. 简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo演示"><span class="nav-text">2.1. Demo演示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本RedisTemplate的使用"><span class="nav-text">2.1.1. 基本RedisTemplate的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本PubSub的使用"><span class="nav-text">2.1.2. 基本PubSub的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他高层API用法"><span class="nav-text">2.2. 其他高层API用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节型API"><span class="nav-text">2.3. 字节型API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RedisTemplate的泛型绑定"><span class="nav-text">2.4. RedisTemplate的泛型绑定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringDataRedis简易工作原理"><span class="nav-text">3. SpringDataRedis简易工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置自动加载"><span class="nav-text">3.1. 配置自动加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用Redis单结点"><span class="nav-text">3.2. 调用Redis单结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Redis连接"><span class="nav-text">3.2.1. 创建Redis连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定or创建？"><span class="nav-text">3.2.1.1. 绑定or创建？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lettuce创建连接"><span class="nav-text">3.2.1.2. Lettuce创建连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立Netty-Channel后的握手"><span class="nav-text">3.2.1.3. 建立Netty Channel后的握手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execute执行"><span class="nav-text">3.2.2. execute执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令的发送"><span class="nav-text">3.2.2.1. 指令的发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令返回值的处理"><span class="nav-text">3.2.2.2. 指令返回值的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放连接"><span class="nav-text">3.2.3. 释放连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transactional事务的开启和提交"><span class="nav-text">3.2.4. @Transactional事务的开启和提交</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴迪"
      src="/images/avatar.jpg?raw=true">
  <p class="site-author-name" itemprop="name">吴迪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备17000391号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴迪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      var config = {
        theme:'default',
        logLevel:'fatal',
        securityLevel:'strict',
        startOnLoad:true,
        arrowMarkerAbsolute:false,

        er:{
          diagramPadding:20,
          layoutDirection:'TB',
          minEntityWidth:100,
          minEntityHeight:75,
          entityPadding:15,
          stroke:'gray',
          fill:'honeydew',
          fontSize:12,
          useMaxWidth:true,
        },
        flowchart:{
          diagramPadding:8,
          htmlLabels:true,
          curve:'linear',
        },
        sequence:{
          diagramMarginX:50,
          diagramMarginY:10,
          actorMargin:50,
          width:150,
          height:65,
          boxMargin:10,
          boxTextMargin:5,
          noteMargin:10,
          messageMargin:35,
          messageAlign:'center',
          mirrorActors:true,
          bottomMarginAdj:1,
          useMaxWidth:true,
          rightAngles:false,
          showSequenceNumbers:false,
        },
        gantt:{
          titleTopMargin:25,
          barHeight:20,
          barGap:4,
          topPadding:50,
          leftPadding:75,
          gridLineStartPadding:35,
          fontSize:11,
          fontFamily:'"Open-Sans", "sans-serif"',
          numberSectionStyles:4,
          axisFormat:'%Y-%m-%d',
        }
      };
      mermaid.initialize(config);
    }
  </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
