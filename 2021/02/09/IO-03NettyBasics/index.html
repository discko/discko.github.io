<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.wudi.space","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前一篇文章自己利用java.nio.Selector实现了一个可以分组的多路复用器。在实际实践中，对于复杂的网络通信环境，通常会使用Netty来简化开发工作。由于netty5迟迟难产（具体可以参见Netty Issue 4466），目前稳定的版本依然是Netty4（截止2021年初）   接下来，就利用Netty 4.1.59-Final（1天前发布的，趁热）来对前文的“智能对话机器人”进行重构。">
<meta property="og:type" content="article">
<meta property="og:title" content="IO-03Netty基础用法与几个细节">
<meta property="og:url" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/index.html">
<meta property="og:site_name" content="吴迪小站">
<meta property="og:description" content="前一篇文章自己利用java.nio.Selector实现了一个可以分组的多路复用器。在实际实践中，对于复杂的网络通信环境，通常会使用Netty来简化开发工作。由于netty5迟迟难产（具体可以参见Netty Issue 4466），目前稳定的版本依然是Netty4（截止2021年初）   接下来，就利用Netty 4.1.59-Final（1天前发布的，趁热）来对前文的“智能对话机器人”进行重构。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyByteBufOperations.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyUnsafeComment.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/ByteBufTree.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyChunks.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/runsAvailAllocate.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/runsAvaiFree.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NioEventLoopTree.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyPipeline.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/ChannelInOutBoundHandlerAndDefaultFire.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyHandlePipeline.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyBoundHandlerPropagation.png">
<meta property="og:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/SharableHandler.png">
<meta property="article:published_time" content="2021-02-09T13:56:25.000Z">
<meta property="article:modified_time" content="2021-02-21T11:02:00.722Z">
<meta property="article:author" content="吴迪">
<meta property="article:tag" content="IO">
<meta property="article:tag" content="NIO">
<meta property="article:tag" content="Netty4">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.wudi.space/2021/02/09/IO-03NettyBasics/NettyByteBufOperations.png">

<link rel="canonical" href="https://www.wudi.space/2021/02/09/IO-03NettyBasics/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>IO-03Netty基础用法与几个细节 | 吴迪小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴迪小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.wudi.space/2021/02/09/IO-03NettyBasics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg?raw=true">
      <meta itemprop="name" content="吴迪">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴迪小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          IO-03Netty基础用法与几个细节
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-09 21:56:25" itemprop="dateCreated datePublished" datetime="2021-02-09T21:56:25+08:00">2021-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-21 19:02:00" itemprop="dateModified" datetime="2021-02-21T19:02:00+08:00">2021-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">IO技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="/2021/02/08/IO-02MultiplexSelector/">前一篇文章</a>自己利用java.nio.Selector实现了一个可以分组的多路复用器。在实际实践中，对于复杂的网络通信环境，通常会使用Netty来简化开发工作。由于netty5迟迟难产（具体可以参见<a href="https://github.com/netty/netty/issues/4466" target="_blank" rel="noopener">Netty Issue 4466</a>），目前稳定的版本依然是Netty4（截止2021年初）  </p>
<p>接下来，就利用Netty 4.1.59-Final（1天前发布的，趁热）来对前文的“智能对话机器人”进行重构。</p>
<p>Netty的核心Core分为部分。为了简化对ByteBuffer的操作，Netty使用了自己定义的ByteBuf（官方介绍为Zero-Copy-Capable Rich Byte Buffer，即“可零拷贝的富字节缓存”），然后是对新旧Java IO封装的API（官方介绍为Universal Communication API，即“通用通信API”）。最后是基于拦截链的灵活事件模型（官方介绍为Extensible Event Model，也即“可扩展的事件模型”）<br><a id="more"></a></p>
<h1 id="ByteBuf"><span class="post-title-index">1. </span><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><p><code>ByteBuf</code>是Netty中的一个抽象类，通过接口<code>ReferenceCounted</code>提供对内存的引用计数和释放。  </p>
<h2 id="内部结构和基本操作"><span class="post-title-index">1.1. </span><a href="#内部结构和基本操作" class="headerlink" title="内部结构和基本操作"></a>内部结构和基本操作</h2><p>在上一篇文章中，我们分析了JDK中的<code>java.nio.ByteBuffer</code>的结构，其中只有一个<code>position</code>指针来记录当前操作到（读到 和 写到）的位置，然后通过limit标记读写的极限位置，使用时通过<code>flip()</code>、<code>reset()</code>、<code>rewind()</code>等方法不断操作<code>position</code>的位置，从而对<code>ByteBuffer</code>进行读写。<code>ByteBuffer</code>的操作还是略显麻烦，并且违反直觉。  </p>
<p>而Netty的<code>ByteBuf</code>中通过两个指针<code>readerIndex</code>和<code>writerIndex</code>记录已经读到和写到的位置。这样的话，整个ByteBuf的内存就可以分为3块：</p>
<ol>
<li><code>discardable bytes</code>：0到<code>readerIndex</code>之间，这一部分已经读过了，可以通过<code>ByteBuf#discardReadBytes()</code>或<code>ByteBuf#discardSomeReadBytes()</code>去丢弃它们。  </li>
<li><code>readable bytes</code>：<code>readerIndex</code>到<code>writerIndex</code>之间，这一部分是已经写入的，但还没有读的，是接下来可读的，可以通过<code>ByteBuf#readByte</code>系列的方法读取。</li>
<li><code>writable bytes</code>：<code>writerIndex</code>到最后（也即<code>capacity</code>）之间，这一部分是还没有写入的区域，也就是还剩余的可写区域。可通过<code>ByteBuf#writeByte</code>系列的方法写入。  </li>
</ol>
<p><img src="/2021/02/09/IO-03NettyBasics/NettyByteBufOperations.png" alt="NettyByteBufOperations"> </p>
<p>通过上面提到的这些方法，可以遵循正常的操作直觉对ByteBuf进行操作，当然实际是在操作<code>readerIndex</code>和<code>writerIndex</code>两个指针。顺序情况下，我们只需要通过readByte或者writeByte在读写的过程中对readerIndex和writerIndex进行移动。<br>当需要丢弃一部分数据时，如果需要丢弃已被读过的部分（discardable bytes），可以通过<code>discardReadBytes</code>或者<code>discardSomeReadBytes</code>来进行。当开始丢弃时，会将<code>readerIndex</code>和<code>writerIndex</code>之间的<code>readable bytes</code>复制到0位置，然后将<code>readerIndex</code>指针移动到0位置，<code>writerIndex</code>移动到新的<code>readable bytes</code>的尾。两个方法的不同之处在于，<code>discardReadBytes</code>会无条件地进行复制（当<code>readable bytes</code>区域长度为0是退化为不复制）；而<code>discardSomeReadBytes</code>只会在可用空间不足一半时，才会复制，这样就避免了在空间还很充足的情况下反复地滕让空间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.AbstractByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">discardReadBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readerIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (readerIndex != writerIndex) &#123;</span><br><span class="line">        setBytes(<span class="number">0</span>, <span class="keyword">this</span>, readerIndex, writerIndex - readerIndex);</span><br><span class="line">        writerIndex -= readerIndex;</span><br><span class="line">        adjustMarkers(readerIndex);</span><br><span class="line">        readerIndex = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        adjustMarkers(readerIndex);</span><br><span class="line">        writerIndex = readerIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">discardSomeReadBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readerIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readerIndex == writerIndex) &#123;</span><br><span class="line">            ensureAccessible();</span><br><span class="line">            adjustMarkers(readerIndex);</span><br><span class="line">            writerIndex = readerIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (readerIndex &gt;= capacity() &gt;&gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            setBytes(<span class="number">0</span>, <span class="keyword">this</span>, readerIndex, writerIndex - readerIndex);</span><br><span class="line">            writerIndex -= readerIndex;</span><br><span class="line">            adjustMarkers(readerIndex);</span><br><span class="line">            readerIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>另外一种丢弃数据的方式就是将已经被读过的部分和写入的部分都丢弃，也就是清空这个ByteBuf，使用<code>clear()</code>方法。当然这个方法仅仅将2个指针都移动到0的位置，当然，并没有真的清空，这些已经写入的区域，将会在后面写入时被覆盖掉）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.AbstractByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readerIndex = writerIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，最暴力的方法就是通过<code>setIndex(int readerIndex, writerIndex)</code>直接设置两个指针的位置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.AbstractByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds) &#123;</span><br><span class="line">        checkIndexBounds(readerIndex, writerIndex, capacity());</span><br><span class="line">    &#125;</span><br><span class="line">    setIndex0(readerIndex, writerIndex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex0</span><span class="params">(<span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerIndex = readerIndex;</span><br><span class="line">    <span class="keyword">this</span>.writerIndex = writerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ByteBuf的分类"><span class="post-title-index">1.2. </span><a href="#ByteBuf的分类" class="headerlink" title="ByteBuf的分类"></a>ByteBuf的分类</h2><p>ByteBuf可以根据不同的维度进行分类。总的来说说基本会按照分配的位置（Heap vs Direct）、可重用性（Pooled vs Unpooled）和指针安全性（- vs Unsafe）这三个方面进行分类。</p>
<h3 id="分配位置"><span class="post-title-index">1.2.1. </span><a href="#分配位置" class="headerlink" title="分配位置"></a>分配位置</h3><p>如果按照分配位置来分类的话，ByteBuf可以分为在堆上分配的ByteBuf和在直接内存上分配的ByteBuf。在命名上以Heap和Direct进行区分。<br>在堆上分配，就直接通过new byte[]的方式进行，比如UnpooledHeapByteBuf。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.UnpooledDirectByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledDirectByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验和field赋值</span></span><br><span class="line">    setByteBuffer(allocateDirect(initialCapacity), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.allocateDirect(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直接内存则是通过ByteBuffer.allocateDirect，比如UnpooledDirectByteBuf<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.UnpooledHeapByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledHeapByteBuf</span><span class="params">(ByteBufAllocator alloc, <span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验和field赋值</span></span><br><span class="line">    setArray(allocateArray(initialCapacity));</span><br><span class="line">    setIndex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] allocateArray(<span class="keyword">int</span> initialCapacity) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="是否复用内存空间"><span class="post-title-index">1.2.2. </span><a href="#是否复用内存空间" class="headerlink" title="是否复用内存空间"></a>是否复用内存空间</h3><p>根据是否复用内存空间来分，ByteBuf可以分为Pooled和Unpooled两类。<br>Unpooled每一次初始化，都会调用相关API，在内存中直接创建一块内存用于存储，具体而言就是<a href="#分配位置">上面提到的分配位置的API</a>。</p>
<p>而Pooled则是在一块预先分配好的空间上，反复使用。这块内存通过一个<code>PoolChunk</code>对象进行管理，通过<code>reuse</code>方法进行重复使用，在需要回收时，通过传入的<code>recycleHandler</code>进行deallocate：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.PooledByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reuse</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    maxCapacity(maxCapacity);</span><br><span class="line">    resetRefCnt();</span><br><span class="line">    setIndex0(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    discardMarks();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="是否使用Unsafe"><span class="post-title-index">1.2.3. </span><a href="#是否使用Unsafe" class="headerlink" title="是否使用Unsafe"></a>是否使用Unsafe</h3><p>根据是否通过Unsafe直接访问内存来访问ByteBuf的内容，可以将ByteBuf分为带有Unsafe和不带Unsafe的两类。<br>从<code>Unpooled</code>的<code>wrappedBuffer(ByteBuffer)</code>中可以看到，如果运行的平台支持Unsafe（也就是<code>sun.misc.Unsafe</code>存在），则会创建Unsafe的ByteBuf，否则创建普通的ByteBuf。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.Unpooled</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">wrappedBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">if</span> (!buffer.isDirect() &amp;&amp; buffer.hasArray()) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.isReadOnly()) &#123;</span><br><span class="line">            <span class="comment">// 返回ReadOnly的ByteBuf</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回UnsafeByteBuf</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnpooledUnsafeDirectByteBuf(ALLOC, buffer, buffer.remaining());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.isReadOnly()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReadOnlyByteBufferBuf(ALLOC, buffer);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回普通ByteBuf</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UnpooledDirectByteBuf(ALLOC, buffer, buffer.remaining());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而PlatformDependent.hasUnsafe()则是明确的说明了判断的条件以及为什么使用Unsafe的原因：</p>
<p><img src="/2021/02/09/IO-03NettyBasics/NettyUnsafeComment.png" alt="Netty Unsafe Comment"></p>
<blockquote>
<p>如果<code>sun.misc.Unsafe</code>存在则返回<code>true</code>，以此提速对直接内存的访问。  </p>
</blockquote>
<p>而在底层，UnsafeByteBuf是通过Unsafe对内存直接进行操作，以获取特定index处的字节为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.UnpooledUnsafeDirectByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkIndex(index);</span><br><span class="line">    <span class="keyword">return</span> _getByte(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用_getByte(int)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UnsafeByteBufUtil.getByte(addr(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将index转换为地址</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">addr</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memoryAddress + index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UnsafeByteBufUtil.getByte最终调用</span></span><br><span class="line"><span class="comment">// io.netty.util.internal.PlatformDependent0#getByte(long)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// UNSAFE是一个sun.misc.Unsafe的实例</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.getByte(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而与之相对的，不带Unsafe标志的ByteBuf，则是直接通过对象操作，交由JVM自己去执行响应的API。比如Direct就利用ByteBuffer（具体来说是一个<code>DirectByteBuffer</code>），而Heap就通过<code>byte[]</code>数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.UnpooledDirectByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">return</span> _getByte(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// buffer是一个java.nio.ByteBuffer的实例</span></span><br><span class="line">    <span class="keyword">return</span> buffer.get(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.netty.buffer.UnpooledHeapByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    <span class="keyword">return</span> _getByte(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">byte</span> <span class="title">_getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HeapByteBufUtil.getByte(array, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// io.netty.buffer.HeapByteBufUtil#getByte</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">byte</span>[] memory, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memory[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以总的来说，标有Unsafe的ByteBuf对象，在进行数据访问时，会通过sun.misc.Unsafe工具类对内存进行直接访问；而没有Unsafe的ByteBuf则直接通过JVMAPI对数据进行访问。使用Unsafe在一些情况下，会快一些。  </p>
<h3 id="小结"><span class="post-title-index">1.2.4. </span><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后，通过Idea生成一个在上述3个分类中的8个ByteBuf派生类的继承关系图<br><img src="/2021/02/09/IO-03NettyBasics/ByteBufTree.png" alt="ByteBufTree"></p>
<p>关于为什么其他Unsafe的都是继承自非Unsafe的同名类，而<code>PooledUnsafeDirectByteBuf</code>和<code>PooledDirectByteBuf</code>却是同级的（都直接继承自<code>PooledByteBuf</code>，目前我还没有看出来原因，直接在源码上，我似乎还没有找到需要绕过<code>PooledDirectByteBuf</code>的情况。</p>
<p>不过看稍早期Netty 4 的类结构，似乎<code>UnpooledUnsafeDirectByteBuf</code>也是直接绕过<code>UnpooledUnsafeDirectByteBuf</code>，转而继承自<code>AbstractReferenceCountedByteBuf</code>。也许只是忘记改了？</p>
<h2 id="PooledByteBuf的创建"><span class="post-title-index">1.3. </span><a href="#PooledByteBuf的创建" class="headerlink" title="PooledByteBuf的创建"></a>PooledByteBuf的创建</h2><p>这一块比较复杂，值得单独抽一篇文章来讲。这里仅仅说明一下结论。<br>在创建时，如果没有指定使用Direct内存还是Heap内存，将优先使用Direct。这样在直接操作内存时，就可以不受GC回收导致内存地址变化而需要反复获取内存地址了。但是由于创建直接内存比在堆上直接分配内存慢（因为堆上直接由JMM管理，而堆上内存需要通过操作系统分配），所以通过Pooled的形式形成内存池，接下来由Netty自行管理。  </p>
<h3 id="名词解释"><span class="post-title-index">1.3.1. </span><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>首先先说明一下Netty的内存管理中的几个名词：</p>
<ul>
<li>page：page是可分配的最小内存块</li>
<li>run：若干个page组成的集合</li>
<li>chunk：若干个run组成的集合  </li>
<li>handle：用于快速识别和访问chunk中已经被分配的内存的一个long指针。其格式见后</li>
<li>runAvailMap：一个用于管理所有run（包括已使用的和未使用的）的map。其key是runOffset（chunk中page的偏移量），value是对应的handle。每一个run的首page和尾page都会放在这个map中。</li>
<li>runAvail：一个PriorityQueue[]，每一个queue中存放相同大小的run，并以offset为优先级排序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oooooooo ooooooos ssssssss ssssssue bbbbbbbb bbbbbbbb bbbbbbbb bbbbbbbb</span><br><span class="line">o：runOffset（chunk中page的偏移量），15bit。</span><br><span class="line">s：run的大小（用page的个数表示），15bit。</span><br><span class="line">u：是否被使用了，1bit</span><br><span class="line">e：是否是subpage，1bit</span><br><span class="line">b：subpage的bitmapIdx，如果不是subpage则为0，32bit</span><br></pre></td></tr></table></figure>
<h3 id="Chunk"><span class="post-title-index">1.3.2. </span><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>在初始时，Netty将会一次性获取<code>chunkSize</code>大小的Direct内存（通过<code>DirectByteBuffer</code>持有），<code>chunkSize = maxPages * pageSize</code>。默认情况下最大page数量<code>maxPages = 2048</code>，而单page大小<code>pageSize = 8kiB</code>，所以默认情况下，Netty会分配<code>chunkSize = 16Mib</code>大小的直接内存。  </p>
<p>但显然Netty不可能仅适用一块Chunk。所以更多的Chunk将通过ChunkList进行管理（<code>PoolChunkList</code>），而各个元素就是<code>PoolChunk</code>，他们之间以双向链表的形式进行连接。  </p>
<p>为了提高内存管理效率，避免内存混乱找不到合适的连续空间，Netty还将多个<code>PoolChunkList</code>按照使用量进行分类，并且将<code>PoolChunkList</code>也做成双向链表，并存放在<code>PoolArena</code>中。（arena是舞台的意思）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.PoolArena#PoolArena</span></span><br><span class="line">q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);</span><br><span class="line">q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);</span><br><span class="line">q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);</span><br><span class="line">q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);</span><br><span class="line">qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);</span><br><span class="line"><span class="comment">// PoolChunkList(PoolArena&lt;T&gt; arena, PoolChunkList&lt;T&gt; nextList, int minUsage, int maxUsage, int chunkSize)</span></span><br><span class="line"></span><br><span class="line">q100.prevList(q075);</span><br><span class="line">q075.prevList(q050);</span><br><span class="line">q050.prevList(q025);</span><br><span class="line">q025.prevList(q000);</span><br><span class="line">q000.prevList(<span class="keyword">null</span>);</span><br><span class="line">qInit.prevList(qInit);</span><br></pre></td></tr></table></figure><br>所以在chunk级别上，其结构大致是这样的：<br><img src="/2021/02/09/IO-03NettyBasics/NettyChunks.png" alt="NettyChunks"><br>至于为什么q100的空间要写成100%到+∞，可以看一下PoolChunkList的add方法，这样就不需要为q100单独编写没有阈值上限的代码了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.PoolChunkList</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(PoolChunk&lt;T&gt; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk.freeBytes &lt;= freeMinThreshold) &#123;</span><br><span class="line">        nextList.add(chunk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add0(chunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一个Chunk中，其所占有的空间被分割为一个个的page。这些page首先组成一个从头到尾的run。在后面申请内存的时候，将其拆分为一个个小的run。这些小run就通过runAvail数组进行管理。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">splitLargeRun</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">int</span> needPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> totalPages = runPages(handle);  <span class="comment">// 也就是s位置的值</span></span><br><span class="line">    <span class="keyword">int</span> remPages = totalPages - needPages;</span><br><span class="line">    <span class="keyword">if</span> (remPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> runOffset = runOffset(handle);  <span class="comment">// o位置的值</span></span><br><span class="line">        <span class="keyword">int</span> availOffset = runOffset + needPages;</span><br><span class="line">        <span class="keyword">long</span> availRun = toRunHandle(availOffset, remPages, <span class="number">0</span>);</span><br><span class="line">        insertAvailRun(availOffset, remPages, availRun);</span><br><span class="line">        <span class="comment">// not avail</span></span><br><span class="line">        <span class="keyword">return</span> toRunHandle(runOffset, needPages, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mark it as used</span></span><br><span class="line">    handle |= <span class="number">1L</span> &lt;&lt; IS_USED_SHIFT;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以从这个层面上来说，runAvail数组中大尺寸的块在被不断拆分，用剩下的则被放到了runAvail数组中较小尺寸的队列中等待被使用。  </p>
<p>比如在下面这张图中，初始化时所有page合并视作一个run，存放在<code>runsAvail[39]</code>中。<br>当申请内存时，即使只需要1个page大小的空间，在使用后，都会使得<code>runsAvail[39]</code>少于其最少要满足的空间大小（也即<code>chunkSize</code>），所以只能在分配完空间后，将剩余的空间移动到符合条件的queue中，比如<code>runsAvail[38]</code>。<br>当再需要分配一个小空间时，因为即使少了这样一块空间，<code>runsAvail[38]</code>中的这个run的尺寸依然大于要求的最小空间，所以直接缩减这个run，不需要拆分。<br>这时，如果需要一大块内存，缩减这个run之后，剩余的尺寸不满足<code>runsAvail[38]</code>的最低要求时，就只能将这个run的剩余部分拆分至其他合适的queue中了。  </p>
<p><img src="/2021/02/09/IO-03NettyBasics/runsAvailAllocate.png" alt="runsAvailAllocate"></p>
<p>上面的每个queue中都只有一个run。来看看多个run的情况。<br>当空间被释放时，自然就会有空闲的page被放入<code>runAvail</code>中。当多个page是连续的，则会被合并为1个run，并放到合适的queue中；如果多个run之间并不能彼此连续，则queue会根据他们的pageOffset（也就是page的序号）将它们排序，这样在分配内存时，总是会取到合适的run中offset最小的那一个。<br><img src="/2021/02/09/IO-03NettyBasics/runsAvaiFree.png" alt="runsAvaiFree"></p>
<h3 id="Subpage"><span class="post-title-index">1.3.3. </span><a href="#Subpage" class="headerlink" title="Subpage"></a>Subpage</h3><p>往大了不够可以增加chunk，但对于每一个page占用8KiB的空间而言有时也比较浪费，所以在page中又增加了一层subpage，用于对更小内存的管理（但对内存管理还是按page进行的）。  </p>
<p>当所需要的空间小于1个page大小时，会首先判断是否有已经使用过的subpage，如果有，则直接使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.PoolArena#tcacheAllocateSmall</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tcacheAllocateSmall</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity, <span class="keyword">final</span> <span class="keyword">int</span> sizeIdx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="comment">// 查找是否有已经使用过的同尺寸的Subpage（可能还有空间可以放得下）</span></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = smallSubpagePools[sizeIdx];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needsNormalAllocation;</span><br><span class="line">        <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">            <span class="comment">// 因为可能会进行链表操作，需要上锁</span></span><br><span class="line">            <span class="keyword">final</span> PoolSubpage&lt;T&gt; s = head.next;</span><br><span class="line">            <span class="comment">// 如果head.next指向自己，说明没有创建过Subpage</span></span><br><span class="line">            <span class="comment">// 如果已经创建过Subpage，则head.next会指向一个PoolSubpage对象，用于记录使用情况</span></span><br><span class="line">            needsNormalAllocation = s == head;</span><br><span class="line">            <span class="keyword">if</span> (!needsNormalAllocation) &#123;</span><br><span class="line">                <span class="comment">// 已经使用过了Subpage，直接向这块Page中填充剩余的部分</span></span><br><span class="line">                <span class="keyword">assert</span> s.doNotDestroy &amp;&amp; s.elemSize == sizeIdx2size(sizeIdx);</span><br><span class="line">                <span class="keyword">long</span> handle = s.allocate();</span><br><span class="line">                <span class="keyword">assert</span> handle &gt;= <span class="number">0</span>;</span><br><span class="line">                s.chunk.initBufWithSubpage(buf, <span class="keyword">null</span>, handle, reqCapacity, cache);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsNormalAllocation) &#123;</span><br><span class="line">            <span class="comment">// 这个尺寸上没有创建过Subpage，则从`runsAvail`中取出一个合适大小的run用作Subpage</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                allocateNormal(buf, reqCapacity, sizeIdx, cache);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        incSmallAllocation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>否则会从<code>runsAvail</code>中取出一个合适大小的run用作Subpage。上面的allocateNormal最终会调用PoolChunk的allocate方法。当申请的尺寸属于small大小时，就会执行allocateSubpage：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.buffer.PoolChunk</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allocate</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> sizeIdx, PoolThreadCache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sizeIdx &lt;= arena.smallMaxSizeIdx) &#123;</span><br><span class="line">        <span class="comment">// small</span></span><br><span class="line">        handle = allocateSubpage(sizeIdx);</span><br><span class="line">        <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSubpage</span><span class="params">(handle)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// allocateRun</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init buf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，allocateSubpage会首先在PoolArena中找出一个合适大小的run。那么合适的大小是多大呢？首先会将所申请的size调整到某个预设的大小上（通过sizeIdx，这样可以让许多相差不大的尺寸都使用一个大小，代价仅仅是浪费几个字节）并取出这个大小的代表head，然后计算出所需要的run的合适尺寸，接下来就是将这个subpage的信息记录到PoolSubpage对象中，然后将这个对象添加到head.next上（这样，在上面tcacheAllocateSmall方法中就可以通过next指针判断是否还需要重新取run作为subpage了）。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> sizeIdx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据sizeIdx取出合适大小的PollSubpage的head</span></span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(sizeIdx);</span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;   <span class="comment">// 因为可能会涉及链表操作，上锁</span></span><br><span class="line">        <span class="comment">// 计算需要的run的尺寸</span></span><br><span class="line">        <span class="keyword">int</span> runSize = calculateRunSize(sizeIdx);</span><br><span class="line">        <span class="comment">// 通过allocateRun获取该尺寸的run</span></span><br><span class="line">        <span class="keyword">long</span> runHandle = allocateRun(runSize);</span><br><span class="line">        <span class="keyword">if</span> (runHandle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> runOffset = runOffset(runHandle);</span><br><span class="line">        <span class="keyword">assert</span> subpages[runOffset] == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 这个run中每一个subpage的尺寸</span></span><br><span class="line">        <span class="keyword">int</span> elemSize = arena.sizeIdx2size(sizeIdx);</span><br><span class="line">        <span class="comment">// 将这个run中的subpage使用情况记录到head.next中</span></span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, pageShifts, runOffset, runSize(pageShifts, runHandle), elemSize);</span><br><span class="line">        subpages[runOffset] = subpage;</span><br><span class="line">        <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么run是如何划分为subpage的呢？奥秘在<code>calculateRunSize</code>中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateRunSize</span><span class="params">(<span class="keyword">int</span> sizeIdx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxElements = <span class="number">1</span> &lt;&lt; pageShifts - SizeClasses.LOG2_QUANTUM;</span><br><span class="line">    <span class="keyword">int</span> runSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nElements;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> elemSize = arena.sizeIdx2size(sizeIdx);</span><br><span class="line">    <span class="comment">// 下面的2个while循环，保证了runSize始终是pageSize和elemSize的最小公倍数        </span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        runSize += pageSize;</span><br><span class="line">        nElements = runSize / elemSize;</span><br><span class="line">    &#125; <span class="keyword">while</span> (nElements &lt; maxElements &amp;&amp; runSize != nElements * elemSize);</span><br><span class="line">    <span class="keyword">while</span> (nElements &gt; maxElements) &#123;</span><br><span class="line">        runSize -= pageSize;</span><br><span class="line">        nElements = runSize / elemSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以，目标runSize总是page大小和subpage大小的最小公倍数。比如pageSize是8KiB，申请的空间是2Kib，那么1个page就够了，则这个page会被划分为4块，每块都是2KiB。  </p>
<h1 id="NioEventLoop"><span class="post-title-index">2. </span><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h1><p>之前在写java原生的NIO代码时，在线程中通过一个死循环执行selector.select()以及事件处理，在Netty中同样如此。这个死循环在NioEventLoop中被使用。  </p>
<p><img src="/2021/02/09/IO-03NettyBasics/NioEventLoopTree.png" alt="NioEventLoopTree"></p>
<h2 id="寻找循环入口"><span class="post-title-index">2.1. </span><a href="#寻找循环入口" class="headerlink" title="寻找循环入口"></a>寻找循环入口</h2><p>从上面的UML中可以看出，<code>NioEventLoop</code>继承自接口<code>Executor</code>，所以必然存在<code>execute(Runnable)</code>方法。该方法在其父类<code>SingleThreadEventExecutor</code>中被实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.concurrent.SingleThreadEventExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略参数校验</span></span><br><span class="line">    execute(task, !(task <span class="keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么这个task就是NIO的事件循环EventLoop么？并不是。<br>往下看调用栈，可以发现，这个task很快就通过addTask方法交给了一个名为taskQueue的队列进行缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.concurrent.SingleThreadEventExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task);  <span class="comment">// call taskQueue.offer(task);</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                    reject = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个execute方法很快就结束了，并没有发现什么无限循环在其中。但是这个方法通过<code>startThread()</code>另外开启了一个线程，让人很是在意。<br>在多层调用后来到了<code>doStartTrhead()</code>方法中，可以看到除了参数校验，核心语句只有一个：<code>executor.execute(new Runnable(){...});</code>由此可见，在<code>NioEventLoop</code>中，通过<code>execute()</code>方法，再开启了一个线程，执行另外的事情。那么这个“另外的事情”具体有哪些呢？我们来看看这个匿名的<code>Runnable</code>的<code>run()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.concurrent.SingleThreadEventExecutor </span></span><br><span class="line">thread = Thread.currentThread();    <span class="comment">// 将新线程保存在NioEventLoop的thread域中</span></span><br><span class="line"><span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">updateLastExecutionTime();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    SingleThreadEventExecutor.<span class="keyword">this</span>.run();   <span class="comment">// 执行NioEventLoop的run()方法</span></span><br><span class="line">    success = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅地收尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="select循环"><span class="post-title-index">2.2. </span><a href="#select循环" class="headerlink" title="select循环"></a>select循环</h2><p>那么显而易见，核心过程就在<code>run()</code>中了。由于<code>SingleThreadEventExecutor</code>的<code>run()</code>是abstract的，真正的实现在<code>NioEventLoop</code>中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果taskQueue中有任务，则尝试select()并立即返回select的数量 &gt;= 0</span></span><br><span class="line">                <span class="comment">// 否则返回SelectStrategy.SELECT</span></span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:   <span class="comment">// -2</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:  <span class="comment">// -3</span></span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:     <span class="comment">// -1</span></span><br><span class="line">                    <span class="comment">// 没有其他任务，则执行select()</span></span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = NONE; <span class="comment">// 没有定时任务(Integer.MAX_VALUE)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            <span class="comment">// 再次判断，没有任务的话，执行select，并保证在下一个定时任务完成时结束select</span></span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 将下一个醒来时间设置为“已醒来(-1)”以示区别</span></span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// 发生异常后的处理</span></span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            selectCnt++;    <span class="comment">// select的次数，用于日志</span></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">boolean</span> ranTasks;</span><br><span class="line">            <span class="comment">// radio表示IO时间占总时间的比例</span></span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// radio==100表示不启用IO吞吐量控制</span></span><br><span class="line">                <span class="comment">// 会在处理selectedKey之后，立即执行所有堆积的task</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ranTasks = runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果存在若干个待处理的selectedKey，且ioRadio启用（!=100)</span></span><br><span class="line">                <span class="comment">// 则先处理selectKey</span></span><br><span class="line">                <span class="comment">// 然后根据ioTime计算taskTime并执行task</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    <span class="comment">// 执行一定时间的任务，并返回执行的任务数量</span></span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 执行最少数量的任务，以期尽早返回，避免长时间阻塞IO</span></span><br><span class="line">                ranTasks = runAllTasks(<span class="number">0</span>); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// select每一定次数，输出日志</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> ... &#123;</span><br><span class="line">            <span class="comment">// 各种异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="IO与任务的处理"><span class="post-title-index">2.3. </span><a href="#IO与任务的处理" class="headerlink" title="IO与任务的处理"></a>IO与任务的处理</h2><p>可能有人要问了，这里的task具体是指什么？这里的task其实就是指的各种register、unregister、interstOp调整等操作。  </p>
<p>由于IO和task混在一个线程中进行（至于原因可以参考<a href="https://www.wudi.space/2021/02/08/IO-02MultiplexSelector/#错误的写法导致的死锁">上一篇博文</a>）这里Netty提供了一个参数ioRatio用于控制IO和task的时间占比。  </p>
<ul>
<li>当ioRatio在1~99时，表示IO的时间占IO+task时间的百分比。此时在task时间过长时，会仅执行部分task</li>
<li>当ioRatio为100时，表示取消IO占比的调整，有多少task就执行多少task（而不是IO时间为100%，那样task无法执行就可能出现死锁了）</li>
<li>ioRatio的默认值为50，且不可以是0</li>
</ul>
<p>这样，在ioRatio≠100时，会在执行processSelectedKeys时（这个过程是阻塞的IO）进行计时，然后根据ioRatio计算出可供task执行的时间。接下来就是调用<code>runAllTasks(long)</code>了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.concurrent.SingleThreadEventExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从scheduledTaskQueue中取出task装入taskQueue中，直到scheduledTaskQueue被取完，或者taskQueue被装满</span></span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="comment">// 从taskQueue中取出一个task</span></span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果taskQueue空了，则执行后处理，并返回false</span></span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果参数timeoutNanos为0，则deadline为0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timeoutNanos &gt; <span class="number">0</span> ? ScheduledFutureTask.nanoTime() + timeoutNanos : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        safeExecute(task);  <span class="comment">// 执行一个task</span></span><br><span class="line">        runTasks ++;</span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// nanoTime()调用成本比较高，每64（0x40）个任务判断一下时间是否超过deadline</span></span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// 超时则不在取task，结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取下一个task，如果为空则结束循环</span></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    afterRunningAllTasks(); <span class="comment">// 执行后处理并返回</span></span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于获取nanoTime的方法调用成本比较高，每执行完一个task就调用一下非常不经济，因此这里通过<code>(runTasks &amp; 0x3F)</code>每64个任务才会判断一次是否超时。根据官方的说法，这个<code>0x3F</code>未来可能会改成可配置的，在目前的版本中还是一个hard code。  </p>
<p>关于<code>afterRunningAllTasks()</code>这个方法，目前官方对它的定位是<code>@UnstableApi</code>，也就是甚至可能在bugfix时就会对其进行修改甚至删除。在NioEventLoop中，这个方法被用于“在目前正在执行的任务或下一个任务完成后，立即执行一个额外的插队任务”，可以通过<code>NIOEventLoop.executeAfterEventLoopIteration(Runnable task)</code>进行。  </p>
<h2 id="Netty对selectedKeys的骚操作"><span class="post-title-index">2.4. </span><a href="#Netty对selectedKeys的骚操作" class="headerlink" title="Netty对selectedKeys的骚操作"></a>Netty对selectedKeys的骚操作</h2><p>任务都看完了，那接下来就是真正的IO操作了。不过在此之前，需要给大家展示一下Netty的骚操作。在NioEventLoop的<code>openSelector()</code>方法中，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = Class.forName(<span class="string">"sun.nio.ch.SelectorImpl"</span>, <span class="keyword">false</span>, PlatformDependent.getSystemClassLoader());   <span class="comment">// 获取SelectorImpl的Class对象</span></span><br><span class="line"><span class="comment">// 上面做了一定的意会，不是原始代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取SelectorImpl中的selectedKeys和publicSelectedKeys2个field</span></span><br><span class="line">Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line">Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从selectorProvider中获取一个SelectorImpl的实例</span></span><br><span class="line"><span class="keyword">final</span> Selector unwrappedSelector = provider.openSelector();</span><br><span class="line"><span class="comment">// 创建一个SelectionKey的集合</span></span><br><span class="line"><span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"><span class="comment">// 将selector中的selectedKeys和publicSelectedKeys替换为自定义的selectedKeySet</span></span><br><span class="line">selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br></pre></td></tr></table></figure><br>自定义的这个selectedKeySet是<code>io.netty.channel.nio.SelectedSelectionKeySet</code>类型的，继承自<code>AbstractSet&lt;SelectionKey&gt;</code>，内部不再是通过Map进行存储，而是直接通过一个初始大小为1024的定长数组存放keys。而在<code>SelectorImpl</code>也就是原本的selector中，这两个Set都是通过ConcurrentHashMap进行封装的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.SelectedSelectionKeySet</span></span><br><span class="line">SelectedSelectionKeySet() &#123;</span><br><span class="line">    keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sun.nio.ch.SelectorImpl</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(sp);</span><br><span class="line">    keys = ConcurrentHashMap.newKeySet();</span><br><span class="line">    selectedKeys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    publicKeys = Collections.unmodifiableSet(keys);</span><br><span class="line">    publicSelectedKeys = Util.ungrowableSet(selectedKeys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而且甚至各个操作都没有加锁，因为Netty的时间循环都是在单线程中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    keys[size++] = o;</span><br><span class="line">    <span class="keyword">if</span> (size == keys.length) </span><br><span class="line">        increaseCapacity(); <span class="comment">// 长度翻倍，arraycopy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以说，Netty为了效率是无所不用其极啊。</p>
<h2 id="对selectedKeys的IO操作"><span class="post-title-index">2.5. </span><a href="#对selectedKeys的IO操作" class="headerlink" title="对selectedKeys的IO操作"></a>对selectedKeys的IO操作</h2><p>接下来就到<code>processSelectedKeys()</code>方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里就可以看到，如果selectedKeys替换成功，就会执行<code>processSelectedKeysOptimized()</code>方法，而如果替换失败，则只能通过selector.selectedKeys()取出默认的keys集合。<br>对默认keys集合进行处理，只能通过iterator进行，而自定义的keys集合因为是通过数组实现的（而且这个数组还是package-proteced的，在包内可以直接访问），所以直接通过数组访问就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;    <span class="comment">// 设为null，助GC</span></span><br><span class="line">        <span class="comment">// 默认情况下，attachment存放的是jdk channel对应的netty NioChannel</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">// 根据ACCEPT、WRITE、READ等事件执行读写IO</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户自定义的处理任务</span></span><br><span class="line">            processSelectedKey(k, (NioTask&lt;SelectableChannel&gt;)a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略重新select</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用户自定义的处理任务没什么好看的，对连接、读、写的操作的processSelectedKey就相对比较熟悉了，其核心代码就是根据ops进行对应的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.NioEventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略前后的校验和异常捕获</span></span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略OP_CONNECT</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// OP_WRITE</span></span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">        ch.unsafe().forceFlush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并OP_READ和OP_ACCEPT，对ServerSocketChannel而言ACCEPT时读，对SocketChannel而言READ时读</span></span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">        unsafe.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么，最终，<code>unsafe.read()</code>又做了些什么来读取相关的数据或者将新连接accept呢？<br>对于新连接的处理，会通过NioMessageUnsafe进行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 读取数据到readBuf中，返回是否读取到了数据（1或0）</span></span><br><span class="line">            <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">            <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                closed = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allocHandle.incMessagesRead(localRead);</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        exception = t;  <span class="comment">// 记录异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">        <span class="comment">// 即使发生异常，也会先将已经读取到的数据fireChannelRead</span></span><br><span class="line">        readPending = <span class="keyword">false</span>;</span><br><span class="line">        pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    readBuf.clear();</span><br><span class="line">    pipeline.fireChannelReadComplete(); <span class="comment">// 通知数据读取完毕</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果发生了异常，fireExceptionCaught</span></span><br><span class="line">        closed = closeOnReadError(exception);</span><br><span class="line">        pipeline.fireExceptionCaught(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而对于普通消息的处理会通过<code>NioByteUnsafe</code>进行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);  <span class="comment">// 分配内存，过程见上</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));<span class="comment">// 从缓冲区读取数据</span></span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 省略没有读到数据的处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将数据fire到pipeline中</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>; <span class="comment">// null out for gc</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());<span class="comment">// 直到读完</span></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete(); <span class="comment">// 发送读完通知</span></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 发生了异常也要把能读的数据fireRead后，再fireExceptionCaught</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byteBuf.isReadable()) &#123;</span><br><span class="line">                readPending = <span class="keyword">false</span>;</span><br><span class="line">                pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                byteBuf.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        pipeline.fireExceptionCaught(cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 省略finally收尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，到这里，可以发现，无论是建立连接accept的事件，还是对channel进行读字节流，在读取完成后，都会通过pipeline的fireChannelRead将读取到的message交给用户自行处理。  </p>
<p>这个pipeline到底怎么工作的，具体的过程将在下一章进行介绍。  </p>
<h1 id="Netty-Pipeline"><span class="post-title-index">3. </span><a href="#Netty-Pipeline" class="headerlink" title="Netty Pipeline"></a>Netty Pipeline</h1><p>Netty的Pipeline是一个容器，用于承载对在Netty中进出的数据的处理方法。<br>数据结构上，Pipiline可以认为是一个双向链表，而各个处理的handle就是链表中的元素。在数据进出时，通过在双向链表中的前后移动，就可以实现对各个handle中功能的调用。<br>举个常见的例子，通常对于进出的数据，我们都有加解密、日志等需求，那么从入到出大概就是下图的样子：<br><img src="/2021/02/09/IO-03NettyBasics/NettyPipeline.png" alt="NettyPipeline">。  </p>
<h2 id="ChannelInboundHandler和ChannelOutboundHandler"><span class="post-title-index">3.1. </span><a href="#ChannelInboundHandler和ChannelOutboundHandler" class="headerlink" title="ChannelInboundHandler和ChannelOutboundHandler"></a>ChannelInboundHandler和ChannelOutboundHandler</h2><p>Netty关于Pipeline及其存储的Handle有这样的要求。<br>首先根据功能，Handle分为<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>两类。对于<code>ChannelInboundHandler</code>，通常有如下方法供用户实现，其主要功能是面向用户侧的状态或数据事件触发：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface io.netty.channel.ChannelInboundHandler</span></span><br><span class="line"><span class="comment">// 当channel注册时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 当channel注销时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// channel连接完成时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// channel失去连接时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// channel中数据已经读好时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// channel的本次读事件已经全部完成时触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// channel的用户事件时触发（如关闭Input通道）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// channel的writable state改变时触发（比如连接存续但是无法写时）</span></span><br><span class="line"><span class="comment">// 见io.netty.channel.AbstractChannel.AbstractUnsafe#flush0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 发生异常时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><br>另外，还有<code>ChannelOutboundHandler</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.ChannelOutboundHandler</span></span><br><span class="line"><span class="comment">// （服务端）将SocketAddreess与channel绑定，执行成功后触发fireChannelActive</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// （客户端）执行连接，执行成功后触发fireChannelActive</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 执行断开连接，执行完成后触发fireChannelInactive</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 执行关闭channel，执行完成后触发fireChannelInactive，以及Unregistered</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 注销本channel，执行完成后触发fireChannelUnregistered</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 执行读（将数据从缓冲区读到buffer中），读取完成后执行fireChannelRead等方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 执行写（将msg写到缓冲区中让网卡发送）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="comment">// 执行flush（强制网卡缓冲区数据发送）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><br>所以总结一下，<code>ChannelInboundHandler</code>主要用于事件响应或回调，也即在事件发生后进行处理（比如读“完成”后对读取到的数据进行处理），是用户侧的；而<code>ChannelOutboundHandler</code>主要用于发出某个指令（比如<code>read()</code>的参数列表中就没有数据，也不会将读到的数据返回<code>read()</code>的调用者），是面向硬件或者系统的。  </p>
<p><img src="/2021/02/09/IO-03NettyBasics/ChannelInOutBoundHandlerAndDefaultFire.png" alt="ChannelInOutBoundHandlerAndDefaultFire">  </p>
<p>注意，上面所说的触发关系仅仅是在Netty-all-4.1.59.Final中的默认触发情况，其他版本中可能会有所不同，而且当自己实现<code>ChannelOutboundHandler</code>时，也可以根据自己的需要去fire其他的事件。  </p>
<p>此外，还有一种Handler叫做DuplexHandler，同时继承自<code>ChannelInboundHandler</code>和<code>ChannelOutboundHandler</code>。这种Handler就可以同时承担这两方面的职责</p>
<h2 id="Inbound和Outbound在Pipeline中的查找方向"><span class="post-title-index">3.2. </span><a href="#Inbound和Outbound在Pipeline中的查找方向" class="headerlink" title="Inbound和Outbound在Pipeline中的查找方向"></a>Inbound和Outbound在Pipeline中的查找方向</h2><p>与ChannelInBoundHandler和OutBoundHandler不同的是，在handler中进行链式调用时，也需要考虑其Bound的方向。<br>比如在某个ChannelInBoundHandler的实现中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf)msg;</span><br><span class="line">    ctx.writeAndFlush(getReply(in));</span><br><span class="line">    ctx.fireChannelRead(ctx, doHandle(in));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过ctx.write和ctx.fireChannelRead两个方法，都可以将ByteBuf转移给另一个Handler去(修改后再)写或者（继续）读。但是他们所调用的Handler是不同的（这个应该可以理解吧，除非Handler是Duplex的，不然要么只能响应ChannelInBound事件，要么只能响应ChannelOutBound事件），而且甚至在pipeline的链表中查找的方向也是不同的。  </p>
<p>来看一段源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 省略其他</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(flush ? (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">        next.invokeWriteAndFlush(m, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.invokeWrite(m, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在同一个实现类中，write（含writeAndFlush）与fireChannelRead在调用具体的ChannelHandler去执行时，前者是通过<code>findContextOutbond</code>，而后者是通过findContextInbound。这两者的区别在哪里呢：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannelHandlerContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextOutbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">    EventExecutor currentExecutor = executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，两者就是复制粘贴的关系，唯一的区别就是，findOutbound时，循环体内是<code>ctx = ctx.prev</code>，而findInbound是<code>ctx = ctx.next</code>。这里就可以看出来Outbound是向前查找合适的handler，而Inbound是向后查找合适的handler。<br>所以原则上对输入的处理要放在后面，对输出的处理要放在前面。而且不论对于输入还是输出，越靠前的数据往往被包装的层级越多，越靠后的则越接近业务数据。当然，考虑到异常是Inbound的，所以一般情况下会在最后插入一个异常处理的handler。那么对于本章开头的那个输入输出逻辑，其各个handler在pipeline中的排布可能是下面图中的样子（不绝对，顺序应当根据业务逻辑调整，比如日志到底放在那里）：<br><img src="/2021/02/09/IO-03NettyBasics/NettyHandlePipeline.png" alt="IO-03NettyBasics/NettyHandlePipeline"><br>其中绿色的是<code>ChannelInbondHandler</code>，蓝色的是<code>ChannelOutboundHandler</code>。  </p>
<h2 id="真实的Pipeline"><span class="post-title-index">3.3. </span><a href="#真实的Pipeline" class="headerlink" title="真实的Pipeline"></a>真实的Pipeline</h2><p>上面所说的pipeline其实只是为了方便叙述而简化的模型，真正的pipeline内部并不是直接承载着Handler，而是通过<code>ChannelHandlerContext</code>去承载。在其抽象实现<code>AbstractChannelHandlerContext</code>中，有2个指针，这就是pipeline中的链表关节：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.AbstractChannelHandlerContext</span></span><br><span class="line"><span class="keyword">volatile</span> AbstractChannelHandlerContext next;</span><br><span class="line"><span class="keyword">volatile</span> AbstractChannelHandlerContext prev;</span><br></pre></td></tr></table></figure><br>而在<code>ChannelPipeline</code>的实现<code>DefaultChannePipeline</code>中，存在两个指针，它们就会指向首尾各1个<code>AbstractChannelHandlerContext</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline</span></span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head;</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br></pre></td></tr></table></figure><br>但是如果有心的话，在运行时对pipeline下断点，会惊讶地发现无论是<code>head</code>还是<code>tail</code>，指向的都不是我们自定义的<code>ChannelHandler</code>。而是<code>DefaultChannelPipeline</code>中实现的两个内部类<code>HeadContext</code>和<code>TailContext</code>，均继承自<code>AbstractChannelHandlerContext</code>，而且都实现了所有的<code>ChannelInboundHandler</code>的接口（也就是上面提到的fireXXX等）和<code>ChannelOutboundHandler</code>中的接口（也就是上面提到的bind、read、write等）。这是要干什么呢？  </p>
<p>对于<code>HeadContext</code>，可以看一下源码，其关于<code>ChannelOutboundHandler</code>的那些接口，都相当于<code>io.netty.channel.Channel.Unsafe</code>的同名方法的代理；而关于<code>ChannelInboundHandler</code>的那些接口，则直接通过<code>ctx</code>向后调用同名方法。<br>继续往下，可以看到这个<code>Unsafe</code>接口的实现很多，但都很明确，那就是调用具体的（Epoll、Select、KQueue等）的实现类来进行实际的read、write、bind操作。<br>那么<code>HeadContext</code>的作用就很清楚了，在调用Outbound系列方法时，通过<code>HeadContext</code>兜底，让自定义的排在最前面的OutboundHandler在调用诸如<code>ctx.write</code>时，可以真正触发向网卡“写”的操作。  </p>
<p>同理，对于<code>TailContext</code>，它是Inbound方向上的兜底。比如exceptionCaught方法，当最后一个自定义handler仍然执行<code>ctx.fireExceptionCaught(ctx, throwable)</code>，<code>TailContext</code>就可以将其log下来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline.TailContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">    onUnhandledInboundException(cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.warn(<span class="string">"An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception."</span>, cause);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ctx-read-不要也罢？"><span class="post-title-index">3.4. </span><a href="#ctx-read-不要也罢？" class="headerlink" title="ctx.read()不要也罢？"></a>ctx.read()不要也罢？</h2><p>最后，可能会有人问，ChannelOutBoundHandler的read()有什么用，从来都没有调用过，不是也依然每次都能够自动进入<code>ChannelRead()</code>方法么？  </p>
<p>这是因为Netty庞大的默认配置，不信的话，在初始化<code>NioServerSocketChannel</code>的时候，进行这样的设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NioServerSocketChannel server = <span class="keyword">new</span> NioServerSocketChannel();</span><br><span class="line">server.config().setAutoRead(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><br>你会发现没有触发<code>fireChannelRead()</code>了。而这时，只能在所有需要的场合下，提前发出<code>ctx.read()</code>指令，比如在NioChannel Actived之后、在每一次read之后等等，很多细碎的细节，但是自己控制实在是太麻烦了，写多了怕消耗性能，写少了又怕在某个环节忘记read造成卡死。所以如果不是需要精确控制的话，乖乖使用autoRead吧。  </p>
<h2 id="一个测试用例"><span class="post-title-index">3.5. </span><a href="#一个测试用例" class="headerlink" title="一个测试用例"></a>一个测试用例</h2><p>下面是一个用来测试InboundHandler和OutboundHandler的测试用例，代码已经放在<a href="https://github.com/discko/learnio/tree/master/trynetty/src/main/java/space/wudi/learnio/nettyInOut" target="_blank" rel="noopener">我的GitHub仓库</a>中了，欢迎随时取用。  </p>
<p>其主要作用是，客户端每发送过来一个字符串，则在经过InBoundHandler的时候都将自己的handlerName拼接在上面，并返回客户端。<br>handler的顺序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverPipeline.addLast(<span class="keyword">new</span> InHandler(group, (remoteAddress -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ChannelHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut0"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> InHandler(<span class="string">"ClientIn1"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut1"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> InHandler(<span class="string">"ClientIn2"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut2"</span>));</span><br><span class="line">    <span class="keyword">return</span> handlers;</span><br><span class="line">&#125;), <span class="string">"AcceptIn1"</span>));</span><br></pre></td></tr></table></figure><br>比如客户端发送“Hello”，则应该收到的是：</p>
<blockquote>
<p>HelloClientIn1<br>HelloClientIn1ClientIn2</p>
</blockquote>
<p>下图是调用过程，与预期是完全一致的：<br><img src="/2021/02/09/IO-03NettyBasics/NettyBoundHandlerPropagation.png" alt="NettyBoundHandlerPropagation"><br>图中红色的是HeadContext和TailContext，蓝色的是自定义的handler。  </p>
<h2 id="为什么需要以如此麻烦的方式给childHandler赋值"><span class="post-title-index">3.6. </span><a href="#为什么需要以如此麻烦的方式给childHandler赋值" class="headerlink" title="为什么需要以如此麻烦的方式给childHandler赋值"></a>为什么需要以如此麻烦的方式给childHandler赋值</h2><h3 id="问题的描述"><span class="post-title-index">3.6.1. </span><a href="#问题的描述" class="headerlink" title="问题的描述"></a>问题的描述</h3><p>在新手期，可能会遇到这样的问题，比如通过ServerBootstrap给childHandler赋值时，本来是这么写的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler();</span><br><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(clientHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>甚至在简单测试时都没有问题。但是当同时有2个客户端连接过来时，控制台上马上就会打印出这样的红字：<br><img src="/2021/02/09/IO-03NettyBasics/SharableHandler.png" alt="Sharable handler"><br>提示信息也很清晰，那就是加入的这个handler没有标注为@Sharable的。<br>加上这个注解是很简单的，但是为什么呢？甚至会问，为什么要通过ChannelInitializer这个抽象类去传递childHandler而直接传入呢？  </p>
<p>同样，在不使用Bootstrap的时候，同样可能会出现这样的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ChannelHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut0"</span>));</span><br><span class="line">handlers.add(<span class="keyword">new</span> InHandler(<span class="string">"ClientIn1"</span>));</span><br><span class="line">handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut1"</span>));</span><br><span class="line">handlers.add(<span class="keyword">new</span> InHandler(<span class="string">"ClientIn2"</span>));</span><br><span class="line">handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut2"</span>));</span><br><span class="line">NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">3</span>);</span><br><span class="line">NioServerSocketChannel server = <span class="keyword">new</span> NioServerSocketChannel();</span><br><span class="line">server.pipeline().addLast(<span class="keyword">new</span> InHandler(group, handlers), <span class="string">"AcceptIn1"</span>));</span><br><span class="line"><span class="comment">// new InHandler(NioEventLoopGroup, List&lt;ChildHandler&gt;)</span></span><br></pre></td></tr></table></figure><br>写的时候初看觉得没什么问题，顺序也决定好了，东西也传进去了。但是在连接时，同样会报出@Sharable的错误。  </p>
<h3 id="问题的解释"><span class="post-title-index">3.6.2. </span><a href="#问题的解释" class="headerlink" title="问题的解释"></a>问题的解释</h3><p>这个问题其实解释起来也很简单，甚至不需要去翻源码。<br>当我们的ServerHandler触发ChannelRead事件后，我们知道，是新的客户端来了，这时我们会为新的客户端的NioChannel的pipeline中加入In和Outbound的handler。  </p>
<p>而如果加入到pipeline中的handler是在外面就new好的，那么显然无论新建多少客户端channel，他们中的handler都是相同的那几个对象。<br>相同的对象就意味着他们在执行各个事件时是共享的，不但可能存在并发隐患，甚至记录在handler中的channel的状态也会因为handler的共享而被混淆。  </p>
<p>正因如此，如果确定自己的handler即使被多个channel共享也不会有问题，那么就通过@Sharable，显式地标记其为可以共享的，否则就需要一个工具函数，在accept客户端channel时，现场new出这些handler。<br>所以ChannelInitializer发挥的其实是一个Functional Interface的功能，如果要求不高的话，完全可以像我一样，用一个<code>Function&lt;SocketAddress, Collection&lt;ChannelHandler&gt;&gt;</code>来代替，这样就可以开心地一个lambda写过去了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverPipeline.addLast(<span class="keyword">new</span> InHandler(group, (remoteAddress -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ChannelHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut0"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> InHandler(<span class="string">"ClientIn1"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut1"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> InHandler(<span class="string">"ClientIn2"</span>));</span><br><span class="line">    handlers.add(<span class="keyword">new</span> OutHandler(<span class="string">"ClientOut2"</span>));</span><br><span class="line">    <span class="keyword">return</span> handlers;</span><br><span class="line">&#125;), <span class="string">"AcceptIn1"</span>));</span><br></pre></td></tr></table></figure><br>当然，ChannelInitializer的可取之处在于他本身就是一个handler，可以直接将其加入到pipeline中，就不需要额外的代码将自定义的handler取出来加入pipeline中了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/IO/" rel="tag"># IO</a>
              <a href="/tags/NIO/" rel="tag"># NIO</a>
              <a href="/tags/Netty4/" rel="tag"># Netty4</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/08/IO-02MultiplexSelector/" rel="prev" title="IO-02-多路复用网络选择器的设计">
      <i class="fa fa-chevron-left"></i> IO-02-多路复用网络选择器的设计
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ByteBuf"><span class="nav-text">1. ByteBuf</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内部结构和基本操作"><span class="nav-text">1.1. 内部结构和基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ByteBuf的分类"><span class="nav-text">1.2. ByteBuf的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分配位置"><span class="nav-text">1.2.1. 分配位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否复用内存空间"><span class="nav-text">1.2.2. 是否复用内存空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否使用Unsafe"><span class="nav-text">1.2.3. 是否使用Unsafe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-text">1.2.4. 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PooledByteBuf的创建"><span class="nav-text">1.3. PooledByteBuf的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#名词解释"><span class="nav-text">1.3.1. 名词解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chunk"><span class="nav-text">1.3.2. Chunk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Subpage"><span class="nav-text">1.3.3. Subpage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NioEventLoop"><span class="nav-text">2. NioEventLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#寻找循环入口"><span class="nav-text">2.1. 寻找循环入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select循环"><span class="nav-text">2.2. select循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO与任务的处理"><span class="nav-text">2.3. IO与任务的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty对selectedKeys的骚操作"><span class="nav-text">2.4. Netty对selectedKeys的骚操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对selectedKeys的IO操作"><span class="nav-text">2.5. 对selectedKeys的IO操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty-Pipeline"><span class="nav-text">3. Netty Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ChannelInboundHandler和ChannelOutboundHandler"><span class="nav-text">3.1. ChannelInboundHandler和ChannelOutboundHandler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inbound和Outbound在Pipeline中的查找方向"><span class="nav-text">3.2. Inbound和Outbound在Pipeline中的查找方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#真实的Pipeline"><span class="nav-text">3.3. 真实的Pipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ctx-read-不要也罢？"><span class="nav-text">3.4. ctx.read()不要也罢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个测试用例"><span class="nav-text">3.5. 一个测试用例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要以如此麻烦的方式给childHandler赋值"><span class="nav-text">3.6. 为什么需要以如此麻烦的方式给childHandler赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题的描述"><span class="nav-text">3.6.1. 问题的描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题的解释"><span class="nav-text">3.6.2. 问题的解释</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="吴迪"
      src="/images/avatar.jpg?raw=true">
  <p class="site-author-name" itemprop="name">吴迪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备17000391号 </a>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴迪</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      var config = {
        theme:'default',
        logLevel:'fatal',
        securityLevel:'strict',
        startOnLoad:true,
        arrowMarkerAbsolute:false,

        er:{
          diagramPadding:20,
          layoutDirection:'TB',
          minEntityWidth:100,
          minEntityHeight:75,
          entityPadding:15,
          stroke:'gray',
          fill:'honeydew',
          fontSize:12,
          useMaxWidth:true,
        },
        flowchart:{
          diagramPadding:8,
          htmlLabels:true,
          curve:'linear',
        },
        sequence:{
          diagramMarginX:50,
          diagramMarginY:10,
          actorMargin:50,
          width:150,
          height:65,
          boxMargin:10,
          boxTextMargin:5,
          noteMargin:10,
          messageMargin:35,
          messageAlign:'center',
          mirrorActors:true,
          bottomMarginAdj:1,
          useMaxWidth:true,
          rightAngles:false,
          showSequenceNumbers:false,
        },
        gantt:{
          titleTopMargin:25,
          barHeight:20,
          barGap:4,
          topPadding:50,
          leftPadding:75,
          gridLineStartPadding:35,
          fontSize:11,
          fontFamily:'"Open-Sans", "sans-serif"',
          numberSectionStyles:4,
          axisFormat:'%Y-%m-%d',
        }
      };
      mermaid.initialize(config);
    }
  </script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
